{"meta":{"title":"熠熙轻雷","subtitle":"blog","description":"","author":"Devying","url":"https://devying.github.io","root":"/"},"pages":[{"title":"书单","date":"2019-11-09T14:31:33.201Z","updated":"2019-11-07T10:29:47.429Z","comments":false,"path":"books/index.html","permalink":"https://devying.github.io/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-11-09T14:31:33.193Z","updated":"2019-11-09T13:26:46.966Z","comments":false,"path":"about/index.html","permalink":"https://devying.github.io/about/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-11-09T14:31:33.205Z","updated":"2019-11-07T10:29:47.429Z","comments":true,"path":"links/index.html","permalink":"https://devying.github.io/links/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-11-09T14:31:33.202Z","updated":"2019-11-07T10:29:47.429Z","comments":false,"path":"categories/index.html","permalink":"https://devying.github.io/categories/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2019-11-09T14:31:33.179Z","updated":"2019-11-07T10:29:47.428Z","comments":false,"path":"/404.html","permalink":"https://devying.github.io/404.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-11-09T14:31:33.206Z","updated":"2019-11-07T10:29:47.429Z","comments":false,"path":"repository/index.html","permalink":"https://devying.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-11-09T14:33:21.781Z","updated":"2019-11-09T14:33:21.781Z","comments":false,"path":"tags/index.html","permalink":"https://devying.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"golang反射","slug":"golang反射","date":"2020-02-06T06:21:21.947Z","updated":"2020-02-06T07:32:45.472Z","comments":true,"path":"2020/02/06/golang反射/","link":"","permalink":"https://devying.github.io/2020/02/06/golang%E5%8F%8D%E5%B0%84/","excerpt":"","text":"反射类型reflect.TypeOf Typereflect.ValueOf Value 其中面对类型时要区分Type和Kind。前者表示真实类型（静态类型），后者表示其基础结构（底层类型） 12345678type X intfunc main() &#123; var a X = 100 t := reflect.TypeOf(a) fmt.Println(t.Name(), t.Kind())&#125;//X int 除了通过实际对象获取类型外，也可以直接构造一些基础复合类型。 123456789func main() &#123; a := reflect.ArrayOf(10, reflect.TypeOf(byte(0))) // m := reflect.MapOf(reflect.TypeOf(string(\"\")), reflect.TypeOf(int(0))) m := reflect.MapOf(reflect.TypeOf(\"\"), reflect.TypeOf(0)) fmt.Println(a, m)&#125;//m的两种方式都可以 均输出[10]uint8 map[string]int 方法Elem 返回指针、数组、切片、字典（值）或通道的元素类型。所以记住一点 这些类型需要用Elem方法来返回基类型、并且结构体必须得用指针的方式来返回基类型。其他的类型不用了 123456789101112131415161718func main() &#123; var p *int var a [4]int var s []string var m map[int]string var c chan int fmt.Println(reflect.TypeOf(p).Elem()) fmt.Println(reflect.TypeOf(a).Elem()) fmt.Println(reflect.TypeOf(s).Elem()) fmt.Println(reflect.TypeOf(m).Elem()) fmt.Println(reflect.TypeOf(c).Elem())&#125;intintstringstringint 只有在获取结构体的基类型后才能遍历它的字段。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556type user struct &#123; name string age int&#125;type manager struct &#123; user title string ad addr&#125;type addr struct &#123; road string num int&#125;func main() &#123; var m manager t := reflect.TypeOf(m) //main.manager //结构类型反射后 Kind 是指针 if t.Kind() == reflect.Ptr &#123; t = t.Elem() //获取到指针的基类型 &#125; for i := 0; i &lt; t.NumField(); i++ &#123; f := t.Field(i) fmt.Println(f.Name, f.Type, f.Offset) //获取到字段的名称、类型、偏移量 ft := f.Type //ft 已经是基类型 if f.Anonymous &#123; //输出匿名字段 fmt.Println(ft, ft.Kind()) //main.user struct ft已经是基类型 for x := 0; x &lt; ft.NumField(); x++ &#123; af := ft.Field(x) fmt.Println(\"\\t\", af.Name, af.Type) &#125; &#125; //不是匿名但是二级结构体 if !f.Anonymous &amp;&amp; ft.Kind() == reflect.Struct &#123; //ft = ft.Elem() fmt.Println(ft, ft.Kind()) for j := 0; j &lt; ft.NumField(); j++ &#123; fmt.Println(\"\\t\", ft.Field(j).Name, ft.Field(j).Type) &#125; &#125; &#125;&#125;user main.user 0main.user struct name string age inttitle string 24ad main.addr 40main.addr struct road string num int上面也可以直接判定 ft.Kind() == reflect.Struct 对于匿名字段，可用多级索引直接访问。 1234567891011121314151617181920212223type user struct &#123; name string age int&#125;type manager struct &#123; user title string a addr&#125;type addr struct &#123; pro string num int&#125;func main() &#123; var m manager t := reflect.TypeOf(m) name, _ := t.FieldByName(\"name\") fmt.Println(name.Name, name.Type) // name string 按名称查找 age := t.FieldByIndex([]int&#123;1，0&#125;) //按多级索引查找 第一个数表示 第一层的 下标 ，第二个数是第二层下标 ,如果只有一层那么只保留第一个数。 fmt.Println(age.Name, age.Type)&#125; FiledByName 不支持多级名称，如有同名遮蔽，须通过匿名字段二次获取。另外反射可以探知当前包或者包外的非导出结构成员。 12345678910111213141516171819202122232425262728func main() &#123; var s http.Server t := reflect.TypeOf(s) for i := 0; i &lt; t.NumField(); i++ &#123; fmt.Println(t.Field(i).Name) &#125;&#125;AddrHandlerTLSConfigReadTimeoutReadHeaderTimeoutWriteTimeoutIdleTimeoutMaxHeaderBytesTLSNextProtoConnStateErrorLogdisableKeepAlivesinShutdownnextProtoOncenextProtoErrmulistenersactiveConndoneChanonShutdown 利用反射还可以提取tag辅助判断方法 Implements、ConvertibleTo、AssignableTo 都是运行期进行动态调用和赋值所必需的。 12345678910111213141516type X intfunc (X) String() string &#123; return \"+OK\"&#125;func main() &#123; var a X t := reflect.TypeOf(a) //implements 不能直接使用类型作为参数，所以需要用一个这种类型的值 st := reflect.TypeOf((*fmt.Stringer)(nil)).Elem() fmt.Println(t.Implements(st)) //true it := reflect.TypeOf(0) fmt.Println(t.ConvertibleTo(it)) //true t类型可以转为int fmt.Println(t.AssignableTo(st), t.AssignableTo(it)) //t类型可以赋给st t类型不可以赋给int&#125; 值和Type获取类型信息不同，Value专注于对象实例数据读写。在前面的章节中提到过，接口变量会复制对象，且是unaddressable的，所以你要想修改目标对象，就必须用指针。 12345678910func main() &#123; a := 100 va, vp := reflect.ValueOf(a), reflect.ValueOf(&amp;a).Elem() fmt.Println(va.CanAddr(), va.CanSet()) fmt.Println(vp.CanAddr(), vp.CanSet()) //就算传入指针，一样需要通过Elem获取目标对象。因为接口存储的指针本身不能寻址和进行设置操作的。 //否则你可以试试 vp.SetInt(20) fmt.Println(a)&#125; 注意，不能对非导出字段直接进行设置操作，无论是当前包还是外包。 123456789101112131415161718192021222324type User struct &#123; Name string code int&#125;func main() &#123; p := new(User) v := reflect.ValueOf(p).Elem() name := v.FieldByName(\"Name\") code := v.FieldByName(\"code\") fmt.Printf(\"name: cannaddr = %v,canset = %v\\n\", name.CanAddr(), name.CanSet()) fmt.Printf(\"code: cannaddr = %v,canset = %v\\n\", code.CanAddr(), code.CanSet()) // name: cannaddr = true,canset = true // code: cannaddr = true,canset = false if name.CanSet() &#123; name.SetString(\"Tom\") &#125; if code.CanAddr() &#123; //转成 unsafe.Pointer再转成*int *(*int)(unsafe.Pointer(code.UnsafeAddr())) = 100 &#125; fmt.Printf(\"%+v\\n\", *p) //&#123;Name:Tom code:100&#125;&#125; Value.Pointer和Value.Int 等方法类似，将Value.data 存储的数据转为指针，目标必须是指针类型。而UnsafeAddr返回任何CanAddr Value.Data 地址（相当于&amp;取地址操作）,比如Elem后的Value,以及字段成员地址。以结构体里的指针类型字段为例，Pointer返回该字段所保存的地址，而UnsafeAddr 返回该字段自身的地址（结构对象地址+偏移量）。可通过Interface方法进行类型推断和转换 1234567891011121314151617181920212223type user struct &#123; Name string Age int&#125;func main() &#123; u := user&#123; \"zhangsan\", 60, &#125; v := reflect.ValueOf(&amp;u) if !v.CanInterface() &#123; println(\"CanInterface:fail !\") return &#125; if p, ok := v.Interface().(*user); ok &#123; p.Age++ fmt.Printf(\"%+v\", u) //&#123;Name:zhangsan Age:61&#125; return &#125; println(\"CanInterface:fail !\")&#125;&#123;Name:zhangsan Age:61&#125;% 当然我们也可以用Value.Int、Bool 等方法进行类型转换，但失败时会引发panic，且不支持ok-idiom.符合类型对象设置如下： 123456c := make(chan int, 4)v := reflect.ValueOf(c)if v.TrySend(reflect.ValueOf(100)) &#123; fmt.Println(v.TryRecv())&#125;//100 true 接口有两种nil状态，这一直是个潜在的麻烦。解决方法是用IsNil判定是否为nil 123456var a interface&#123;&#125; = nilvar b interface&#123;&#125; = (*int)(nil)fmt.Println(a == nil)fmt.Println(b == nil, reflect.ValueOf(b).IsNil())// true// false true 当然前面我们说过了只有当 tab 和 data 都为空时 interface才是空，所以也可以用unsafe转换后直接判断iface.data是否为零值。 123456789101112131415func main() &#123; var a interface&#123;&#125; = nil var b interface&#123;&#125; = (*int)(nil) fmt.Println(a == nil) fmt.Println(b == nil, reflect.ValueOf(b).IsNil()) //tab 和 data b_iface := (*[2]uintptr)(unsafe.Pointer(&amp;b)) fmt.Printf(\"%v\\n\", b_iface) //&amp;[17434240 0] fmt.Println(b_iface[0], b_iface[1]) //17434240 0 var c interface&#123;&#125; = 30 c_iface := (*[2]uintptr)(unsafe.Pointer(&amp;c)) //tab 和 data的地址 fmt.Printf(\"%v\\n\", c_iface) //&amp;[17454272 17695344] 这是两个地址转成了uintptr&#125; Value里面的某些方法未实现ok-idom或返回error,所以需要自己判断返回的是否为Zero Value在获取字段的时候，我们需要IsValid方法判断是否是合法的字段 方法动态调用方法，需要按In列表准备好所需参数即可 12345678910111213141516171819type X struct&#123;&#125;func (X) Test(x, y int) (int, error) &#123; return x + y, fmt.Errorf(\"err: %d\", x+y)&#125;func main() &#123; var a X v := reflect.ValueOf(&amp;a) m := v.MethodByName(\"Test\") in := []reflect.Value&#123; reflect.ValueOf(1), reflect.ValueOf(2), &#125; out := m.Call(in) for _, v := range out &#123; fmt.Println(v) &#125;&#125; 那么对于变参来说用CallSlice要更方便一些。 12345678910111213141516171819202122232425type X struct&#123;&#125;func (X) Format(s string, a ...interface&#123;&#125;) string &#123; return fmt.Sprintf(s, a...)&#125;func main() &#123; var a X v := reflect.ValueOf(&amp;a) m := v.MethodByName(\"Format\") in := []reflect.Value&#123; reflect.ValueOf(\"%s = %d\"), reflect.ValueOf(\"x\"), reflect.ValueOf(100), &#125; out := m.Call(in) fmt.Println(out) out = m.CallSlice([]reflect.Value&#123; reflect.ValueOf(\"%s = %d\"), reflect.ValueOf([]interface&#123;&#125;&#123;\"x\", 100&#125;), //只需一个interface&#123;&#125;即可 &#125;) fmt.Println(out)&#125;[x = 100][x = 100] 构建反射库提供了内置函数 make 和 new 对应的操作，其中有意思的是 MakeFunc.可用它实现通用模板，适应不同数据类型。 12","categories":[],"tags":[]},{"title":"golang并发和通道","slug":"golang并发和通道","date":"2018-06-03T12:23:02.000Z","updated":"2020-02-06T06:23:05.536Z","comments":true,"path":"2018/06/03/golang并发和通道/","link":"","permalink":"https://devying.github.io/2018/06/03/golang%E5%B9%B6%E5%8F%91%E5%92%8C%E9%80%9A%E9%81%93/","excerpt":"","text":"单向尽管可以用make 创建单向通道，但那没有任何意义。通常使用类型转换来获取单向通道，并分别赋予操作双方 12345678910111213141516171819202122232425262728293031func main() &#123; var wg sync.WaitGroup wg.Add(2) c := make(chan int) var send chan&lt;- int = c var recv &lt;-chan int = c go func() &#123; defer wg.Done() for x := range recv &#123; println(\"recv:\", x) &#125; &#125;() go func() &#123; defer wg.Done() defer close(c) for i := 0; i &lt; 3; i++ &#123; println(\"send:\", i) send &lt;- i &#125; &#125;() wg.Wait()&#125;send: 0send: 1recv: 0recv: 1send: 2recv: 2 不能再单向通道上做逆向操作，同理不能close出通道，无法将单向通道转为双向的。通道关闭后&lt;-chan 就会解除阻塞for range 也会结束for { v,ok := &lt;-chan}ok 会返回false。 一次性事件用close效率更好，没有多余开销。连续或多样性事件，可传递不同数据标志实现。还可使用sync.Cond实现单播或者广播事件。处理多个通道可以用select随机选择 123456789101112131415161718192021222324252627282930313233343536373839404142434445package mainimport ( \"sync\")func main() &#123; var wg sync.WaitGroup wg.Add(2) a, b := make(chan int), make(chan int) go func() &#123; defer wg.Done() for &#123; var ( name string x int ok bool ) select &#123; case x, ok = &lt;-a: name = \"a\" case x, ok = &lt;-b: name = \"b\" &#125; if !ok &#123; //如果有任一通道关闭就终止 return &#125; println(name, x) &#125; &#125;() go func() &#123; defer wg.Done() defer close(a) defer close(b) for i := 0; i &lt; 10; i++ &#123; //随机选择通道发送 select &#123; case a &lt;- i: case b &lt;- i * 10: &#125; &#125; &#125;() wg.Wait()&#125; 对于closed 或者 nil 通道。发送和接收操作都有相应的规则：注意一点无论收发，nil通道都会阻塞。而关闭或者重复关闭nil通道都会panic。如果要等全部通道消息处理结束，可以将已完成的通道设为nil。这样它就会被阻塞，不再被select选中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package mainimport ( \"sync\")func main() &#123; var wg sync.WaitGroup wg.Add(3) a, b := make(chan int), make(chan int) go func() &#123; defer wg.Done() for &#123; select &#123; case x, ok := &lt;-a: if !ok &#123; a = nil break &#125; println(\"a\", x) case x, ok := &lt;-b: if !ok &#123; b = nil break &#125; println(\"b\", x) &#125; if a == nil &amp;&amp; b == nil &#123; return &#125; &#125; &#125;() go func() &#123; defer wg.Done() defer close(a) for i := 0; i &lt; 10; i++ &#123; a &lt;- i &#125; &#125;() go func() &#123; defer wg.Done() defer close(b) for i := 0; i &lt; 5; i++ &#123; b &lt;- i * 10 &#125; &#125;() wg.Wait()&#125;a 0b 0a 1a 2a 3b 10b 20b 30a 4a 5a 6b 40a 7a 8a 9 即便是同一个通道select 也可以随机选择case。当所有通道都不可用时，select会执行default语句。 模式通常使用工厂方法将goroutine和通道绑定 12345678910111213141516171819202122232425type receiver struct &#123; sync.WaitGroup data chan int&#125;func newReceiver() *receiver &#123; r := &amp;receiver&#123; data: make(chan int), &#125; r.Add(1) go func() &#123; defer r.Done() for x := range r.data &#123; println(\"recv:\", x) &#125; &#125;() return r&#125;func main() &#123; r := newReceiver() r.data &lt;- 1 r.data &lt;- 2 close(r.data) r.Wait()&#125; 鉴于通道本身就是一个并发安全的队列，可作为ID generator、Pool 等用途 1234567891011121314151617181920212223242526272829type pool chan []bytefunc newPool(cap int) pool &#123; return make(chan []byte, cap)&#125;func (p pool) get() []byte &#123; var v []byte select &#123; case v = &lt;-p: default: v = make([]byte, 10) //Pool如果是空的那么就新建一个 &#125; return v&#125;func (p pool) put(b []byte) &#123; select &#123; case p &lt;- b: //用完后放回去 default: //Pool满了直接丢去 &#125;&#125;func main() &#123; pl := newPool(12) //大小为12 v := pl.get() //使用这个v pl.put(v) //放回这个v fmt.Println(pl)&#125; 捕获信号 123456789101112131415161718192021222324252627282930313233var exits = &amp;struct &#123; sync.RWMutex funcs []func() signals chan os.Signal&#125;&#123;&#125;func atexit(f func()) &#123; exits.Lock() defer exits.Unlock() exits.funcs = append(exits.funcs, f)&#125;func waitExit() &#123; if exits.signals == nil &#123; exits.signals = make(chan os.Signal) signal.Notify(exits.signals, syscall.SIGINT, syscall.SIGTERM) &#125; exits.RLock() for _, f := range exits.funcs &#123; defer f() &#125; exits.RLock() &lt;-exits.signals&#125;func main() &#123; atexit(func() &#123; println(\"exit 1 ----&gt;\") &#125;) atexit(func() &#123; println(\"exit 2 ----&gt;\") &#125;) waitExit()&#125;^Cexit 2 ----&gt;exit 1 ----&gt; 性能将发往通道的数据打包，减少传输次数，可有效提升性能。从实现上来说，通道队列依旧使用锁同步机制，单词获取更多数据（批处理），可改善因频繁加锁造成的性能问题。我们可以使用数组对数据打包（把数据放进数组里面，然后只需要进一次通道就OK，如果用切片的话，会造成更多内存分配次数，如果数据多了） 资源泄露防止通道阻塞问题 同步将Mutex作为匿名字段时，相关方法必须实现为 pointer-recerver,否则会因复制导致锁机制失效。下面这个例子中 读写都是成对出现的，也就是说锁失效了。所以把方法接受者改成*T就OK了 1234567891011121314151617181920212223242526272829type data struct &#123; sync.Mutex&#125;func (d *data) test(s string) &#123; d.Lock() defer d.Unlock() for i := 0; i &lt; 5; i++ &#123; println(s, i) time.Sleep(time.Second) &#125;&#125;func main() &#123; var wg sync.WaitGroup wg.Add(2) //var d *data = &amp;data&#123;&#125; 上下两个方式都可以 var d data go func() &#123; defer wg.Done() d.test(\"read\") &#125;() go func() &#123; defer wg.Done() d.test(\"write\") &#125;() wg.Wait()&#125; 当然我们也可以用嵌入*Mutex来避免复制问题。需要下面这么改下也可以。 1234type data struct &#123; *sync.Mutex&#125;var d data = data&#123;new(sync.Mutex)&#125; 应该将Mutex锁粒度控制在最小范围内，及早释放。所以别总是deferMutex不支持递归锁，即便是在同一 goroutine下也会导致死锁func main(){ var m sync.Mutex m.Lock() { m.Lock() m.Unlock() } m.Unlock()}()fatal error :all goroutines are asleep - deadlock!建议： 对性能要求高的，避免使用defer Unlock 读写并发时，RWMutex 性能会更好 对单个数据写保护，可尝试使用原子操作。 执行严格测试，尽可能打开数据竞争检查。 导入包导入方式有四种不同的方式 1234import \"github.com/foo/bar\" 默认方式:bar.Aimport X \"github.com/foo/bar\" 别名方式:X.Aimport . \"github.com/foo/bar\" 简便方式:Aimport _ \"github.com/foo/bar\" 初始化方式：无法引用，仅用来初始化目标包 简便方式常用于单元测试中，不推荐正式项目中使用。另外，初始化方式仅仅是为了让目标包的初始化函数得以执行，而非引用其成员。","categories":[{"name":"golang","slug":"golang","permalink":"https://devying.github.io/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://devying.github.io/tags/golang/"}]},{"title":"golang 接口总结","slug":"golang接口","date":"2018-05-28T08:13:11.000Z","updated":"2020-02-05T09:44:53.932Z","comments":true,"path":"2018/05/28/golang接口/","link":"","permalink":"https://devying.github.io/2018/05/28/golang%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"定义接口代表一种调用契约，是多个方法声明的集合从内部看接口本身也是一种结构类型，只是编译器会对其作出很多限制。 不能有字段 不能定义自己的方法 只能声明方法不能实现 可嵌入其他接口类型接口通常以er作为名称后缀，方法名是声明组成部分，但是参数可不同或者省略。123456789101112131415161718192021222324type tester interface &#123; test() string() string&#125;type data struct&#123;&#125;func (*data) test() &#123;&#125;func (data) string() string &#123; return \"+OK\"&#125;func main() &#123; var d data //var t tester = d //cannot use d (type data) as type tester in assignment: //data does not implement tester (test method has pointer receiver) var t tester = &amp;d println(t.string())&#125;很明显我们根据上一章的内容知道 *T的方法集中包含了所有T的方法集 如何接口没有任何方法声明，那么就是一个空接口(interface{}),它的用途类似于面向对象里面的根类型Object，可被赋值为任何类型的对象。接口变量默认值是nil。如果实现接口的类型支持，可做相等运算。1234567var t1, t2 interface&#123;&#125; println(t1 == nil, t1 == t2) //true true t1, t2 = 100, 100 println(t1 == t2) //true t1, t2 = map[string]int&#123;&#125;, map[string]int&#123;&#125; println(t1 == t2) //panic: runtime error: comparing uncomparable type map[string]int 可以像匿名字段那样，嵌入其他接口。目标类型方法集中必须拥有包含嵌入接口方法在内的全部方法才算是实现了该接口。1234567891011121314151617181920212223type stringer interface &#123; string() string&#125;type tester interface &#123; stringer test()&#125;type data struct&#123;&#125;func (*data) test() &#123;&#125;func (data) string() string &#123; return \"+OK\"&#125;func main() &#123; var d data var t tester = &amp;d t.test() println(t.string())&#125;//+OK 超集接口变量可隐式转为子集，反过来不行1234567891011121314151617181920212223242526type stringer interface &#123; string() string&#125;type tester interface &#123; stringer test()&#125;type data struct&#123;&#125;func (*data) test() &#123;&#125;func (data) string() string &#123; return \"+OK\"&#125;func pp(a stringer) &#123; println(a.string())&#125;func main() &#123; var d data var t tester = &amp;d pp(t) //隐式转换为子集接口 var s stringer = t //超集转换为子集 println(s.string()) //var t2 tester = s //stringer does not implement tester (missing test method)&#125; 支持匿名接口类型，可直接用于变量定义，或作为结构字段类型。12345678910111213141516171819202122type data struct&#123;&#125;func (data) string() string &#123; return \"+OK\"&#125;type node struct &#123; i interface &#123; //作为结构体字段类型 string() string &#125;&#125;func main() &#123; var t interface &#123; string() string &#125; = data&#123;&#125; //直接用于变量定义 n := node&#123; i: t, &#125; println(n.i.string())&#125; 执行机制接口使用一个名为itab的结构存储运行期间所需的相关类型信息12345678910type iface struct&#123; tab *itab //类型信息 data unsafe.Pointer //实际对象指针&#125;type itab struct&#123; inter *interfacetype //接口类型 _type *_type //实际对象类型 fun [1]uintptr //实际对象方法地址&#125; 1234567891011121314151617type Ner interface &#123; a() b(int) c(string) string&#125;type N intfunc (N) a() &#123;&#125;func (*N) b(int) &#123;&#125;func (*N) c(string) string &#123; return \"+OK\" &#125;func main() &#123; var n N var t Ner = &amp;n t.a() println(t.c(\"\"))&#125; 另外接口还有一个重要特征：将对象复制给接口变量时，会复制该对象。并且我们甚至无法修改接口存储的复制品，因为它也是不可寻址的。即便将其复制出来，用本地变量修改后，依然无法对iface.data 赋值。解决的办法就是将对象指针赋值给接口，那么接口内存储的就是指针的复制品。我们来试试12345678910111213141516type data struct &#123; x int&#125;func main() &#123; d := data&#123;100&#125; var t interface&#123;&#125; = d println(t.(data).x) t.(data).x = 20 //cannot assign to t.(data).x p := &amp;t.(data) //cannot take the address of t.(data) var t1 interface&#123;&#125; = &amp;d //对象指针赋值给接口 println(t1.(*data)) //0xc000030728 t1.(*data).x = 200 println(t1.(*data).x)//200&#125; 只有当接口变量 内部的两个指针itab和data都为nil时，接口才等于nil。1234567var a interface&#123;&#125; = nilvar b interface&#123;&#125; = (*int)(nil)println(a == nil, b == nil) //true false(gdb) info localsb = &#123;_type = 0x10557e0 &lt;type.*+27744&gt;, data = 0x0&#125;a = &#123;_type = 0x0, data = 0x0&#125; 也正是这样会有一个容易被忽视的错误。1234567891011121314151617181920212223type TestError struct&#123;&#125;func (*TestError) Error() string &#123; return \"error\"&#125;func abc(x int) (int, error) &#123; var err *TestError if x &lt; 0 &#123; err = new(TestError) x = 0 &#125; else &#123; x += 100 &#125; return x, err //这里这个err 是有类型的 所以你用err != nil 问题就出现了&#125;func main() &#123; x, err := test(100) if err != nil &#123; panic(err) // &#125; println(x)&#125; 类型转换类型推断可以将变量还原为原始类型，或用来判定是否实现了某个更具体的接口类型。12345678910111213141516171819type data intfunc (d data) String() string &#123; return fmt.Sprintf(\"data:%d\", d)&#125;func main() &#123; var d data = 15 var x interface&#123;&#125; = d if n, ok := x.(fmt.Stringer); ok &#123; fmt.Printf(\"%#v\\n\", n) //15 fmt.Println(n) //data:15 &#125; if d2, ok := x.(data); ok &#123; fmt.Printf(\"%#v\\n\", d2) //15 fmt.Println(d2) //data:15 &#125; e := x.(error) //panic: interface conversion: main.data is not error: missing method Error println(e)&#125; 另外我们还可以用switch语句在多种类型间做出推断匹配。123456789101112131415var y interface&#123;&#125; = func(x int) string &#123; return fmt.Sprintf(\"d:%d\", x) &#125;switch v := y.(type) &#123;case nil: println(\"nil\")case *int: println(*v)case func(int) string: println(v(100))case fmt.Stringer: fmt.Println(v)default: println(\"unknow\")&#125; 技巧让编译器检查，确保类型实现了指定接口。123456789101112type x intfunc init() &#123; var _ fmt.Stringer = x(0)&#125;func main() &#123; fmt.Println(\"===\")&#125;./in.go:10:6: cannot use x(0) (type x) as type fmt.Stringer in assignment: x does not implement fmt.Stringer (missing String method) 定义函数类型，让相同签名的函数自动实现某个接口12345678910111213141516type FuncString func() stringfunc (f FuncString) String() string &#123; return f()&#125;func main() &#123; var t fmt.Stringer = FuncString(func() string &#123; return \"hello boy\" &#125;) fmt.Println(t) fmt.Println(\"===\")&#125;hello boy===","categories":[{"name":"golang","slug":"golang","permalink":"https://devying.github.io/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://devying.github.io/tags/golang/"}]},{"title":"golang 方法总结","slug":"golang方法","date":"2018-05-19T07:23:02.000Z","updated":"2020-02-05T09:43:23.698Z","comments":true,"path":"2018/05/19/golang方法/","link":"","permalink":"https://devying.github.io/2018/05/19/golang%E6%96%B9%E6%B3%95/","excerpt":"","text":"定义方法是对象实例绑定的特殊函数，方法和函数的区别是前者有前置实例接收参数（receiver），编译器以此确定方法所属类型。我们可以为当前包，以及除接口和指针以外的任何类型定义方法。 12345678910type N intfunc (n N) toString() string &#123; return fmt.Sprintf(\"%#x\", n)&#125;func main() &#123; var a N = 25 println(a.toString())&#125;//0x19 方法同样不支持重载。receiver参数名没有限制，按惯例会选用简短有意义的名称。如方法内部并不引用实例，可以省略参数名，仅保留类型 1234type N intfun (N) test()&#123; println(\"hi\")&#125; 方法可以看作特殊的函数，那么receiver的类型自然可以是基础类型或指针类型。这会关系到调用时对象实例是否被复制。 1234567891011121314151617181920type N intfunc (n N) value() &#123; n++ fmt.Printf(\"v: %p,%v\\n\", &amp;n, n)&#125;func (n *N) pointer() &#123; (*n)++ fmt.Printf(\"v: %p,%v\\n\", n, *n)&#125;func main() &#123; var a N = 25 a.value() a.pointer() fmt.Printf(\"a: %p,%v\\n\", &amp;a, a)&#125;// v: 0xc000086008,26 // receiver 被复制// v: 0xc000086000,26// a: 0xc000086000,26// 可以使用实例值或者指针调用方法，编译器会根据方法 receiver类型自动在基础类型和指针类型间转换,但是不能用多级指针调用方法。 1234567891011121314151617181920func (n N) value() &#123; n++ fmt.Printf(\"v: %p,%v\\n\", &amp;n, n)&#125;func (n *N) pointer() &#123; (*n)++ fmt.Printf(\"v: %p,%v\\n\", n, *n)&#125;func main() &#123; var a N = 25 a.value() a.pointer() fmt.Printf(\"a: %p,%v\\n\", &amp;a, a) b := &amp;a b.value() b.pointer() fmt.Printf(\"b: %p,%v\", b, *b) c := &amp;b c.value() //错误：calling method value with receiver c (type **N) requires explicit dereference&#125; 指针类型的receiver必须是合法的指针(包括nil)，或能获取实例地址。 1234567891011type X struct&#123;&#125;func (x *X) test() &#123; println(\"hi\", x)&#125;func main() &#123; var a *X a.test() //hi 0x0 X&#123;&#125;.test() //cannot call pointer method on X literal&#125; 如何选择方法的receiver类型呢 要修改实例状态，用*T。 无需修改状态的小对象或者固定值，建议用T。 大对象建议用*T，以减少复制成本。 引用类型、字符串、函数等指针包装对象，直接用T。 若包含Mutex等同步字段，用*T，避免复制造成锁操作无效。 其他无法确定的情况，都用*T 匿名字段可以像访问匿名字段成员那样调用其方法，由编译器负责查找。 12345678910type data struct &#123; sync.Mutex buf [1024]byte&#125;func main() &#123; d := data&#123;&#125; d.Lock() //编译器会处理为sycn.(*Mutex).Lock() 怎么有点断言的意思 defer d.Unlock()&#125; 方法也会有同名遮蔽问题。但是利用这种特性，可实现类似覆盖操作。尽管能直接访问匿名字段的成员和方法，但是它们依然不属于继承关系。 123456789101112131415161718192021type user struct &#123;&#125;type manager struct &#123; user&#125;func (user) toString() string &#123; return \"user\"&#125;func (m manager) toString() string &#123; return m.user.toString() + \";manager\"&#125;func main() &#123; var m manager println(m.toString()) println(m.user.toString())&#125;// user;manager// user 方法集类型有一个与之相关的方法集，这决定了它是否实现了某个接口。 类型T方法集包含所有receiver T方法。 类型T方法集包含了所有receiver T + `T`方法。 匿名嵌入S，T方法集包含了所有receiver S方法。 匿名嵌入S，T方法集包含了所有receiver S+`S`方法。 匿名嵌入S或者S,`T方法集合包含了所有receiver S+*S`方法 可以利用发射测试这些规则。 123456789101112131415161718192021222324type S struct &#123;&#125;type T struct &#123; S&#125;func (S) sVal() &#123;&#125;func (*S) sPtr() &#123;&#125;func (T) tVal() &#123;&#125;func (*T) tPtr() &#123;&#125;func methodSet(a interface&#123;&#125;) &#123; t := reflect.TypeOf(a) for i, n := 0, t.NumMethod(); i &lt; n; i++ &#123; m := t.Method(i) fmt.Println(m.Name, m.Type) &#125;&#125;func main() &#123; var t T methodSet(t) println(\"--------\") methodSet(&amp;t)&#125; 方法集仅影响接口实现和方法表达式转换，与通过实例或者实例指针调用方法无关。实例并不使用方法集，而是直接调用（或通过隐式字段名） 表达式方法和函数一样，除直接调用外，还可以赋值给变量，或作为参数传递。依照具体引用方式的不同，可分为expression 和 value 两种状态 Method Expression通过类型引用的 method expression 会被还原为普通函数样式，receiver 是第一参数，调用时须显式传参。至于类型，可以是T或者*T,只要目标方法存在该类型方法集中即可。//func (n N ) test() 这个底层会转成 func test(n N) 1234567891011121314151617type N intfunc (n N) test() &#123; fmt.Printf(\"test.n: %p, %d\\n\", &amp;n, n)&#125;func main() &#123; var n N = 25 fmt.Printf(\"main.n: %p, %d\\n\", &amp;n, n) f1 := N.test //把方法赋给f1 func(n N) 通过类型(N)引用的 method expression f1(n) //receiver 是第一参数 f2 := (*N).test // func(n *N) 通过类型(*N)引用的 method expression f2(&amp;n) //传递指针 receiver 是第一参数&#125;// main.n: 0xc000080000, 25// test.n: 0xc000080018, 25// test.n: 0xc00008a000, 25 *T是包含了所有T的方法集，所以上面这个例子中 test方法存在*T方法集中（只要目标方法存在该类型方法集中即可）因此我们变更一下看看下面这个例子 1234567891011121314151617type N intfunc (n *N) test() &#123; fmt.Printf(\"test.n: %p, %d\\n\", n, *n)&#125;func main() &#123; var n N = 25 fmt.Printf(\"main.n: %p, %d\\n\", &amp;n, n) f1 := N.test //把方法赋给f1 func(n N) 通过类型(N)引用的 method expression 目标方法test不在类型N的方法集中 f1(n) //receiver 是第一参数 f2 := (*N).test // func(n *N) 通过类型(*N)引用的 method expression f2(&amp;n) //传递指针 receiver 是第一参数&#125;//invalid method expression N.test (needs pointer receiver: (*N).test)//目标方法test() 不在 `T`的方法集中，所以这样就不行 所以这里可以知道，在第一个例子中，尽管你用的是*N 你的receiver类型是指针，但是编译器会保证按原定义类型拷贝传值。(原定义类型是func (n N) test()),同理第二个例子肯定是地址一样的。当然上面的代码也可以一步到位，直接以表达式的方式调用。 123456789101112131415type N intfunc (n N) test() &#123; fmt.Printf(\"test.n: %p, %d\\n\", &amp;n, n)&#125;func main() &#123; var n N = 25 fmt.Printf(\"main.n: %p, %d\\n\", &amp;n, n) N.test(n) (*N).test(&amp;n)&#125;// main.n: 0xc000018080, 25// test.n: 0xc000018098, 25 // test.n: 0xc000088000, 25 同理 123456789101112type N intfunc (n *N) test() &#123; fmt.Printf(\"test.n: %p, %d\\n\", n, *n)&#125;func main() &#123; var n N = 25 fmt.Printf(\"main.n: %p, %d\\n\", &amp;n, n) //f2 := (*N).test // func(n *N) 通过类型(*N)引用的 method expression (*N).test(&amp;n) //传递指针 receiver 是第一参数&#125; Method Value基于实例或者指针引用的method value，参数签名不会改变，依旧按正常方式调用。但当method value 被赋值给变量或者作为参数传递时，会立即计算并复制该方法执行所需的 receiver 对象，与其绑定，以便在稍后执行时，能隐式的传入receiver参数 123456789101112131415161718192021type N intfunc (n N) test() &#123; fmt.Printf(\"test.n: %p, %v\\n\", &amp;n, n)&#125;func main() &#123; var n N = 25 p := &amp;n n++ f1 := n.test //通过实例引用的method value 被赋值给变量 这里复制了n 直接等同于 func test() n++ f2 := p.test //通过指针引用method value 被赋值给变量 而这里复制了*p 所以是27 而不是28 n++ fmt.Printf(\"main.n: %p, %v\\n\", p, n) f1() f2()&#125;// main.n: 0xc000090000, 28// test.n: 0xc000090018, 26// test.n: 0xc00007e008, 27 当method value 作为参数时，会复制含receiver在内的整个method value。 12345678910111213141516171819202122232425type N intfunc (n N) test() &#123; fmt.Printf(\"test.n: %p, %v\\n\", &amp;n, n)&#125;func call(m func()) &#123; m()&#125;func main() &#123; var n N = 25 p := &amp;n fmt.Printf(\"main.n: %p, %v\\n\", p, n) n++ call(n.test) n++ call(p.test)&#125;// main.n: 0xc000082000, 25// test.n: 0xc000082018, 26// test.n: 0xc00008c000, 27 我们把 receiver类型改成指针，那么复制的仅是指针了 1234567891011121314151617181920212223242526type N intfunc (n *N) test() &#123; fmt.Printf(\"test.n: %p, %v\\n\", n, *n)&#125;func main() &#123; var n N = 25 p := &amp;n n++ f1 := n.test n++ f2 := p.test n++ fmt.Printf(\"main.n: %p, %v\\n\", p, n) f1() f2()&#125;// main.n: 0xc000018078, 28// test.n: 0xc000018078, 28// test.n: 0xc000018078, 28 只要 receiver 参数类型正确，使用nil同样可以执行 1234567891011121314151617181920212223type N intfunc (n N) test() &#123; fmt.Printf(\"test.n: %p, %v\\n\", &amp;n, n)&#125;func (*N) pointer() &#123; //fmt.Printf(\"point.n: %p, %v\\n\", n, *n) println(\"====\")&#125;func main() &#123; var a *N var b N a.pointer() (*N)(nil).pointer() (*N).pointer(nil) N.test(b)&#125;============test.n: 0xc00008a000, 0","categories":[{"name":"golang","slug":"golang","permalink":"https://devying.github.io/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://devying.github.io/tags/golang/"}]},{"title":"golang 通道","slug":"golang通道","date":"2018-04-29T16:23:02.000Z","updated":"2020-03-23T15:17:36.926Z","comments":true,"path":"2018/04/30/golang通道/","link":"","permalink":"https://devying.github.io/2018/04/30/golang%E9%80%9A%E9%81%93/","excerpt":"","text":"单向尽管可以用make 创建单向通道，但那没有任何意义。通常使用类型转换来获取单向通道，并分别赋予操作双方 12345678910111213141516171819202122232425262728293031func main() &#123; var wg sync.WaitGroup wg.Add(2) c := make(chan int) var send chan&lt;- int = c var recv &lt;-chan int = c go func() &#123; defer wg.Done() for x := range recv &#123; println(\"recv:\", x) &#125; &#125;() go func() &#123; defer wg.Done() defer close(c) for i := 0; i &lt; 3; i++ &#123; println(\"send:\", i) send &lt;- i &#125; &#125;() wg.Wait()&#125;send: 0send: 1recv: 0recv: 1send: 2recv: 2 不能再单向通道上做逆向操作，同理不能close出通道，无法将单向通道转为双向的。通道关闭后&lt;-chan 就会解除阻塞for range 也会结束for { v,ok := &lt;-chan}ok 会返回false。 一次性事件用close效率更好，没有多余开销。连续或多样性事件，可传递不同数据标志实现。还可使用sync.Cond实现单播或者广播事件。处理多个通道可以用select随机选择 123456789101112131415161718192021222324252627282930313233343536373839404142434445package mainimport ( \"sync\")func main() &#123; var wg sync.WaitGroup wg.Add(2) a, b := make(chan int), make(chan int) go func() &#123; defer wg.Done() for &#123; var ( name string x int ok bool ) select &#123; case x, ok = &lt;-a: name = \"a\" case x, ok = &lt;-b: name = \"b\" &#125; if !ok &#123; //如果有任一通道关闭就终止 return &#125; println(name, x) &#125; &#125;() go func() &#123; defer wg.Done() defer close(a) defer close(b) for i := 0; i &lt; 10; i++ &#123; //随机选择通道发送 select &#123; case a &lt;- i: case b &lt;- i * 10: &#125; &#125; &#125;() wg.Wait()&#125; 对于closed 或者 nil 通道。发送和接收操作都有相应的规则：注意一点无论收发，nil通道都会阻塞。而关闭或者重复关闭nil通道都会panic。如果要等全部通道消息处理结束，可以将已完成的通道设为nil。这样它就会被阻塞，不再被select选中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package mainimport ( \"sync\")func main() &#123; var wg sync.WaitGroup wg.Add(3) a, b := make(chan int), make(chan int) go func() &#123; defer wg.Done() for &#123; select &#123; case x, ok := &lt;-a: if !ok &#123; a = nil break &#125; println(\"a\", x) case x, ok := &lt;-b: if !ok &#123; b = nil break &#125; println(\"b\", x) &#125; if a == nil &amp;&amp; b == nil &#123; return &#125; &#125; &#125;() go func() &#123; defer wg.Done() defer close(a) for i := 0; i &lt; 10; i++ &#123; a &lt;- i &#125; &#125;() go func() &#123; defer wg.Done() defer close(b) for i := 0; i &lt; 5; i++ &#123; b &lt;- i * 10 &#125; &#125;() wg.Wait()&#125;a 0b 0a 1a 2a 3b 10b 20b 30a 4a 5a 6b 40a 7a 8a 9 即便是同一个通道select 也可以随机选择case。当所有通道都不可用时，select会执行default语句。 模式通常使用工厂方法将goroutine和通道绑定 12345678910111213141516171819202122232425type receiver struct &#123; sync.WaitGroup data chan int&#125;func newReceiver() *receiver &#123; r := &amp;receiver&#123; data: make(chan int), &#125; r.Add(1) go func() &#123; defer r.Done() for x := range r.data &#123; println(\"recv:\", x) &#125; &#125;() return r&#125;func main() &#123; r := newReceiver() r.data &lt;- 1 r.data &lt;- 2 close(r.data) r.Wait()&#125; 鉴于通道本身就是一个并发安全的队列，可作为ID generator、Pool 等用途 1234567891011121314151617181920212223242526272829type pool chan []bytefunc newPool(cap int) pool &#123; return make(chan []byte, cap)&#125;func (p pool) get() []byte &#123; var v []byte select &#123; case v = &lt;-p: default: v = make([]byte, 10) //Pool如果是空的那么就新建一个 &#125; return v&#125;func (p pool) put(b []byte) &#123; select &#123; case p &lt;- b: //用完后放回去 default: //Pool满了直接丢去 &#125;&#125;func main() &#123; pl := newPool(12) //大小为12 v := pl.get() //使用这个v pl.put(v) //放回这个v fmt.Println(pl)&#125; 捕获信号 123456789101112131415161718192021222324252627282930313233var exits = &amp;struct &#123; sync.RWMutex funcs []func() signals chan os.Signal&#125;&#123;&#125;func atexit(f func()) &#123; exits.Lock() defer exits.Unlock() exits.funcs = append(exits.funcs, f)&#125;func waitExit() &#123; if exits.signals == nil &#123; exits.signals = make(chan os.Signal) signal.Notify(exits.signals, syscall.SIGINT, syscall.SIGTERM) &#125; exits.RLock() for _, f := range exits.funcs &#123; defer f() &#125; exits.RLock() &lt;-exits.signals&#125;func main() &#123; atexit(func() &#123; println(\"exit 1 ----&gt;\") &#125;) atexit(func() &#123; println(\"exit 2 ----&gt;\") &#125;) waitExit()&#125;^Cexit 2 ----&gt;exit 1 ----&gt; 性能将发往通道的数据打包，减少传输次数，可有效提升性能。从实现上来说，通道队列依旧使用锁同步机制，单词获取更多数据（批处理），可改善因频繁加锁造成的性能问题。我们可以使用数组对数据打包（把数据放进数组里面，然后只需要进一次通道就OK，如果用切片的话，会造成更多内存分配次数，如果数据多了） 资源泄露防止通道阻塞问题 同步将Mutex作为匿名字段时，相关方法必须实现为 pointer-recerver,否则会因复制导致锁机制失效。下面这个例子中 读写都是成对出现的，也就是说锁失效了。所以把方法接受者改成*T就OK了 1234567891011121314151617181920212223242526272829type data struct &#123; sync.Mutex&#125;func (d *data) test(s string) &#123; d.Lock() defer d.Unlock() for i := 0; i &lt; 5; i++ &#123; println(s, i) time.Sleep(time.Second) &#125;&#125;func main() &#123; var wg sync.WaitGroup wg.Add(2) //var d *data = &amp;data&#123;&#125; 上下两个方式都可以 var d data go func() &#123; defer wg.Done() d.test(\"read\") &#125;() go func() &#123; defer wg.Done() d.test(\"write\") &#125;() wg.Wait()&#125; 当然我们也可以用嵌入*Mutex来避免复制问题。需要下面这么改下也可以。 1234type data struct &#123; *sync.Mutex&#125;var d data = data&#123;new(sync.Mutex)&#125; 应该将Mutex锁粒度控制在最小范围内，及早释放。所以别总是deferMutex不支持递归锁，即便是在同一 goroutine下也会导致死锁func main(){ var m sync.Mutex m.Lock() { m.Lock() m.Unlock() } m.Unlock()}()fatal error :all goroutines are asleep - deadlock!建议： 对性能要求高的，避免使用defer Unlock 读写并发时，RWMutex 性能会更好 对单个数据写保护，可尝试使用原子操作。 执行严格测试，尽可能打开数据竞争检查。","categories":[{"name":"golang","slug":"golang","permalink":"https://devying.github.io/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://devying.github.io/tags/golang/"}]},{"title":"golang 结构体总结","slug":"golang结构体","date":"2018-04-18T16:23:02.000Z","updated":"2019-11-17T07:13:20.001Z","comments":true,"path":"2018/04/19/golang结构体/","link":"","permalink":"https://devying.github.io/2018/04/19/golang%E7%BB%93%E6%9E%84%E4%BD%93/","excerpt":"","text":"结构字段名必须唯一，可以用”_”来部位，支持使用自身指针类型成员。字段名、排列顺序属类型组成部分。除对齐处理外，编译器不会优化，调整内存布局。 1234567891011121314151617type node struct &#123; _ int id int next *node&#125;func main() &#123; n1 := node&#123; id: 1, &#125; n2 := node&#123; id: 2, next: &amp;n1, &#125; fmt.Println(n1, n2)&#125;//&#123;0 1 &lt;nil&gt;&#125; &#123;0 2 0xc00006e020&#125; 只有在所有字段类型全部时，才可以做相等操作。 12345678910func main() &#123; d1 := data&#123; x: 1, &#125; d2 := data&#123; x: 1, &#125; fmt.Println(d1 == d2)&#125;//invalid operation: d1 == d2 (struct containing map[string]int cannot be compared) 可以使用指针直接操作结构字段，但不能是多级指针。 123456789101112131415161718192021type user struct &#123; name string age int&#125;func main() &#123; p := &amp;user&#123; name: \"TOM\", age: 22, &#125; p.name = \"TAE\" p.age++ p2 := &amp;p fmt.Println(p, *p2) (*p2).name = \"Jack\" fmt.Println((*p2).name) fmt.Println((*p2).age)&#125;// &amp;&#123;TAE 23&#125; &amp;&#123;TAE 23&#125;// Jack// 23 空结构空结构是指没有字段的结构类型，它比较特殊，因为无论是其自身，还是作为数组元素类型，其长度都是0,但是尽管没有分配数组内存，但依然可以操作元素，对应切片len、cap属性也正常。实际上这类”长度”为零的对象通常都指向runtime.zerobase变量 123456789101112131415161718func main() &#123; var a struct&#123;&#125; var b [100]struct&#123;&#125; var d [100]struct&#123;&#125; println(unsafe.Sizeof(a), unsafe.Sizeof(b)) s := d[:] d[1] = struct&#123;&#125;&#123;&#125; s[2] = struct&#123;&#125;&#123;&#125; fmt.Println(s[3], len(s), cap(s)) // s1 := [10]struct&#123;&#125;&#123;&#125; s2 := s1[:] s3 := [0]int&#123;&#125; fmt.Printf(\"%p,%p,%p\", &amp;s1, &amp;s2[0], &amp;s3)&#125;//0 0//&#123;&#125; 100 100//0x118efd0,0x118efd0,0x118efd0 空结构可以用作通道元素类型，用于事件通知。 12345ch := make(chan struct&#123;&#125;)go func()&#123; ch &lt;- struct&#123;&#125;&#123;&#125;&#125;()&lt;-ch 匿名字段所谓匿名字段，是指没有名字，仅有类型的字段，也被称作嵌入字段或者嵌入类型,这类用法非常常见。如嵌入其他包中的类型，则隐式字段名不包括包名。就是说定义的时候字段是File而非os.File 12345678910111213141516171819202122232425type user struct &#123; name string age int addr os.File&#125;type addr struct &#123; city string road string&#125;func main() &#123; u := user&#123; name: \"tom\", age: 2, addr: addr&#123; city: \"Beijing\", road: \"XiBeiWang\", &#125;, File: os.File&#123;&#125;, &#125; u.city = \"Tianjin\" fmt.Println(u)&#125;//&#123;tom 2 &#123;Tianjin XiBeiWang&#125; &#123;&lt;nil&gt;&#125;&#125; 不仅仅是结构体，除接口指针和多级指针以外的任何命名类型都可以作为匿名字段 1234567891011121314type data struct &#123; *int string&#125;func main() &#123; x := 100 d := data&#123; int: &amp;x, string: \"Abc\", &#125; fmt.Printf(\"%#v\\n\", d)&#125;//main.data&#123;int:(*int)(0xc00007e008), string:\"Abc\"&#125; 12345678type a *inttype b **inttype c interface&#123;&#125;type d struct &#123; *a //embedded type cannot be a pointer b //embedded type cannot be a pointer c //embedded type cannot be a pointer to interface&#125; 不能将基础类型和其指针类型同时嵌入，因为两者隐式名字相同。 1234type file struct&#123; *int int&#125; 虽然可以像普通字段那要访问匿名字段成员，但是会存在重名问题。如果是这样的话就必须要使用显式字段名。如果有多个成员都存在重名情况就必须要使用显式字段名。 123456789101112131415161718192021type file struct &#123; name string&#125;type data struct &#123; file name string&#125;func main() &#123; d := data&#123; name: \"data\", file: file&#123; \"file\", &#125;, &#125; d.name = \"data2\" d.file.name = \"file2\" //使用显式的方式访问 data.file.name fmt.Println(d)&#125;//&#123;&#123;file2&#125; data2&#125; 字段标签字段标签(tag)并不是注释，而是用来对字段进行描述的元数据。尽管它不属于数据成员，但却是类型的组成部分。在运行期间，可用发射获取标签信息。它常常被用作格式校验，数据库关系映射等。 123456789101112131415type user struct &#123; name string `昵称` sex byte `性别`&#125;func main() &#123; u := user&#123;\"Tom\", 1&#125; v := reflect.ValueOf(u) t := v.Type() for i, n := 0, t.NumField(); i &lt; n; i++ &#123; fmt.Printf(\"%s: %v\\n\", t.Field(i).Tag, v.Field(i)) &#125;&#125;// 昵称: Tom// 性别: 1 内存分布不管结构体包含多少字段，其内存总是一次性分配的，各字段在相邻的地址空间按定义顺序排列，当然对于引用类型、字符串和指针，结构内存中只包含其基本（头部）数据。还有，所有匿名字段成员也被包含在内。借助unsafe包中的相关函数，可输出所有字段的偏移量和长度。 12345678910111213141516171819202122232425262728293031323334type point struct &#123; x, y int&#125;type value struct &#123; id int //基本类型 name string //字符串 data []byte //引用类型 next *value //指针类型 point //匿名字段&#125;func main() &#123; v := value&#123; id: 1, name: \"jack\", data: []byte&#123;1, 2, 3, 4&#125;, point: point&#123;x: -100, y: -10&#125;, &#125; fmt.Printf(\"v: %p ~ %x, size: %d, align: %d\\n\", &amp;v, uintptr(unsafe.Pointer(&amp;v))+unsafe.Sizeof(v), unsafe.Sizeof(v), unsafe.Alignof(v)) fmt.Printf(\"id addr: %p offset: %d size: %d\\n\", &amp;v.id, unsafe.Offsetof(v.id), unsafe.Sizeof(v.id)) fmt.Printf(\"name addr: %p offset: %d size: %d\\n\", &amp;v.name, unsafe.Offsetof(v.name), unsafe.Sizeof(v.name)) fmt.Printf(\"data addr: %p offset: %d size: %d\\n\", &amp;v.data, unsafe.Offsetof(v.data), unsafe.Sizeof(v.data)) fmt.Printf(\"next addr: %p offset: %d size: %d\\n\", &amp;v.next, unsafe.Offsetof(v.next), unsafe.Sizeof(v.next)) fmt.Printf(\"pointx addr: %p offset: %d size: %d\\n\", &amp;v.x, unsafe.Offsetof(v.x), unsafe.Sizeof(v.x)) fmt.Printf(\"pointy addr: %p offset: %d size: %d\\n\", &amp;v.y, unsafe.Offsetof(v.y), unsafe.Sizeof(v.y))&#125;//对齐 8// v: 0xc00008c000 ~ c00008c000, size: 72, align: 8// id addr: 0xc00008c000 offset: 0 size: 8// name addr: 0xc00008c008 offset: 8 size: 16// data addr: 0xc00008c018 offset: 24 size: 24// next addr: 0xc00008c030 offset: 48 size: 8// pointx addr: 0xc00008c038 offset: 56 size: 8// pointy addr: 0xc00008c040 offset: 64 size: 8 12345 |-------- name -------|------------- data -------------| |------ point ------|+----+----------+----------+----------+----------+----------+------+---------+---------+| id | name.ptr | name.len | data.ptr | data.len | data.cap | next | point.x | point.y |+----+----------+----------+----------+----------+----------+------+---------+---------+0 8 16 24 32 40 48 56 64 72 在分配内存时，字段须做对齐处理，通常以所有字段中最长的基础类型宽度为标准。 123456789101112131415161718func main() &#123; // v0 := struct&#123; // a byte // b []int //基础类型为int 对齐宽度是8 // c byte // &#125;&#123;&#125; v1 := struct &#123; a byte b byte c int32 //对齐宽度4 &#125;&#123;1, 1, 16&#125; fmt.Printf(\"%d %d\\n\", unsafe.Alignof(v1), unsafe.Sizeof(v1)) fmt.Printf(\"%p,%d,%d\\n\", &amp;v1.a, unsafe.Offsetof(v1.a), unsafe.Sizeof(v1.a)) fmt.Printf(\"%p,%d,%d\\n\", &amp;v1.b, unsafe.Offsetof(v1.b), unsafe.Sizeof(v1.b)) fmt.Printf(\"%p,%d,%d\\n\", &amp;v1.c, unsafe.Offsetof(v1.c), unsafe.Sizeof(v1.c)) //a是1位b是1位，\"xx\" c 是4位 单独开启 4位 ，那么排列起来就是 xx--|xxxx 宽度是4的对齐少于4个的重新开4个 //假如我们换个顺序改成a、c、b 我们预测一下应该是x---|xxxx|x--- &#125; 比较特殊的是空结构类型的字段。如果它是最后一个字段，那么编译器将其当做长度为1的类型做对齐处理，以便其地址不会越界，避免引发垃圾回收错误。 12345678910111213141516func main() &#123; v1 := struct &#123; a struct&#123;&#125; c struct&#123;&#125; b int &#125;&#123;&#125; fmt.Printf(\"%p ~ %x, size: %d align: %d\\n\", &amp;v1, uintptr(unsafe.Pointer(&amp;v1))+unsafe.Sizeof(v1), unsafe.Sizeof(v1), unsafe.Alignof(v1)) fmt.Printf(\"a addr: %p offset: %d size: %d\\n\", &amp;v1.a, unsafe.Offsetof(v1.a), unsafe.Sizeof(v1.a)) fmt.Printf(\"b addr: %p offset: %d size: %d\\n\", &amp;v1.b, unsafe.Offsetof(v1.b), unsafe.Sizeof(v1.b)) fmt.Printf(\"c addr: %p offset: %d size: %d\\n\", &amp;v1.c, unsafe.Offsetof(v1.c), unsafe.Sizeof(v1.c))&#125;// 0xc000092000 ~ c000092010, size: 16 align: 8// a addr: 0xc000092000 offset: 0 size: 0// b addr: 0xc000092000 offset: 0 size: 8// c addr: 0xc000092008 offset: 8 size: 0// xxxxxxxx|x------ 最后一个字段长度1","categories":[{"name":"golang","slug":"golang","permalink":"https://devying.github.io/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://devying.github.io/tags/golang/"}]},{"title":"golang map总结","slug":"golangmap","date":"2018-03-24T16:23:02.000Z","updated":"2019-11-21T14:58:46.057Z","comments":true,"path":"2018/03/25/golangmap/","link":"","permalink":"https://devying.github.io/2018/03/25/golangmap/","excerpt":"","text":"字典作为无序键值对集合，字典要求val必须是支持相等运算符(==,!=)的数据类型，比如数字、字符串、指针、数组、结构体，以及对应接口类型。访问不存在的键值，默认返回零值，不会引发错误。但是推荐使用ok-idiom模式对字典进行迭代的时候每次返回的键值顺序都是不一样的。字段不支持cap。因内存访问安全和哈希算法等缘故，字段被设计成”not addressable”，故不能直接修改value成员（结构或数组） 12345678910111213141516171819202122type user struct &#123; name string age byte&#125;func main() &#123; m := map[int]user&#123; 1: &#123;\"Tom\", 19&#125;, &#125; //m[1].age++ //错误了cannot assign to struct field m[1].age in map //正确的做法如下 u := m[1] u.age++ m[1] = u fmt.Println(m) //map[1:&#123;Tom 20&#125;] //或者使用指针类型 m2 := map[int]*user&#123; 1: &amp;user&#123;\"Jack\", 20&#125;, &#125; m2[1].age++ fmt.Println(m2) //map[1:0xc00000c0e0]&#125; 当然m[key]++ 是可以操作的，如果value支持可寻址的话，可以网上搜索golang 可寻址不能对nil字典进行写操作，但是可以读。 12345func main()&#123; var m map[string]int println(m[\"a\"])//返回零值 m[\"a\"] = 1 //panic: assignment to entry in nil map&#125; 注意了：内容为空的字典，与nil是不同的 123456func main()&#123; var m1 map[string]int m2 := map[string]int&#123;&#125; println(m1 == nil,m2 == nil) //true false&#125; 两个map不支持比较操作,只能和nil比较 123456func main() &#123; x := map[int]string&#123;1: \"a\"&#125; y := map[int]string&#123;1: \"a\"&#125; println(x == y)&#125;//invalid operation: x == y (map can only be compared to nil) 安全在迭代期间删除或者新增键值是安全的。 123456789101112131415161718192021222324func main() &#123; m := map[int]int&#123;&#125; for i := 0; i &lt; 10; i++ &#123; m[i] = i + 100 &#125; for x := range m &#123; if x == 3 &#123; m[100] = 1000 &#125; delete(m, x) fmt.Println(x, m) &#125;&#125;// 4 map[0:100 1:101 2:102 3:103 5:105 6:106 7:107 8:108 9:109]// 5 map[0:100 1:101 2:102 3:103 6:106 7:107 8:108 9:109]// 6 map[0:100 1:101 2:102 3:103 7:107 8:108 9:109]// 7 map[0:100 1:101 2:102 3:103 8:108 9:109]// 8 map[0:100 1:101 2:102 3:103 9:109]// 1 map[0:100 2:102 3:103 9:109]// 3 map[0:100 2:102 9:109 100:1000]// 9 map[0:100 2:102 100:1000]// 0 map[2:102 100:1000]// 2 map[100:1000]我们可以看到 map 迭代的无序性，每次删除m的元素都会更新 关于map并发操作导致的进程崩溃。(并发读、写、迭代) 123456789101112131415161718func main() &#123; m := map[string]int&#123;\"a\":1,\"b\":2&#125; go func() &#123; for &#123; m[\"a\"] += 1 time.Sleep(time.Microsecond) &#125; &#125;() go func() &#123; for &#123; _ = m[\"b\"] time.Sleep(time.Microsecond) &#125; &#125;() select &#123;&#125;&#125;//fatal error: concurrent map read and map write 可以使用go run -race s.go 来检查此类问题,当然为了避免此类问题，可以使用读写互斥锁 12345678910111213141516171819202122func main() &#123; m := map[string]int&#123;&#125; var lock sync.RWMutex go func() &#123; for &#123; lock.Lock() m[\"a\"] += 1 lock.Unlock() time.Sleep(time.Microsecond) &#125; &#125;() go func() &#123; for &#123; lock.Lock() _ = m[\"b\"] lock.Unlock() time.Sleep(time.Microsecond) &#125; &#125;() select &#123;&#125;&#125; 在创建时预先准备足够的空间有助于提升性能，减少扩张时的内存分配和重新哈希操作。对于海量小对象，应该直接用字典存储键值数据拷贝而不是指针，这样减少扫描对象的数量缩短垃圾回收时间。另外，字典不会收缩内存，适当替换新对象是有必要的。","categories":[{"name":"golang","slug":"golang","permalink":"https://devying.github.io/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://devying.github.io/tags/golang/"}]},{"title":"golang切片总结","slug":"golang切片","date":"2018-03-09T16:23:02.000Z","updated":"2019-11-17T07:11:12.812Z","comments":true,"path":"2018/03/10/golang切片/","link":"","permalink":"https://devying.github.io/2018/03/10/golang%E5%88%87%E7%89%87/","excerpt":"","text":"切片切片本身并非动态数组或者数组指针。它内部通过指针引用底层数组，设定相关属性将数据读写操作限定在指定区域内。切片本身是个只读对象，其工作机制类似于数组指针的一种包装demo: 1234567891011121314151617181920212223x := [...]int&#123;0,1,2,3,4,5,6,7,8,9&#125;expression slice len cap -----------+------------------------+-----+-----+------------x[:] [0 1 2 3 4 5 6 7 8 9] 10 10 x[0:len(x)] x[2:5] [2 3 4] 3 8x[2:5:7] [2 3 4] 3 5x[4:] [4 5 6 7 8 9] 6 6 x[4:len(x)]x[:4] [0 1 2 3] 4 10 x[0:4]x[:4:6] [0 1 2 3] 4 6 x[0:4:6]操作如下 low:2 high:5 max:7 len = high - low | | | cap = max - low +---+---+---+---+---+---+---+---+---+---+ +-----+---+---+ x | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | | ptr | 3 | 5 | x[2:5:7] +---+---+---+---+---+---+---+---+---+---+ +-----+---+---+ | | | | |&lt;-- len --&gt;| | | | | | |&lt;------ cap ------&gt;| | | | |&lt;----------------- array pointer&lt;-------------+ 1.cap 表示切片引用数组片段的真实长度，len用于限定可读写元素数量。另外数组必须addressable，否则会引发错误。关于是否可寻址，可以参考一下https://colobu.com/2018/02/27/go-addressable/2.和数组一样，切片同样适用索引号访问元素内容。起始索引为0，而非对应的底层数组的真实索引位置。3.可以直接创建切片对象，无需预先准备数组。因为是引用类型，须使用make函数或显示初始化语句，他会自动完成底层数组内存分配 123456789101112func main() &#123; s1 := make([]int, 3, 5) s2 := make([]int, 3) s3 := []int&#123;10, 20, 5: 30&#125; //这个方式跟数组好像 fmt.Println(s1, len(s1), cap(s1)) fmt.Println(s2, len(s2), cap(s2)) fmt.Println(s3, len(s3), cap(s3))&#125;//输出[0 0 0] 3 5[0 0 0] 3 3[10 20 0 0 0 30] 6 6 注意以下两种定义方式的区别。前者定义了一个[]int类型变量，并未执行初始化操作，而后者则用初始化表达式完成了全部创建过程。 123456var a []intb := []int&#123;&#125;println(a==nil,b==nil)//true false//可以用(*reflect.SliceHeader)(unsafe.Pointer(&amp;a))打印出来结构另外虽然a == nil ，切片本身依然会分配内存。可以直接对a进行slice[:]操作，同样返回nil 切片不支持比较操作，就算元素类型支持也不行，仅能判定是否为nil可以获取元素的地址，但是不能像数组那样直接用指针访问元素。 12345678s := []int&#123;0, 1, 2, 3, 4&#125;p := &amp;sp0 := &amp;s[0]p1 := &amp;s[1]println(p, p0, p1)*p0 += 1 //这种操作切片和数组一样*p1 += 100fmt.Println(s) 假如元素类型也是切片，那么也就可以实现类似交错数组功能。另外并不是所有的时候都适合用切片代替数组，因为切片底层数组可能会再堆上分配内存。而且小数组在栈上拷贝的消耗也未必就比make大。 12345678910111213141516171819202122232425262728293031func array() [1024]int&#123; var x [1024]int for i:= 0;i&lt;len(x);i++&#123; x[i]=i &#125; return x&#125;func slice() []int&#123; x := make([]int,1024) for i:= 0;i&lt;len(x);i++&#123; x[i]=i &#125; return x&#125;func BenchmarkArray(b *testing.B)&#123; for i:=0;i&lt;b.N;i++&#123; array() &#125;&#125;func BenchmarkSlice(b *testing.B)&#123; for i:=0;i&lt;b.N;i++&#123; slice() &#125;&#125;//测试结果goos: darwingoarch: amd64BenchmarkArray-4 2000000 725 ns/opBenchmarkSlice-4 1000000 1284 ns/opPASSok command-line-arguments 3.490s reslice将切片视作[cap]slice数据源，据此创建新切片对象。不能超过cap，但不受len限制。s[x:y:z] x起始索引 y结束索引，但是不包含y值，z表示取s的z个容量，如果不写z则是cap(s)-x否则是z-x 12345678910111213141516171819+---+---+---+---+---+---+---+---+---+---+| 0 | 1 | 2 | 3 | 4 | 5 | 6 | | | | s len:6,cap:10+---+---+---+---+---+---+---+---+---+---+0 3 8 10 +---+---+---+---+---+---+---+ | 3 | 4 | 5 | 6 | 0 | | | s1=s[3:8] len:5,cap:7 +---+---+---+---+---+---+---+ 0 2 4 6 +---+---+---+---+ | 5 | 6 | | | s2=s1[2:4:6] len:2,cap:4 +---+---+---+---+ 0 1 +---+---+---+---+---+ | 5 | | | | | s3=s2[:1:5] error:slice bounds out of range +---+---+---+---+---+ copy在两个切片对象间复制数据，允许指向同一底层数组，允许目标区间重叠。最终所复制长度以较短的切片长度为准 123456789func main() &#123; s := []int&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125; s1 := s[5:8] n := copy(s[4:], s1) //5,6,7======&gt;4--9 //在同一底层数组的不同区间复制 fmt.Println(s, s1, n) //[0 1 2 3 5 6 7 7 8 9] [6 7 7] 3 s2 := make([]int, 6) n2 := copy(s2, s) //在不同数组间复制 fmt.Println(s2, n2) //[0 1 2 3 5 6] 6&#125; 当然还可以将字符串中复制数据到[]byte 123b := make([]byte, 5)n3 := copy(b, str)fmt.Println(b, n3) //[97 98 99 100 101] 5 如果切片长时间引用大数组中很小的片段，那么建议单独新建独立的切片，复制出所需数据，以便原数组可以被及时回收","categories":[{"name":"golang","slug":"golang","permalink":"https://devying.github.io/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://devying.github.io/tags/golang/"}]},{"title":"golang数组总结","slug":"golang数组","date":"2018-02-24T16:23:02.000Z","updated":"2019-11-17T06:49:37.812Z","comments":true,"path":"2018/02/25/golang数组/","link":"","permalink":"https://devying.github.io/2018/02/25/golang%E6%95%B0%E7%BB%84/","excerpt":"","text":"数组定义定义数组类型时，数组长度必须是非负整数常量表达式，长度是类型组成部分。也就是说，元素类型相同，但是长度不同的数组不属于同一类型。 12345var a [4]intb := [4]int&#123;2,5&#125; //未初始化的元素自动初始化为0c := [4]int&#123;5,3:10&#125; //可以指定索引位置初始化d := [...]int&#123;12,13,14&#125; //编译器按初始化值的数量来确定数组的长度e := [...]int&#123;10,5:100&#125; 对于结构等复合类型，可以省略元素初始化类型标签。 1234567891011type user struct &#123; name string age byte&#125;d := [...]user&#123; &#123;\"Huangby\", 30&#125;, &#123;\"Mi\", 20&#125;,&#125;fmt.Printf(\"%#v\", d)//以上输出[2]main.user&#123;main.user&#123;name:\"Huangby\", age:0x1e&#125;, main.user&#123;name:\"Mi\", age:0x14&#125;&#125; 在定义多维数组时仅第一维度允许使用”…” 123456789101112131415161718b := [...][3]int&#123; &#123;10,20&#125;, &#123;10,20,50&#125;,&#125;//结果是 [[10 20 0] [10 20 50]]c := [...][3][4]int&#123; &#123; &#123;10,12,2&#125;, &#123;6,12&#125;, &#123;100&#125;, &#125;, &#123; &#123;13,2:90&#125;, &#123;6&#125;, &#123;3:33&#125;, &#125;,&#125;//结果是 [[[10 12 2 0] [6 12 0 0] [100 0 0 0]] [[13 0 90 0] [6 0 0 0] [0 0 0 33]]] 另外内置函数len和cap都返回的是第一维度的长度如果数组的元素类型支持“==”或者“!=”操作，那么对应数组也支持。 123456789var a,b [2]intprintln(a==b) //int支持==操作符 truec := [2]int&#123;1,2&#125;d := [2]int&#123;0,1&#125;println(c==d) //falsevar e,f [2]map[string]intprintln(e == f) //map[string]int 不支持 == 操作符 指针要分清楚指针数组和数组指针的区别，指针数是指元素为指针类型的数组，数组指针是获取数组变量的地址。 12345678x, y := 10, 20a := [...]*int&#123;&amp;x, &amp;y&#125;p := &amp;afmt.Printf(\"%T,%v\\n\", a, a) //元素为指针的指针数组fmt.Printf(\"%T,%v\\n\", p, p) //存储数组地址的指针//以上输出// [2]*int,[0xc000092000 0xc00007e008]// *[2]*int,&amp;[0xc000092000 0xc00007e008] 另外我们可以获取任何元素的地址 1234a := [...]int&#123;1,2&#125;println(&amp;a,&amp;a[0],&amp;a[1])//以上输出//0xc000032778 0xc000032778 0xc000032780 数组指针可以直接用来操作元素 12345678910a := [...]int&#123;1, 2&#125;p := &amp;ap[1] += 20 //直接操作元素println(p[1]) //22//&amp;a[0] += 100//错误 cannot assign to &amp;a[0]//正确的姿势 因为都是int 也可以将unsafe去掉up := (*int)(unsafe.Pointer(&amp;a[0]))*up = 100//或者 up := &amp;a[0] *up += 100println(a[0], a[1]) //100 22 复制与C数组变量隐式作为指针使用不同，Go数组是值类型，赋值和传参操作都会复制整个数组数据。如果需要，可改用指针或者切片，避免数据复制。","categories":[{"name":"golang","slug":"golang","permalink":"https://devying.github.io/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://devying.github.io/tags/golang/"}]},{"title":"golang字符串总结","slug":"golang字符串","date":"2018-02-02T16:23:02.000Z","updated":"2019-11-17T06:49:29.511Z","comments":true,"path":"2018/02/03/golang字符串/","link":"","permalink":"https://devying.github.io/2018/02/03/golang%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"字符串字符串是不可变字节(byte)序列,其本身是一个复合结构 1234type stringStruct struct&#123; str unsafe.Pointer len int&#125; 头部指针指向字节数组，但没有NULL结尾。默认以UTF-8编码存储Unicode字符，字面量里允许使用十六进制、八进制和UTF编码格式。内置函数len返回字节数组长度，cap不接受字符串类型参数。 123456789101112func main() &#123; s := \"黄abc\\x61\\142\\u0041\" println(len(s)) println(len([]rune(s))) //先转成rune数组再计算数组长度 fmt.Println([]rune(s)) fmt.Println([]byte(s))&#125;//输出97[40644 97 98 99 97 98 65][233 187 132 97 98 99 97 98 65] 字符串默认值是””,可以使用``来处理原始字符串。字符串支持“!=、==、&lt;、&gt;、+、+=”操作符，其中跨行时操作符必须在上一行结尾。 123456789func main() &#123; s := \"ab\" + \"cd\" println(s == \"abcd\") println(s &gt; \"abc\")&#125;//输出truetrue 允许以索引号访问字节数组（非字符）,但不能获取元素地址。 123456func main() &#123; s := \"abcd\" println(s[1]) println(&amp;s[1])//错误&#125;cannot take the address of s[1] 以切片语法返回子串时，其内部依旧指向原字节数组 1234567891011121314151617181920func main() &#123; s := \"abcdefg\" s1 := s[:2] s2 := s[1:4] s3 := s[3:] println(s1, s2, s3) fmt.Printf(\"%#v\", (*reflect.StringHeader)(unsafe.Pointer(&amp;s))) //我们先去到Go字符串的指针，它本质上是一个*reflect.StringHeader，但是Go告诉我们这是一个*string //unsafe.Pointer 用于两个不同类型的指针转换 上面这个就是将字符串指针转成*reflect.StringHeader 指针 fmt.Printf(\"%#v\", (*reflect.StringHeader)(unsafe.Pointer(&amp;s1))) fmt.Printf(\"%#v\", (*reflect.StringHeader)(unsafe.Pointer(&amp;s2))) fmt.Printf(\"%#v\", (*reflect.StringHeader)(unsafe.Pointer(&amp;s3)))&#125;//输出ab bcd defg&amp;reflect.StringHeader&#123;Data:0x10c8b36, Len:7&#125;&amp;reflect.StringHeader&#123;Data:0x10c8b36, Len:2&#125;&amp;reflect.StringHeader&#123;Data:0x10c8b37, Len:3&#125;&amp;reflect.StringHeader&#123;Data:0x10c8b39, Len:4&#125;可以看出 第一个字节地址是一样的 遍历字符串两种方式结果不一样 1234567891011121314151617181920func main() &#123; s := \"胡汉三\" for i := 0; i &lt; len(s); i++ &#123; //byte fmt.Printf(\"%c\\n\", s[i]) &#125; for _, v := range s &#123; //rune:返回数组索引号，以及Unicode字符 fmt.Printf(\"%c\\n\", v) &#125;&#125;//输出é»ä¿胡汉三 转换要修改字符串，须将其转为可变类型（[ ]byte或[ ]rune）待完成后再转回来。但是不管如何转换，都需重新分配内存，并复制数据。当然有些时候这么做会拖累算法性能，可以使用“非安全”方法进行改善。 1234567891011func main() &#123; bt := []byte(\"hello,world\") sp := (*string)(unsafe.Pointer(&amp;bt)) fmt.Println(*sp) *sp = \"huangby\" //直接修改对象 fmt.Println(bt)&#125;//输出hello,worldhuangby该方法利用了[]byte和string头部结构部分相同，以非安全的指针类型转换来实现类型变更。 用append函数可以将string直接追加到[]byte内 1234567891011func main() &#123; bt := []byte(\"hello,world\") bt = append(bt, \"@huangby\"...) fmt.Printf(\"%s\", bt) ru := []rune(\"你好，世界\") ru = append(ru, '应') fmt.Printf(\"%c\", ru)&#125;//输出hello,world@huangby[你 好 ， 世 界 应]注意了rune不能像string...那么使用 考虑到字符串只读特征，转换时复制数据到新分配内存是可以理解的。当然，性能同样重要，编译器会为某些场合进行专门优化，避免额外分配和复制操作： 将[]byte转为string key,去map[string]查询的时候 将string转为[]byte，进行for range迭代时，直接取字节赋值给局部变量。GDB验证一下编译的时候加上 go build -gcflags ‘-N -l’123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687GNU gdb (GDB) 8.3Copyright (C) 2019 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.Type \"show copying\" and \"show warranty\" for details.This GDB was configured as \"x86_64-apple-darwin17.7.0\".Type \"show configuration\" for configuration details.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;.Find the GDB manual and other documentation resources online at: &lt;http://www.gnu.org/software/gdb/documentation/&gt;.For help, type \"help\".Type \"apropos word\" to search for commands related to \"word\"...Reading symbols from ./s...Loading Go Runtime support.(gdb) b 6Breakpoint 1 at 0x10567cb: file /Users/baoying5/go/src/basic/s.go, line 6.(gdb) rStarting program: /Users/baoying5/go/src/basic/s [New Thread 0xc03 of process 4532][New Thread 0xb03 of process 4532]warning: `/BuildRoot/Library/Caches/com.apple.xbs/Binaries/Libc_darwin/install/TempContent/Objects/Libc.build/libsystem_darwin.dylib.build/Objects-normal/x86_64/darwin_vers.o': can't open to read symbols: No such file or directory.warning: `/BuildRoot/Library/Caches/com.apple.xbs/Binaries/Libc_darwin/install/TempContent/Objects/Libc.build/libsystem_darwin.dylib.build/Objects-normal/x86_64/dirstat.o': can't open to read symbols: No such file or directory.warning: `/BuildRoot/Library/Caches/com.apple.xbs/Binaries/Libc_darwin/install/TempContent/Objects/Libc.build/libsystem_darwin.dylib.build/Objects-normal/x86_64/dirstat_collection.o': can't open to read symbols: No such file or directory.warning: `/BuildRoot/Library/Caches/com.apple.xbs/Binaries/Libc_darwin/install/TempContent/Objects/Libc.build/libsystem_darwin.dylib.build/Objects-normal/x86_64/init.o': can't open to read symbols: No such file or directory.warning: `/BuildRoot/Library/Caches/com.apple.xbs/Binaries/Libc_darwin/install/TempContent/Objects/Libc.build/libsystem_darwin.dylib.build/Objects-normal/x86_64/variant.o': can't open to read symbols: No such file or directory.[New Thread 0x90f of process 4532][New Thread 0x1503 of process 4532][New Thread 0x1603 of process 4532][New Thread 0x2903 of process 4532]Thread 2 hit Breakpoint 1, main.main () at /Users/baoying5/go/src/basic/s.go:6warning: Source file is more recent than executable.6 //s := string(key)(gdb) info localsok = falsex = 18550296m = map[string]int = &#123;[0x1075b17 \"abc\"] = 123&#125;key = &#123;array = 0xc00003261d \"abc\\030\\016\\033\\001\", len = 3, cap = 3&#125;(gdb) sruntime.mapaccess2_faststr (t=0x10649c0 &lt;type.*+57568&gt;, h=0xc000032688, ky=..., ~r3=&lt;optimized out&gt;, ~r4=&lt;optimized out&gt;) at /usr/local/go/src/runtime/map_faststr.go:107107 func mapaccess2_faststr(t *maptype, h *hmap, ky string) (unsafe.Pointer, bool) &#123;(gdb) info argst = 0x10649c0 &lt;type.*+57568&gt;h = 0xc000032688ky = &lt;optimized out&gt;~r3 = &lt;optimized out&gt;~r4 = &lt;optimized out&gt;(gdb) x/3xw kyvalue has been optimized out(gdb) s112 if h == nil || h.count == 0 &#123;(gdb) s115 if h.flags&amp;hashWriting != 0 &#123;(gdb) s118 key := stringStructOf(&amp;ky)(gdb) x/3xw keyvalue has been optimized out(gdb) x/3xw &amp;keyCan't take address of \"key\" which isn't an lvalue.(gdb) sruntime.stringStructOf (sp=0xc0000325f8, ~r1=&lt;optimized out&gt;) at /usr/local/go/src/runtime/string.go:230230 return (*stringStruct)(unsafe.Pointer(sp))(gdb) x/3xw keyNo symbol \"key\" in current context.(gdb) x/3xw &amp;keyNo symbol \"key\" in current context.(gdb) sruntime.mapaccess2_faststr (t=0x10649c0 &lt;type.*+57568&gt;, h=0xc000032688, ky=..., ~r3=&lt;optimized out&gt;, ~r4=&lt;optimized out&gt;) at /usr/local/go/src/runtime/map_faststr.go:119119 if h.B == 0 &#123;(gdb) x/3xw key0xc0000325f8: 0x0003261d 0x000000c0 0x00000003(gdb) s121 b := (*bmap)(h.buckets)(gdb) s122 if key.len &lt; 32 &#123;(gdb) s124 for i, kptr := uintptr(0), b.keys(); i &lt; bucketCnt; i, kptr = i+1, add(kptr, 2*sys.PtrSize) &#123;(gdb) x/3xw key0xc0000325f8: 0x0003261d 0x000000c0 0x00000003(gdb) 可以看到 地址 0x0003261d 说明这里是直接修改的地址 性能除类型转换外，动态构建字符串也容易造成性能问题用加法操作字符拼接字符串时，每次都需要重写分配内存。如此，在构建超大字符串时性能就特别差。可以用strings.Join 或者 bytes.Buffer对于数量较少的字符串格式化拼接可以用fmt.Sprintf、text/template等方法123456var a bytes.Buffera.Grow(100)for i := 0; i &lt; 100; i++ &#123; a.WriteByte('c')&#125;fmt.Println(a.String()) Unicode类型rune专门用来存储Unicode码点，他是int32的别名，相当于UCS-4、UTF-32编码格式。使用单引号的字面量，其默认类型就是rune。12345func main() &#123; r := '黄' fmt.Printf(\"type : %T\", r)&#125;//type : int32 除了[]rune 外（即不能[]rune()这样转一个字符串），还可以再rune/byte/string间进行转换,123456789r := '黄'fmt.Printf(\"type : %T\\n\", r)s := string(r)b := byte(r)s2 := string(b)r2 := rune(b)fmt.Println(r, s, b, s2, r2)//40644 黄 196 Ä 196 字符串存储的字节数组，不一定就是合法的UTF-8文本1234567str := \"胡汉三\"stt := str[:1] + str[3:4]fmt.Println(stt) //��fmt.Println(utf8.ValidString(stt))//以上输出��false 当然我们用unicode库下面的一些函数，可以统计Unicode字符数量,另外官方扩展库还有提供对BOM支持的。1234str := \"胡汉三abc\"fmt.Println(len(str), utf8.RuneCountInString(str))//以上输出12 6","categories":[{"name":"golang","slug":"golang","permalink":"https://devying.github.io/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://devying.github.io/tags/golang/"}]},{"title":"golang数据类型总结","slug":"golang数据类型总结","date":"2018-01-12T16:23:02.000Z","updated":"2020-03-16T10:18:28.399Z","comments":true,"path":"2018/01/13/golang数据类型总结/","link":"","permalink":"https://devying.github.io/2018/01/13/golang%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/","excerpt":"","text":"基本类型 类型 长度 默认值 说明 bool 1 false byte 1 0 uint8 rune 4 0 Unicode Code Point, int32 int, uint 4或8 0 32 或 64 位 int8, uint8 1 0 -128 ~ 127, 0 ~ 255 int16, uint16 2 0 -32768 ~ 32767, 0 ~ 65535 int32, uint32 4 0 -21亿~ 21亿, 0 ~ 42亿 int64, uint64 8 0 float32 4 0.0 float64 8 0.0 complex64 8 complex128 16 uintptr 4或8 ⾜足以存储指针的 uint32 或 uint64整数 array 值类型 struct 值类型 string “” UTF-8 字符串 slice nil 引⽤用类型 map nil 引⽤用类型 channel nil 引⽤用类型 interface nil 接⼝ function nil 函数 支持八进制，十六进制以及科学计数法 1234567891011121314a,b,c := 100,0144,0x64fmt.Println(a,b,c) //100,100,100fmt.Printf(\"0b%b,%#o,%#x\",a,b,c)//0b1100100,0144,0x64fmt.Prinln(math.MaxInt8,math.MinInt8)//127,-128//进制转换到十进制a,_ := strconv.ParseInt(\"1100100\",2,32) //100b,_ := strconv.ParseInt(\"0144\",8,32) //100c,_ := strconv.ParseInt(\"64\",16,32) //100//十进制转到其他进制strconv.FormatInt(a,2) //1100100strconv.FormatInt(a,8) //144strconv.FormatInt(a,16) //64 注意浮点数 默认浮点类型是float64 12345678910111213141516package mainimport ( \"fmt\")func main() &#123; var a float32 = 1.123456789 var b float32 = 1.123456781 var c float32 = 1.12345678 println(a, b, c) println(a == b, b == c, a == c) fmt.Printf(\"%v,%v,%v\", a, b, c)&#125;+1.123457e+000 +1.123457e+000 +1.123457e+000true true true1.1234568,1.1234568,1.1234568 别名byte 是 uint8 别名rune 是 int32 别名别名类型不需要转换可以直接赋值，比如下面这样没有问题。但是注意了，就算你在32操作系统上int 并不等于int32，在64位系统上int 并不等于int64 123456789func main()&#123; var x byte = 0x11 var y uint8 = x var z uint8 = x + y test(z)&#125;func test(x byte) &#123; println(x)&#125; 引用类型特指slice，map，chan 这三类内置函数new按指定类型长度分配零值内存，返回指针，并不关心类型内部构造和初始化方式，而引用类型必须要使用make来创建，编译器会将make转为目标类型专用的创建函数（或指令），以确保全部内存分配和相关属性初始化。 类型转换不⽀支持隐式类型转换 12345678a := 10b := byte(a)c := a + int(b) //混合表达式 必须保持类型一致，a自动推断为int 所以a + 后面的也必须是intvar n int = int(b) // 显式转换println(a, b, c) //10，10，20d := bool(a) //这里就有问题了 如果转换的目标是指针，单向通道或者是没有返回值的函数,必须要使用括号。避免造成语法分析错误 1234d := (*int)(&amp;a) //0xc000032780e := (&lt;-chan int)(ch)f := (func())(x)g := func()int(x) //有返回值的可以省略括号 自定义类型使用关键字type定义，包括基于现有基础类型创建或者是结构体、函数类型等。 123456789101112type flag byteconst ( read flag = 1 &lt;&lt; iota write exec)func main()&#123; f := read | exec fmt.Printf(\"%b\\n\",f)&#125;//101 和var 、const 类似，多个type定义可以合并成组，可以在函数或者代码块内定义局部类型。 12345678910111213141516func main()&#123; type ( user struct &#123; //结构体类型 name string age uint8 &#125; event func(string) bool //函数类型 ) u := user&#123;\"huangby\",30&#125; fmt.Println(u) var f event = func(s string) bool &#123; println(s) return s !=\"\" &#125; f(\"huangby\")&#125; 未命名类型与有明确标识符的 bool、int、string 等类型相比，数组、切片、字典、通道等类型与具体类型的长度等属性有关，故称作为命了类型。具有相同声明的未命名类型被视作同一类型。 具有相同基类型的指针。 具有相同元素类型和长度的数组 array 具有相同元素类型的切片 slice 具有相同键值类型的字典 map 具有相同数据类型以及操作方向的通道 channel 具有相同字段序列（字段名、字段类型、标签、字段顺序）的结构体 struct 具有相同签名(参数和返回值，不包括参数名)的函数 func 具有相同方法集（方法名，方法签名）的接口 interface{} 指针不能将内存地址与指针混为一谈内存地址是内存中每个字节单元的唯一编号，指针则是一个实体。指针会分配内存空间，相当于一个专门用来保存地址的整形变量。 123456 p := &amp;x x:=100------------|-------|----\\\\----|---------|-----memory... |0x1200 | ···· | 100 |------------|-------|----\\\\----|---------|-----addr 0x80 0x1200 ----------------------------------------------- &amp;符号用来获取对象地址 指针运算符*用于间接引用目标对象 二级指针 ** T,如包含包名则写成*package T 并非所有的对象都能进行取地址操作，但变量总是能正确返回。指针运算符为左值时(*a = 20)，可以更新目标对象状态，而为右值时(a := *b)，则是为了获取目标状态。指针支持相等运算，单不支持加减法和类型转换。 可以通过unsafe.Pointer将指针转换为 uintptr 后加减运算，但可能会造成非法访问。 Pointer类似于C中的void* 万能指针，可以用来转换指针类型。它能安全持有对象或对象成员，但是 uintptr 不行。uintptr 仅是一种特殊整形，并不引用目标对象，无法阻止垃圾回收器回收对象内存。 123var a,b struct&#123;&#125;println(&amp;a,&amp;b) //都是0x---------println(&amp;a==&amp;b ,&amp;a==nil) //第一个不一定true 但是第二个肯定false 初始化对复合类型（数组，切片，字典，结构体）变量初始化时，有一些语法限制。 初始化表达式必须含有类型标签 左花括号必须在类型尾部，不能另起一行 多个成员初始值以逗号分隔 允许多行，但是每行必须以逗号或者右花括号结束。1234567891011121314type data struct&#123; x int s string&#125;var a data = data&#123;1,\"abc\"&#125;b := data&#123;2,\"def\"&#125;c := []int&#123;1,2,3&#125;var d = map[string]string&#123;\"name\":\"huangby\",\"addr\":\"beijing\"&#125;d := map[string]string&#123;\"name\": \"huangby\", \"addr\": \"beijing\"&#125;d[\"a\"] = \"acd\"//但是var d map[string]stringd[\"a\"] = \"acd\" 这就不行了","categories":[{"name":"golang","slug":"golang","permalink":"https://devying.github.io/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://devying.github.io/tags/golang/"}]},{"title":"golang变量和常量总结","slug":"golang变量和常量","date":"2017-12-31T16:23:02.000Z","updated":"2019-11-17T06:49:35.910Z","comments":true,"path":"2018/01/01/golang变量和常量/","link":"","permalink":"https://devying.github.io/2018/01/01/golang%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/","excerpt":"","text":"变量Go变量总是有固定的数据类型，类型决定了变量内存的长度和存储格式。我们只能修改变量值，无法改变类型。 通过类型转换或者指针操作，我们可以用不同方式修改变量值，但是这并不意味着改变了变量类型。 关键字var可以用于定义变量，运行时内存分配操作会确保变量自动初始化为二进制零值，避免出现不可预测行为。如果显式提供初始化值，可以省略变量类型，由编译器推断。 123var x int //自动初始化为 0var y = false //自动推断为bool类型var z int = 0 //可以省略int 一次性定义多个变量 12var x,y int //相同类型的多个变量var a,s = 100, \"abc\" //不同类型初始化值 按照惯例，以组的方式整理多行变量定义。 1234var ( x, y int a, s = 300, \"abc\") 简短模式除了var 关键字还可以用更简短的变量定义和初始化语法 12x := 100a,s := 1, \"abc\" 简短模式有一些限制： 定义变量，同时显式初始化 不能提供数据类型 只能用在函数内部 123456789var x = 100 //全局变量func main()&#123; fmt.Println(&amp;x,x) x:=\"abc\" //重新定义和初始化同名局部变量，局部有效 fmt.Println(&amp;x,x)&#125;以上程序运行结果：两个&amp;x 内存地址不一样，x值也不一样，可以看出是两个不同的变量 简短模式在函数多值返回，以及if/for/switch等语句中定义局部变量非常方便 简短模式并不总是重新定义变量的，还有可能是部分退化的赋值操作。另外退化赋值的前提条件是至少有一个新变量被定义，且在同一作用域。常见在函数返回err时，始终重复使用err变量 12345678910func main()&#123; x := 100 fmt.Println(&amp;x) x, y := 20,\"abc\" // fmt.Println(&amp;x,x,y)//&amp;x是同一个 x这是退化赋值 &#123; x,y := 12,12 //作用域不同，这里都是重新定义变量 &#125;&#125; 未使用错误编译的时候未使用的局部变量会报错，而全局变量不会。 空标识符_空标识符可临时用来规避编译器对未使用的变量或包的错误检查，但是请注意它是预置成员，不能重新定义。 常量常量表示运行时恒定不可改变的值，通常是一些字面量。常量必须是编译期可确定的字符、字符串、数字、布尔值，可指定常量类型或者由编译器通过初始化推断。不曾使用的常量不会编译报错。 12345678910const x,y int = 123,0x22const s = \"hello\"const c = '哈'const ( i,f = 123,2.3 //int，float64(默认) b = false)func main()&#123; const s = 45 //可以在不同作用域定义同名常量&#125; 可以是编译器可以计算出来的表达式(比如unsafe.Sizeof，cap,len等)，范围必须要正确 12345678const ( x, y = 99, -999 b byte = byte(x) //b 是byte类型，必须显式的将x转为byte n = uint8(y) //错误范围溢出 ptrSize = unsafe.Sizeof(uintptr(0)) strSize = len(\"hello\")) 在常量组中，如不指定类型和初始化值，则与上一行非空常量右值相同 123456const ( x uint16 = 120 y //与上一行x 右值、类型相同 s = \"abc\" z //与上一行s 右值、类型相同) 枚举Go没有明确意义上的enum定义，但是可以借助iota标识符实现一组自增常量值，来实现枚举类型 123456789101112const ( x = iota //0 y //1 z //2)const ( _ = iota //0 KB = 1 &lt;&lt; (10 * iota) // 1 &lt;&lt; (10 * 1) MB // 1 &lt;&lt; (10 * 2) GB // 1 &lt;&lt; (10 * 3)) 自增作用范围为常量组。可以在多常量定义中使用多个iota，它们各自单独计数，只需要确保组中每行常量个数相同即可 12345const ( _, _ = iota ,iota * 10 // 0, 0 * 10 a, b // 1, 1 * 10 c, d // 2, 2 * 10) 如果中断iota自增，必须显式恢复，切后续自增值按行序递增。 12345678const ( a = iota //0 b //1 c = 100 //100 d //100 与上一行保持一致 e = iota //4 恢复iota,行序递增 f //5) 自增默认类型为int,当然你可以显示的指定类型 常量和变量区别常量是只读，不能取地址。数字常量不会分配存储空间，无需像变量那要通过内存寻址来取值，因此无法获取地址。变量在运行期分配存储内存（非优化状态）常量通常会被编译器在预处理阶段直接展开，作为指令数据使用。 1234const x = 100 //无类型声明的常量const y byte = x //直接展开x,相当于const y byte = 100const a int = 100 //显式指定常量类型，编译器会做强类型检查const b byte = a //错误，can not use a （type int）as type byte in const initializer","categories":[{"name":"golang","slug":"golang","permalink":"https://devying.github.io/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://devying.github.io/tags/golang/"}]}]}
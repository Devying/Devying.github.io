{"meta":{"title":"熠熙轻雷","subtitle":"blog","description":"","author":"Devying","url":"https://devying.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2019-11-09T14:31:33.179Z","updated":"2019-11-07T10:29:47.428Z","comments":false,"path":"/404.html","permalink":"https://devying.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2019-11-09T14:31:33.193Z","updated":"2019-11-09T13:26:46.966Z","comments":false,"path":"about/index.html","permalink":"https://devying.github.io/about/index.html","excerpt":"","text":""},{"title":"书单","date":"2019-11-09T14:31:33.201Z","updated":"2019-11-07T10:29:47.429Z","comments":false,"path":"books/index.html","permalink":"https://devying.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-11-09T14:31:33.202Z","updated":"2019-11-07T10:29:47.429Z","comments":false,"path":"categories/index.html","permalink":"https://devying.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-11-09T14:31:33.206Z","updated":"2019-11-07T10:29:47.429Z","comments":false,"path":"repository/index.html","permalink":"https://devying.github.io/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-11-09T14:31:33.205Z","updated":"2019-11-07T10:29:47.429Z","comments":true,"path":"links/index.html","permalink":"https://devying.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-11-09T14:33:21.781Z","updated":"2019-11-09T14:33:21.781Z","comments":false,"path":"tags/index.html","permalink":"https://devying.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"golang变量和常量","slug":"golang变量和常量","date":"2019-11-08T16:23:02.000Z","updated":"2019-11-09T15:04:23.339Z","comments":true,"path":"2019/11/09/golang变量和常量/","link":"","permalink":"https://devying.github.io/2019/11/09/golang%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/","excerpt":"","text":"变量Go变量总是有固定的数据类型，类型决定了变量内存的长度和存储格式。我们只能修改变量值，无法改变类型。 通过类型转换或者指针操作，我们可以用不同方式修改变量值，但是这并不意味着改变了变量类型。 关键字var可以用于定义变量，运行时内存分配操作会确保变量自动初始化为二进制零值，避免出现不可预测行为。如果显式提供初始化值，可以省略变量类型，由编译器推断。 123var x int //自动初始化为 0var y = false //自动推断为bool类型var z int = 0 //可以省略int 一次性定义多个变量 12var x,y int //相同类型的多个变量var a,s = 100, \"abc\" //不同类型初始化值 按照惯例，以组的方式整理多行变量定义。 1234var ( x, y int a, s = 300, \"abc\") 简短模式除了var 关键字还可以用更简短的变量定义和初始化语法 12x := 100a,s := 1, \"abc\" 简短模式有一些限制： 定义变量，同时显式初始化 不能提供数据类型 只能用在函数内部 123456789var x = 100 //全局变量func main()&#123; fmt.Println(&amp;x,x) x:=\"abc\" //重新定义和初始化同名局部变量，局部有效 fmt.Println(&amp;x,x)&#125;以上程序运行结果：两个&amp;x 内存地址不一样，x值也不一样，可以看出是两个不同的变量 简短模式在函数多值返回，以及if/for/switch等语句中定义局部变量非常方便 简短模式并不总是重新定义变量的，还有可能是部分退化的赋值操作。另外退化赋值的前提条件是至少有一个新变量被定义，且在同一作用域。常见在函数返回err时，始终重复使用err变量 12345678910func main()&#123; x := 100 fmt.Println(&amp;x) x, y := 20,\"abc\" // fmt.Println(&amp;x,x,y)//&amp;x是同一个 x这是退化赋值 &#123; x,y := 12,12 //作用域不同，这里都是重新定义变量 &#125;&#125; 未使用错误编译的时候未使用的局部变量会报错，而全局变量不会。 空标识符_空标识符可临时用来规避编译器对未使用的变量或包的错误检查，但是请注意它是预置成员，不能重新定义。 常量常量表示运行时恒定不可改变的值，通常是一些字面量。常量必须是编译期可确定的字符、字符串、数字、布尔值，可指定常量类型或者由编译器通过初始化推断。不曾使用的常量不会编译报错。 12345678910const x,y int = 123,0x22const s = \"hello\"const c = '哈'const ( i,f = 123,2.3 //int，float64(默认) b = false)func main()&#123; const s = 45 //可以在不同作用域定义同名常量&#125; 可以是编译器可以计算出来的表达式(比如unsafe.Sizeof，cap,len等)，范围必须要正确 12345678const ( x, y = 99, -999 b byte = byte(x) //b 是byte类型，必须显式的将x转为byte n = uint8(y) //错误范围溢出 ptrSize = unsafe.Sizeof(uintptr(0)) strSize = len(\"hello\")) 在常量组中，如不指定类型和初始化值，则与上一行非空常量右值相同 123456const ( x uint16 = 120 y //与上一行x 右值、类型相同 s = \"abc\" z //与上一行s 右值、类型相同) 枚举Go没有明确意义上的enum定义，但是可以借助iota标识符实现一组自增常量值，来实现枚举类型 123456789101112const ( x = iota //0 y //1 z //2)const ( _ = iota //0 KB = 1 &lt;&lt; (10 * iota) // 1 &lt;&lt; (10 * 1) MB // 1 &lt;&lt; (10 * 2) GB // 1 &lt;&lt; (10 * 3)) 自增作用范围为常量组。可以在多常量定义中使用多个iota，它们各自单独计数，只需要确保组中每行常量个数相同即可 12345const ( _, _ = iota ,iota * 10 // 0, 0 * 10 a, b // 1, 1 * 10 c, d // 2, 2 * 10) 如果中断iota自增，必须显式恢复，切后续自增值按行序递增。 12345678const ( a = iota //0 b //1 c = 100 //100 d //100 与上一行保持一致 e = iota //4 恢复iota,行序递增 f //5) 自增默认类型为int,当然你可以显示的指定类型 常量和变量区别常量是只读，不能取地址。数字常量不会分配存储空间，无需像变量那要通过内存寻址来取值，因此无法获取地址。变量在运行期分配存储内存（非优化状态）常量通常会被编译器在预处理阶段直接展开，作为指令数据使用。 1234const x = 100 //无类型声明的常量const y byte = x //直接展开x,相当于const y byte = 100const a int = 100 //显式指定常量类型，编译器会做强类型检查const b byte = a //错误，can not use a （type int）as type byte in const initializer","categories":[{"name":"golang","slug":"golang","permalink":"https://devying.github.io/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://devying.github.io/tags/golang/"}]},{"title":"golang性能分析工具","slug":"golang性能分析工具","date":"2019-11-08T16:23:02.000Z","updated":"2019-11-11T07:33:49.306Z","comments":true,"path":"2019/11/09/golang性能分析工具/","link":"","permalink":"https://devying.github.io/2019/11/09/golang%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/","excerpt":"","text":"pprof介绍pprof 类似于php的xhprof，在代码运行期间进行CPU、内存等指标采样，拿到采样数据后可以进行分析，还可以绘制成可视化的图，方便排查性能瓶颈。在go语言中使用的是官方提供的两个包runtime/pprof和net/http/pprof，分别用在脚本方式运行的程序和http server方式运行的程序中。 功能 CPU Profiling：CPU 分析，按照一定的频率采集所监听的应用程序 CPU（含寄存器）的使用情况，可确定应用程序在主动消耗 CPU 周期时花费时间的位置 Memory Profiling：内存分析，在应用程序进行堆分配时记录堆栈跟踪，用于监视当前和历史内存使用情况，以及检查内存泄漏 Block Profiling：阻塞分析，记录 goroutine 阻塞等待同步（包括定时器通道）的位置 Mutex Profiling：互斥锁分析，报告互斥锁的竞争情况 使用方法演示1：分析一个简单的脚本性能。由于runtime/pprof包没有封装使用起来不方便，可以使用github.com/pkg/profile替换。操作步骤: 执行脚本得到分析样本 使用go tool pprof 命令分析样本 go tool pprof [-http=:8080] [binfile] pproffile 演示2：分析task_center服务CPU概况。操作步骤: 执行压测命令wrk wrk [-t线程数] [-c并发数] [-d压测时间] 接口地址 采集样本 go tool pprof -seconds=3 http://10.77..39.89:6608/debug/pprof/profile注意这个seconds 不要超过http设置的WriteTimeout值。 使用go tool pprof 命令分析样本 go tool pprof [-http=:8080] [binfile] pprof_file 演示3：分析task_center服务内存概况。 操作步骤: 执行压测命令wrk wrk [-t线程数] [-c并发数] [-d压测时间] 接口地址 采集样本 go tool pprof -seconds=3 http://127.0.0.1:8080/debug/pprof/heap默认情况下只分析当前活跃对象使用到的内存 可以追加 -alloc_objects(临时分配内存) -inuse_objects（正在使用的对象分配内存） -alloc_space(自程序运行依赖一共分配了多少内存) -inuse_space(常驻内存)等选项查看相应的内存概况 使用go tool pprof 命令分析样本 go tool pprof [-http=:8080] [binfile] pprof_file trace介绍在引入执行trace程序之前，已经有了pprof内存和CPU分析器，那么为什么它还会被添加到官方的工具链中呢？虽然CPU分析器做了一件很好的工作，告诉你什么函数占用了最多的CPU时间，但它并不能帮助你确定是什么阻止了goroutine运行，或者在可用的OS线程上如何调度goroutines。这正是跟踪器真正起作用的地方。trace设计文档很好地解释了跟踪程序背后的动机以及它是如何被设计和工作的。 使用方法演示1：分析一个简单的脚本trace信息操作步骤: 执行脚本得到分析样本 使用go tool trace 命令分析样本 go tool trace trace_file 演示2：分析task_center的trace信息操作步骤: 执行压测命令wrk wrk [-t线程数] [-c并发数] [-d压测时间] 接口地址 采集样本 curl http://127.0.0.1:6608/debug/pprof/trace &gt; trace.out 使用go tool pprof 命令分析样本 go tool trace [-http=addr:port] trace_file 指标含义View trace最复杂、最强大和交互式的可视化显示了整个程序执行的时间轴。这个视图显示了在每个虚拟处理器上运行着什么，以及什么是被阻塞等待运行的。 Goroutine analysis显示了在整个执行过程中，每种类型的goroutines是如何创建的。在选择一种类型之后就可以看到关于这种类型的goroutine的信息。例如，在试图从mutex获取锁、从网络读取、运行等等每个goroutine被阻塞的时间。 Network/Sync/Syscall blocking profile这些图表显示了goroutines在这些资源上所花费的时间。它们非常接近pprof上的内存/cpu分析。这是分析锁竞争的最佳选择。 Scheduler latency profiler为调度器级别的信息提供计时功能，显示调度在哪里最耗费时间。 ###参考 https://www.youtube.com/watch?v=nok0aYiGiYA https://artem.krylysov.com/blog/2017/03/13/profiling-and-optimizing-go-web-applications/ https://www.itcodemonkey.com/article/5419.html https://making.pusher.com/go-tool-trace/ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package mainimport ( \"bufio\" \"fmt\" \"io\" \"os\" \"strconv\" \"github.com/pkg/profile\")func main() &#123; p := profile.Start(profile.CPUProfile,profile.ProfilePath(\"./\")) defer p.Stop() f, err := os.OpenFile(\"/Users/baoying5/Downlosdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfadfasdfasdfasdfasdfads/new.csv\", os.O_RDONLY, os.ModePerm) if err != nil &#123; panic(err) &#125; defer f.Close() bfio := bufio.NewReader(f) a := 0 b := 0 am := make(map[int]bool) bm := make(map[int]bool) for &#123; l, _, err := bfio.ReadLine() if err != nil &amp;&amp; err != io.EOF &#123; panic(err) &#125; if err == io.EOF &#123; break &#125; uid, err := strconv.Atoi(string(l)) if err != nil &#123; panic(err) &#125; if uid &gt; 3000232374 &#123; a++ am[uid] = true &#125; else &#123; b++ bm[uid] = true &#125; //println(string(l)) &#125; fmt.Println(a, b)&#125;","categories":[{"name":"golang","slug":"golang","permalink":"https://devying.github.io/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://devying.github.io/tags/golang/"},{"name":"工具","slug":"工具","permalink":"https://devying.github.io/tags/%E5%B7%A5%E5%85%B7/"}]}]}
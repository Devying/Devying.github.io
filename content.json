{"meta":{"title":"熠熙轻雷","subtitle":"blog","description":"","author":"Devying","url":"https://devying.github.io","root":"/"},"pages":[{"title":"书单","date":"2019-11-09T14:31:33.201Z","updated":"2019-11-07T10:29:47.429Z","comments":false,"path":"books/index.html","permalink":"https://devying.github.io/books/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2019-11-09T14:31:33.179Z","updated":"2019-11-07T10:29:47.428Z","comments":false,"path":"/404.html","permalink":"https://devying.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2019-11-09T14:31:33.193Z","updated":"2019-11-09T13:26:46.966Z","comments":false,"path":"about/index.html","permalink":"https://devying.github.io/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-11-09T14:31:33.202Z","updated":"2019-11-07T10:29:47.429Z","comments":false,"path":"categories/index.html","permalink":"https://devying.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-11-09T14:31:33.205Z","updated":"2019-11-07T10:29:47.429Z","comments":true,"path":"links/index.html","permalink":"https://devying.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-11-09T14:31:33.206Z","updated":"2019-11-07T10:29:47.429Z","comments":false,"path":"repository/index.html","permalink":"https://devying.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-11-09T14:33:21.781Z","updated":"2019-11-09T14:33:21.781Z","comments":false,"path":"tags/index.html","permalink":"https://devying.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"golang变量和常量","slug":"golang变量和常量","date":"2019-11-08T16:23:02.000Z","updated":"2019-11-12T07:32:08.836Z","comments":true,"path":"2019/11/09/golang变量和常量/","link":"","permalink":"https://devying.github.io/2019/11/09/golang%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/","excerpt":"","text":"变量Go变量总是有固定的数据类型，类型决定了变量内存的长度和存储格式。我们只能修改变量值，无法改变类型。 通过类型转换或者指针操作，我们可以用不同方式修改变量值，但是这并不意味着改变了变量类型。 关键字var可以用于定义变量，运行时内存分配操作会确保变量自动初始化为二进制零值，避免出现不可预测行为。如果显式提供初始化值，可以省略变量类型，由编译器推断。 123var x int //自动初始化为 0var y = false //自动推断为bool类型var z int = 0 //可以省略int 一次性定义多个变量 12var x,y int //相同类型的多个变量var a,s = 100, \"abc\" //不同类型初始化值 按照惯例，以组的方式整理多行变量定义。 1234var ( x, y int a, s = 300, \"abc\") 简短模式除了var 关键字还可以用更简短的变量定义和初始化语法 12x := 100a,s := 1, \"abc\" 简短模式有一些限制： 定义变量，同时显式初始化 不能提供数据类型 只能用在函数内部 123456789var x = 100 //全局变量func main()&#123; fmt.Println(&amp;x,x) x:=\"abc\" //重新定义和初始化同名局部变量，局部有效 fmt.Println(&amp;x,x)&#125;以上程序运行结果：两个&amp;x 内存地址不一样，x值也不一样，可以看出是两个不同的变量 简短模式在函数多值返回，以及if/for/switch等语句中定义局部变量非常方便 简短模式并不总是重新定义变量的，还有可能是部分退化的赋值操作。另外退化赋值的前提条件是至少有一个新变量被定义，且在同一作用域。常见在函数返回err时，始终重复使用err变量 12345678910func main()&#123; x := 100 fmt.Println(&amp;x) x, y := 20,\"abc\" // fmt.Println(&amp;x,x,y)//&amp;x是同一个 x这是退化赋值 &#123; x,y := 12,12 //作用域不同，这里都是重新定义变量 &#125;&#125; 未使用错误编译的时候未使用的局部变量会报错，而全局变量不会。 空标识符_空标识符可临时用来规避编译器对未使用的变量或包的错误检查，但是请注意它是预置成员，不能重新定义。 常量常量表示运行时恒定不可改变的值，通常是一些字面量。常量必须是编译期可确定的字符、字符串、数字、布尔值，可指定常量类型或者由编译器通过初始化推断。不曾使用的常量不会编译报错。 12345678910const x,y int = 123,0x22const s = \"hello\"const c = '哈'const ( i,f = 123,2.3 //int，float64(默认) b = false)func main()&#123; const s = 45 //可以在不同作用域定义同名常量&#125; 可以是编译器可以计算出来的表达式(比如unsafe.Sizeof，cap,len等)，范围必须要正确 12345678const ( x, y = 99, -999 b byte = byte(x) //b 是byte类型，必须显式的将x转为byte n = uint8(y) //错误范围溢出 ptrSize = unsafe.Sizeof(uintptr(0)) strSize = len(\"hello\")) 在常量组中，如不指定类型和初始化值，则与上一行非空常量右值相同 123456const ( x uint16 = 120 y //与上一行x 右值、类型相同 s = \"abc\" z //与上一行s 右值、类型相同) 枚举Go没有明确意义上的enum定义，但是可以借助iota标识符实现一组自增常量值，来实现枚举类型 123456789101112const ( x = iota //0 y //1 z //2)const ( _ = iota //0 KB = 1 &lt;&lt; (10 * iota) // 1 &lt;&lt; (10 * 1) MB // 1 &lt;&lt; (10 * 2) GB // 1 &lt;&lt; (10 * 3)) 自增作用范围为常量组。可以在多常量定义中使用多个iota，它们各自单独计数，只需要确保组中每行常量个数相同即可 12345const ( _, _ = iota ,iota * 10 // 0, 0 * 10 a, b // 1, 1 * 10 c, d // 2, 2 * 10) 如果中断iota自增，必须显式恢复，切后续自增值按行序递增。 12345678const ( a = iota //0 b //1 c = 100 //100 d //100 与上一行保持一致 e = iota //4 恢复iota,行序递增 f //5) 自增默认类型为int,当然你可以显示的指定类型 常量和变量区别常量是只读，不能取地址。数字常量不会分配存储空间，无需像变量那要通过内存寻址来取值，因此无法获取地址。变量在运行期分配存储内存（非优化状态）常量通常会被编译器在预处理阶段直接展开，作为指令数据使用。 1234const x = 100 //无类型声明的常量const y byte = x //直接展开x,相当于const y byte = 100const a int = 100 //显式指定常量类型，编译器会做强类型检查const b byte = a //错误，can not use a （type int）as type byte in const initializer","categories":[{"name":"golang","slug":"golang","permalink":"https://devying.github.io/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://devying.github.io/tags/golang/"}]},{"title":"golang数据类型总结","slug":"golang数据类型总结","date":"2019-10-11T16:23:02.000Z","updated":"2019-11-12T07:31:53.594Z","comments":true,"path":"2019/10/12/golang数据类型总结/","link":"","permalink":"https://devying.github.io/2019/10/12/golang%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/","excerpt":"","text":"基本类型 类型 长度 默认值 说明 bool 1 false byte 1 0 uint8 rune 4 0 Unicode Code Point, int32 int, uint 4或8 0 32 或 64 位 int8, uint8 1 0 -128 ~ 127, 0 ~ 255 int16, uint16 2 0 -32768 ~ 32767, 0 ~ 65535 int32, uint32 4 0 -21亿~ 21亿, 0 ~ 42亿 int64, uint64 8 0 float32 4 0.0 float64 8 0.0 complex64 8 complex128 16 uintptr 4或8 ⾜足以存储指针的 uint32 或 uint64整数 array 值类型 struct 值类型 string “” UTF-8 字符串 slice nil 引⽤用类型 map nil 引⽤用类型 channel nil 引⽤用类型 interface nil 接⼝ function nil 函数 支持八进制，十六进制以及科学计数法 1234567891011121314a,b,c := 100,0144,0x64fmt.Println(a,b,c) //100,100,100fmt.Printf(\"0b%b,%#o,%#x\",a,b,c)//0b1100100,0144,0x64fmt.Prinln(math.MaxInt8,math,MinInt8)//127,-128//进制转换到十进制a,_ := strconv.ParseInt(\"1100100\",2,32) //100b,_ := strconv.ParseInt(\"0144\",8,32) //100c,_ := strconv.ParseInt(\"0x64\",16,32) //100//十进制转到其他进制strconv.FormatInt(a,2) //1100100strconv.FormatInt(a,8) //144strconv.FormatInt(a,16) //64 注意浮点数 默认浮点类型是float64 12345678910111213141516package mainimport ( \"fmt\")func main() &#123; var a float32 = 1.123456789 var b float32 = 1.123456781 var c float32 = 1.12345678 println(a, b, c) println(a == b, b == c, a == c) fmt.Printf(\"%v,%v,%v\", a, b, c)&#125;+1.123457e+000 +1.123457e+000 +1.123457e+000true true true1.1234568,1.1234568,1.1234568 别名byte 是 uint8 别名rune 是 int32 别名别名类型不需要转换可以直接赋值，比如下面这样没有问题。但是注意了，就算你在32操作系统上int 并不等于int32，在64位系统上int 并不等于int64 123456789func main()&#123; var x byte = 0x11 var y uint8 = x var z uint8 = x + y test(z)&#125;func test(x byte) &#123; println(x)&#125; 引用类型特指slice，map，chan 这三类内置函数new按指定类型长度分配零值内存，返回指针，并不关心类型内部构造和初始化方式，而引用类型必须要使用make来创建，编译器会将make转为目标类型专用的创建函数（或指令），以确保全部内存分配和相关属性初始化。 类型转换不⽀支持隐式类型转换 12345678a := 10b := byte(a)c := a + int(b) //混合表达式 必须保持类型一致，a自动推断为int 所以a + 后面的也必须是intvar n int = int(b) // 显式转换println(a, b, c) //10，10，20d := bool(a) //这里就有问题了 如果转换的目标是指针，单向通道或者是没有返回值的函数,必须要使用括号。避免造成语法分析错误 1234d := (*int)(&amp;a) //0xc000032780e := (&lt;-chan int)(ch)f := (func())(x)g := func()int(x) //有返回值的可以省略括号 自定义类型使用关键字type定义，包括基于现有基础类型创建或者是结构体、函数类型等。 123456789101112type flag byteconst ( read flag = 1 &lt;&lt; iota write exec)func main()&#123; f := read | exec fmt.Printf(\"%b\\n\",f)&#125;//101 和var 、const 类似，多个type定义可以合并成组，可以在函数或者代码块内定义局部类型。 12345678910111213141516func main()&#123; type ( user struct &#123; //结构体类型 name string age uint8 &#125; event func(string) bool //函数类型 ) u := user&#123;\"huangby\",30&#125; fmt.Println(u) var f event = func(s string) bool &#123; println(s) return s !=\"\" &#125; f(\"huangby\")&#125; 未命名类型与有明确标识符的 bool、int、string 等类型相比，数组、切片、字典、通道等类型与具体类型的长度等属性有关，故称作为命了类型。具有相同声明的未命名类型被视作同一类型。 具有相同基类型的指针。 具有相同元素类型和长度的数组 array 具有相同元素类型的切片 slice 具有相同键值类型的字典 map 具有相同数据类型以及操作方向的通道 channel 具有相同字段序列（字段名、字段类型、标签、字段顺序）的结构体 struct 具有相同签名(参数和返回值，不包括参数名)的函数 func 具有相同方法集（方法名，方法签名）的接口 interface{} 指针不能将内存地址与指针混为一谈内存地址是内存中每个字节单元的唯一编号，指针则是一个实体。指针会分配内存空间，相当于一个专门用来保存地址的整形变量。 123456 p := &amp;x x:=100------------|-------|----\\\\----|---------|-----memory... |0x1200 | ···· | 100 |------------|-------|----\\\\----|---------|-----addr 0x80 0x1200 ----------------------------------------------- &amp;符号用来获取对象地址 指针运算符*用于间接引用目标对象 二级指针 ** T,如包含包名则写成*package T 并非所有的对象都能进行取地址操作，但变量总是能正确返回。指针运算符为左值时(*a = 20)，可以更新目标对象状态，而为右值时(a := *b)，则是为了获取目标状态。指针支持相等运算，单不支持加减法和类型转换。 可以通过unsafe.Pointer将指针转换为 uintptr 后加减运算，但可能会造成非法访问。 Pointer类似于C中的void* 万能指针，可以用来转换指针类型。它能安全持有对象或对象成员，但是 uintptr 不行。uintptr 仅是一种特殊整形，并不引用目标对象，无法阻止垃圾回收器回收对象内存。 123var a,b struct&#123;&#125;println(&amp;a,&amp;b) //都是0x---------println(&amp;a==&amp;b ,&amp;a==nil) //第一个不一定true 但是第二个肯定false 初始化对复合类型（数组，切片，字典，结构体）变量初始化时，有一些语法限制。 初始化表达式必须含有类型标签 左花括号必须在类型尾部，不能另起一行 多个成员初始值以逗号分隔 允许多行，但是每行必须以逗号或者右花括号结束。1234567891011121314type data struct&#123; x int s string&#125;var a data = data&#123;1,\"abc\"&#125;b := data&#123;2,\"def\"&#125;c := []int&#123;1,2,3&#125;var d = map[string]string&#123;\"name\":\"huangby\",\"addr\":\"beijing\"&#125;d := map[string]string&#123;\"name\": \"huangby\", \"addr\": \"beijing\"&#125;d[\"a\"] = \"acd\"//但是var d map[string]stringd[\"a\"] = \"acd\" 这就不行了","categories":[{"name":"golang","slug":"golang","permalink":"https://devying.github.io/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://devying.github.io/tags/golang/"}]}]}
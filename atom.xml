<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>熠熙轻雷</title>
  
  <subtitle>blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://devying.github.io/"/>
  <updated>2020-02-05T09:44:53.932Z</updated>
  <id>https://devying.github.io/</id>
  
  <author>
    <name>Devying</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>golang 接口总结</title>
    <link href="https://devying.github.io/2018/05/28/golang%E6%8E%A5%E5%8F%A3/"/>
    <id>https://devying.github.io/2018/05/28/golang接口/</id>
    <published>2018-05-28T08:13:11.000Z</published>
    <updated>2020-02-05T09:44:53.932Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>接口代表一种调用契约，是多个方法声明的集合<br>从内部看接口本身也是一种结构类型，只是编译器会对其作出很多限制。</p><ul><li>不能有字段</li><li>不能定义自己的方法</li><li>只能声明方法不能实现</li><li>可嵌入其他接口类型<br>接口通常以er作为名称后缀，方法名是声明组成部分，但是参数可不同或者省略。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> tester <span class="keyword">interface</span> &#123;</span><br><span class="line">test()</span><br><span class="line"><span class="keyword">string</span>() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*data)</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(data)</span> <span class="title">string</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"+OK"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> d data</span><br><span class="line"><span class="comment">//var t tester = d</span></span><br><span class="line"><span class="comment">//cannot use d (type data) as type tester in assignment:</span></span><br><span class="line"><span class="comment">//data does not implement tester (test method has pointer receiver)</span></span><br><span class="line"><span class="keyword">var</span> t tester = &amp;d</span><br><span class="line"><span class="built_in">println</span>(t.<span class="keyword">string</span>())</span><br><span class="line">&#125;</span><br><span class="line">很明显我们根据上一章的内容知道 *T的方法集中包含了所有T的方法集</span><br></pre></td></tr></table></figure>如何接口没有任何方法声明，那么就是一个空接口(interface{}),它的用途类似于面向对象里面的根类型Object，可被赋值为任何类型的对象。<br>接口变量默认值是nil。如果实现接口的类型支持，可做相等运算。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t1, t2 <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="built_in">println</span>(t1 == <span class="literal">nil</span>, t1 == t2) <span class="comment">//true true</span></span><br><span class="line">t1, t2 = <span class="number">100</span>, <span class="number">100</span></span><br><span class="line"><span class="built_in">println</span>(t1 == t2) <span class="comment">//true</span></span><br><span class="line">t1, t2 = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;&#125;, <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="built_in">println</span>(t1 == t2)</span><br><span class="line"><span class="comment">//panic: runtime error: comparing uncomparable type map[string]int</span></span><br></pre></td></tr></table></figure>可以像匿名字段那样，嵌入其他接口。目标类型方法集中必须拥有包含嵌入接口方法在内的全部方法才算是实现了该接口。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stringer <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="keyword">string</span>() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> tester <span class="keyword">interface</span> &#123;</span><br><span class="line">stringer</span><br><span class="line">test()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*data)</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(data)</span> <span class="title">string</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"+OK"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> d data</span><br><span class="line"><span class="keyword">var</span> t tester = &amp;d</span><br><span class="line">t.test()</span><br><span class="line"><span class="built_in">println</span>(t.<span class="keyword">string</span>())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//+OK</span></span><br></pre></td></tr></table></figure>超集接口变量可隐式转为子集，反过来不行<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stringer <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="keyword">string</span>() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> tester <span class="keyword">interface</span> &#123;</span><br><span class="line">stringer</span><br><span class="line">test()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*data)</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(data)</span> <span class="title">string</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"+OK"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pp</span><span class="params">(a stringer)</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(a.<span class="keyword">string</span>())</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> d data</span><br><span class="line"><span class="keyword">var</span> t tester = &amp;d</span><br><span class="line">pp(t)              <span class="comment">//隐式转换为子集接口</span></span><br><span class="line"><span class="keyword">var</span> s stringer = t <span class="comment">//超集转换为子集</span></span><br><span class="line"><span class="built_in">println</span>(s.<span class="keyword">string</span>())</span><br><span class="line"><span class="comment">//var t2 tester = s //stringer does not implement tester (missing test method)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>支持匿名接口类型，可直接用于变量定义，或作为结构字段类型。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(data)</span> <span class="title">string</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"+OK"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">i <span class="keyword">interface</span> &#123; <span class="comment">//作为结构体字段类型</span></span><br><span class="line"><span class="keyword">string</span>() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> t <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="keyword">string</span>() <span class="keyword">string</span></span><br><span class="line">&#125; = data&#123;&#125; <span class="comment">//直接用于变量定义</span></span><br><span class="line">n := node&#123;</span><br><span class="line">i: t,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println</span>(n.i.<span class="keyword">string</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="执行机制"><a href="#执行机制" class="headerlink" title="执行机制"></a>执行机制</h2>接口使用一个名为itab的结构存储运行期间所需的相关类型信息<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">iface</span></span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    tab *itab           <span class="comment">//类型信息</span></span><br><span class="line">    data <span class="keyword">unsafe</span>.Pointer <span class="comment">//实际对象指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">itab</span></span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    inter *interfacetype <span class="comment">//接口类型</span></span><br><span class="line">    _<span class="keyword">type</span> *_<span class="keyword">type</span>        <span class="comment">//实际对象类型</span></span><br><span class="line">    fun [<span class="number">1</span>]uintptr      <span class="comment">//实际对象方法地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Ner <span class="keyword">interface</span> &#123;</span><br><span class="line">a()</span><br><span class="line">b(<span class="keyword">int</span>)</span><br><span class="line">c(<span class="keyword">string</span>) <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> N <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(N)</span> <span class="title">a</span><span class="params">()</span></span>               &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*N)</span> <span class="title">b</span><span class="params">(<span class="keyword">int</span>)</span></span>           &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*N)</span> <span class="title">c</span><span class="params">(<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> <span class="string">"+OK"</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> n N</span><br><span class="line"><span class="keyword">var</span> t Ner = &amp;n</span><br><span class="line">t.a()</span><br><span class="line"><span class="built_in">println</span>(t.c(<span class="string">""</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>另外接口还有一个重要特征：将对象复制给接口变量时，会复制该对象。并且我们甚至无法修改接口存储的复制品，因为它也是不可寻址的。<br>即便将其复制出来，用本地变量修改后，依然无法对iface.data 赋值。解决的办法就是将对象指针赋值给接口，那么接口内存储的就是指针的复制品。<br>我们来试试<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">x <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">d := data&#123;<span class="number">100</span>&#125;</span><br><span class="line"><span class="keyword">var</span> t <span class="keyword">interface</span>&#123;&#125; = d</span><br><span class="line"><span class="built_in">println</span>(t.(data).x)</span><br><span class="line">t.(data).x = <span class="number">20</span> <span class="comment">//cannot assign to t.(data).x</span></span><br><span class="line">p := &amp;t.(data) <span class="comment">//cannot take the address of t.(data)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t1 <span class="keyword">interface</span>&#123;&#125; = &amp;d <span class="comment">//对象指针赋值给接口</span></span><br><span class="line"><span class="built_in">println</span>(t1.(*data))   <span class="comment">//0xc000030728</span></span><br><span class="line">t1.(*data).x = <span class="number">200</span></span><br><span class="line"><span class="built_in">println</span>(t1.(*data).x)<span class="comment">//200</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>只有当接口变量 内部的两个指针<code>itab</code>和<code>data</code>都为nil时，接口才等于nil。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">interface</span>&#123;&#125; = (*<span class="keyword">int</span>)(<span class="literal">nil</span>)</span><br><span class="line"><span class="built_in">println</span>(a == <span class="literal">nil</span>, b == <span class="literal">nil</span>) <span class="comment">//true false</span></span><br><span class="line"></span><br><span class="line">(gdb) info locals</span><br><span class="line">b = &#123;_type = <span class="number">0x10557e0</span> &lt;<span class="keyword">type</span>.*+<span class="number">27744</span>&gt;, data = <span class="number">0x0</span>&#125;</span><br><span class="line">a = &#123;_type = <span class="number">0x0</span>, data = <span class="number">0x0</span>&#125;</span><br></pre></td></tr></table></figure>也正是这样会有一个容易被忽视的错误。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TestError <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*TestError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"error"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">abc</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> err *TestError</span><br><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">err = <span class="built_in">new</span>(TestError)</span><br><span class="line">x = <span class="number">0</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">x += <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x, err <span class="comment">//这里这个err 是有类型的 所以你用err != nil 问题就出现了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">x, err := test(<span class="number">100</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err) <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println</span>(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2>类型推断可以将变量还原为原始类型，或用来判定是否实现了某个更具体的接口类型。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d data)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">"data:%d"</span>, d)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> d data = <span class="number">15</span></span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125; = d</span><br><span class="line"><span class="keyword">if</span> n, ok := x.(fmt.Stringer); ok &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, n) <span class="comment">//15</span></span><br><span class="line">fmt.Println(n)         <span class="comment">//data:15</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> d2, ok := x.(data); ok &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, d2) <span class="comment">//15</span></span><br><span class="line">fmt.Println(d2)         <span class="comment">//data:15</span></span><br><span class="line">&#125;</span><br><span class="line">e := x.(error) <span class="comment">//panic: interface conversion: main.data is not error: missing method Error</span></span><br><span class="line"><span class="built_in">println</span>(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>另外我们还可以用switch语句在多种类型间做出推断匹配。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> y <span class="keyword">interface</span>&#123;&#125; = <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">"d:%d"</span>, x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> v := y.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"nil"</span>)</span><br><span class="line"><span class="keyword">case</span> *<span class="keyword">int</span>:</span><br><span class="line"><span class="built_in">println</span>(*v)</span><br><span class="line"><span class="keyword">case</span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">string</span>:</span></span><br><span class="line"><span class="built_in">println</span>(v(<span class="number">100</span>))</span><br><span class="line"><span class="keyword">case</span> fmt.Stringer:</span><br><span class="line">fmt.Println(v)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"unknow"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2>让编译器检查，确保类型实现了指定接口。<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> x int</span><br><span class="line"></span><br><span class="line">func init() <span class="comment">&#123;</span></span><br><span class="line"><span class="comment">var _ fmt.Stringer = x(0)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"></span><br><span class="line">func main() <span class="comment">&#123;</span></span><br><span class="line"><span class="comment">fmt.Println("===")</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"></span><br><span class="line">./<span class="keyword">in</span>.go:<span class="number">10</span>:<span class="number">6</span>: cannot use x(<span class="number">0</span>) (<span class="keyword">type</span> x) <span class="keyword">as</span> <span class="keyword">type</span> fmt.Stringer <span class="keyword">in</span> assignment:</span><br><span class="line">        x does <span class="keyword">not</span> implement fmt.Stringer (missing String <span class="function"><span class="keyword">method</span>)</span></span><br></pre></td></tr></table></figure>定义函数类型，让相同签名的函数自动实现某个接口<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FuncString <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">string</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f FuncString)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> f()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> t fmt.Stringer = FuncString(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"hello boy"</span></span><br><span class="line">&#125;)</span><br><span class="line">fmt.Println(t)</span><br><span class="line">fmt.Println(<span class="string">"==="</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hello boy</span><br><span class="line">===</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;接口代表一种调用契约，是多个方法声明的集合&lt;br&gt;从内部看接口本身也是一种结构类型，只是编译器会对其作出很多限制。&lt;/p&gt;
&lt;ul&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="golang" scheme="https://devying.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://devying.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>golang 方法总结</title>
    <link href="https://devying.github.io/2018/05/19/golang%E6%96%B9%E6%B3%95/"/>
    <id>https://devying.github.io/2018/05/19/golang方法/</id>
    <published>2018-05-19T07:23:02.000Z</published>
    <updated>2020-02-05T09:43:23.698Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>方法是对象实例绑定的特殊函数，方法和函数的区别是前者有前置实例接收参数（receiver），编译器以此确定方法所属类型。<br>我们可以为当前包，以及除接口和指针以外的任何类型定义方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> N <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n N)</span> <span class="title">toString</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">"%#x"</span>, n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a N = <span class="number">25</span></span><br><span class="line"><span class="built_in">println</span>(a.toString())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//0x19</span></span><br></pre></td></tr></table></figure><p>方法同样不支持重载。receiver参数名没有限制，按惯例会选用简短有意义的名称。如方法内部并不引用实例，可以省略参数名，仅保留类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> N <span class="keyword">int</span></span><br><span class="line">fun (N) test()&#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"hi"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法可以看作特殊的函数，那么receiver的类型自然可以是基础类型或指针类型。这会关系到调用时对象实例是否被复制。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> N <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n N)</span> <span class="title">value</span><span class="params">()</span></span> &#123;</span><br><span class="line">n++</span><br><span class="line">fmt.Printf(<span class="string">"v: %p,%v\n"</span>, &amp;n, n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *N)</span> <span class="title">pointer</span><span class="params">()</span></span> &#123;</span><br><span class="line">(*n)++</span><br><span class="line">fmt.Printf(<span class="string">"v: %p,%v\n"</span>, n, *n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a N = <span class="number">25</span></span><br><span class="line">a.value()</span><br><span class="line">a.pointer()</span><br><span class="line">fmt.Printf(<span class="string">"a: %p,%v\n"</span>, &amp;a, a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// v: 0xc000086008,26    // receiver 被复制</span></span><br><span class="line"><span class="comment">// v: 0xc000086000,26</span></span><br><span class="line"><span class="comment">// a: 0xc000086000,26</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><p>可以使用<code>实例值或者指针</code>调用方法，编译器会根据方法 receiver类型自动在基础类型和指针类型间转换,但是不能用多级指针调用方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n N)</span> <span class="title">value</span><span class="params">()</span></span> &#123;</span><br><span class="line">n++</span><br><span class="line">fmt.Printf(<span class="string">"v: %p,%v\n"</span>, &amp;n, n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *N)</span> <span class="title">pointer</span><span class="params">()</span></span> &#123;</span><br><span class="line">(*n)++</span><br><span class="line">fmt.Printf(<span class="string">"v: %p,%v\n"</span>, n, *n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a N = <span class="number">25</span></span><br><span class="line">a.value()</span><br><span class="line">a.pointer()</span><br><span class="line">fmt.Printf(<span class="string">"a: %p,%v\n"</span>, &amp;a, a)</span><br><span class="line">b := &amp;a</span><br><span class="line">b.value()</span><br><span class="line">b.pointer()</span><br><span class="line">    fmt.Printf(<span class="string">"b: %p,%v"</span>, b, *b)</span><br><span class="line">    c := &amp;b</span><br><span class="line">    c.value() <span class="comment">//错误：calling method value with receiver c (type **N) requires explicit dereference</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指针类型的receiver必须是合法的指针(包括nil)，或能获取实例地址。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> X <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *X)</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"hi"</span>, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a *X</span><br><span class="line">a.test()  <span class="comment">//hi 0x0</span></span><br><span class="line">X&#123;&#125;.test()  <span class="comment">//cannot call pointer method on X literal</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何选择方法的receiver类型呢</p><ul><li>要修改实例状态，用*T。</li><li>无需修改状态的小对象或者固定值，建议用T。</li><li>大对象建议用*T，以减少复制成本。</li><li>引用类型、字符串、函数等指针包装对象，直接用T。</li><li>若包含Mutex等同步字段，用*T，避免复制造成锁操作无效。</li><li>其他无法确定的情况，都用*T</li></ul><h3 id="匿名字段"><a href="#匿名字段" class="headerlink" title="匿名字段"></a>匿名字段</h3><p>可以像访问匿名字段成员那样调用其方法，由编译器负责查找。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">sync.Mutex</span><br><span class="line">buf [<span class="number">1024</span>]<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">d := data&#123;&#125;</span><br><span class="line">d.Lock() <span class="comment">//编译器会处理为sycn.(*Mutex).Lock()  怎么有点断言的意思</span></span><br><span class="line"><span class="keyword">defer</span> d.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法也会有同名遮蔽问题。但是利用这种特性，可实现类似覆盖操作。尽管能直接访问匿名字段的成员和方法，但是它们依然不属于继承关系。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> manager <span class="keyword">struct</span> &#123;</span><br><span class="line">user</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(user)</span> <span class="title">toString</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"user"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m manager)</span> <span class="title">toString</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> m.user.toString() + <span class="string">";manager"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> m manager</span><br><span class="line"><span class="built_in">println</span>(m.toString())</span><br><span class="line"><span class="built_in">println</span>(m.user.toString())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// user;manager</span></span><br><span class="line"><span class="comment">// user</span></span><br></pre></td></tr></table></figure><h3 id="方法集"><a href="#方法集" class="headerlink" title="方法集"></a>方法集</h3><p>类型有一个与之相关的方法集，这决定了它是否实现了某个接口。</p><ul><li>类型T方法集包含所有<code>receiver T</code>方法。</li><li>类型<em>T方法集包含了所有<code>receiver T</code> + `</em>T`方法。</li><li>匿名嵌入S，<code>T</code>方法集包含了所有<code>receiver S</code>方法。</li><li>匿名嵌入<em>S，<code>T</code>方法集包含了所有<code>receiver S</code>+`</em>S`方法。</li><li>匿名嵌入S或者<em>S,`</em>T<code>方法集合包含了所有</code>receiver S<code>+</code>*S`方法</li></ul><p>可以利用发射测试这些规则。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">S</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(S)</span> <span class="title">sVal</span><span class="params">()</span></span>  &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*S)</span> <span class="title">sPtr</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(T)</span> <span class="title">tVal</span><span class="params">()</span></span>  &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*T)</span> <span class="title">tPtr</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">methodSet</span><span class="params">(a <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">t := reflect.TypeOf(a)</span><br><span class="line"><span class="keyword">for</span> i, n := <span class="number">0</span>, t.NumMethod(); i &lt; n; i++ &#123;</span><br><span class="line">m := t.Method(i)</span><br><span class="line">fmt.Println(m.Name, m.Type)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> t T</span><br><span class="line">methodSet(t)</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"--------"</span>)</span><br><span class="line">methodSet(&amp;t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法集仅影响接口实现和方法表达式转换，与通过实例或者实例指针调用方法无关。实例并不使用方法集，而是直接调用（或通过隐式字段名）</p><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>方法和函数一样，除直接调用外，还可以赋值给变量，或作为参数传递。依照具体引用方式的不同，可分为expression 和 value 两种状态</p><h4 id="Method-Expression"><a href="#Method-Expression" class="headerlink" title="Method Expression"></a>Method Expression</h4><p>通过类型引用的 method expression 会被还原为普通函数样式，receiver 是第一参数，调用时须显式传参。至于类型，可以是T或者*T,只要目标方法存在该类型方法集中即可。<br>//func (n N ) test() 这个底层会转成  func test(n N)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> N <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n N)</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"test.n: %p, %d\n"</span>, &amp;n, n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> n N = <span class="number">25</span></span><br><span class="line">fmt.Printf(<span class="string">"main.n: %p, %d\n"</span>, &amp;n, n)</span><br><span class="line">f1 := N.test <span class="comment">//把方法赋给f1  func(n N)   通过类型(N)引用的 method expression</span></span><br><span class="line">f1(n)  <span class="comment">//receiver 是第一参数</span></span><br><span class="line">f2 := (*N).test <span class="comment">// func(n *N)        通过类型(*N)引用的 method expression</span></span><br><span class="line">f2(&amp;n)          <span class="comment">//传递指针   receiver 是第一参数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main.n: 0xc000080000, 25</span></span><br><span class="line"><span class="comment">// test.n: 0xc000080018, 25</span></span><br><span class="line"><span class="comment">// test.n: 0xc00008a000, 25</span></span><br></pre></td></tr></table></figure><blockquote><p><code>*T</code>是包含了所有<code>T</code>的方法集，所以上面这个例子中 test方法存在<code>*T</code>方法集中（只要目标方法存在该类型方法集中即可）<br>因此我们变更一下看看下面这个例子</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> N <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *N)</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"test.n: %p, %d\n"</span>, n, *n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> n N = <span class="number">25</span></span><br><span class="line">fmt.Printf(<span class="string">"main.n: %p, %d\n"</span>, &amp;n, n)</span><br><span class="line">f1 := N.test    <span class="comment">//把方法赋给f1  func(n N)   通过类型(N)引用的 method expression 目标方法test不在类型N的方法集中</span></span><br><span class="line">f1(n)           <span class="comment">//receiver 是第一参数</span></span><br><span class="line">f2 := (*N).test <span class="comment">// func(n *N)        通过类型(*N)引用的 method expression</span></span><br><span class="line">f2(&amp;n)          <span class="comment">//传递指针   receiver 是第一参数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//invalid method expression N.test (needs pointer receiver: (*N).test)</span></span><br><span class="line"><span class="comment">//目标方法test() 不在 `T`的方法集中，所以这样就不行</span></span><br></pre></td></tr></table></figure><p>所以这里可以知道，在第一个例子中，尽管你用的是*N 你的receiver类型是指针，但是编译器会保证按原定义类型拷贝传值。(原定义类型是func (n N) test()),同理第二个例子肯定是地址一样的。<br>当然上面的代码也可以一步到位，直接以表达式的方式调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> N <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n N)</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"test.n: %p, %d\n"</span>, &amp;n, n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> n N = <span class="number">25</span></span><br><span class="line">fmt.Printf(<span class="string">"main.n: %p, %d\n"</span>, &amp;n, n)</span><br><span class="line">N.test(n)</span><br><span class="line">(*N).test(&amp;n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main.n: 0xc000018080, 25</span></span><br><span class="line"><span class="comment">// test.n: 0xc000018098, 25     </span></span><br><span class="line"><span class="comment">// test.n: 0xc000088000, 25</span></span><br></pre></td></tr></table></figure><p>同理</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> N <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *N)</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"test.n: %p, %d\n"</span>, n, *n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> n N = <span class="number">25</span></span><br><span class="line">fmt.Printf(<span class="string">"main.n: %p, %d\n"</span>, &amp;n, n)</span><br><span class="line"><span class="comment">//f2 := (*N).test // func(n *N)        通过类型(*N)引用的 method expression</span></span><br><span class="line">(*N).test(&amp;n) <span class="comment">//传递指针   receiver 是第一参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Method-Value"><a href="#Method-Value" class="headerlink" title="Method Value"></a>Method Value</h4><p>基于<code>实例或者指针</code>引用的method value，参数签名不会改变，依旧按正常方式调用。但当method value 被赋值给变量或者作为参数传递时，会立即计算并复制该方法执行所需的 receiver 对象，与其绑定，以便在稍后执行时，能隐式的传入receiver参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> N <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n N)</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"test.n: %p, %v\n"</span>, &amp;n, n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> n N = <span class="number">25</span></span><br><span class="line">p := &amp;n</span><br><span class="line">n++</span><br><span class="line">f1 := n.test <span class="comment">//通过实例引用的method value 被赋值给变量 这里复制了n  直接等同于 func test()</span></span><br><span class="line">n++</span><br><span class="line">f2 := p.test <span class="comment">//通过指针引用method value 被赋值给变量 而这里复制了*p 所以是27 而不是28</span></span><br><span class="line">n++</span><br><span class="line">fmt.Printf(<span class="string">"main.n: %p, %v\n"</span>, p, n)</span><br><span class="line">f1()</span><br><span class="line">f2()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main.n: 0xc000090000, 28</span></span><br><span class="line"><span class="comment">// test.n: 0xc000090018, 26</span></span><br><span class="line"><span class="comment">// test.n: 0xc00007e008, 27</span></span><br></pre></td></tr></table></figure><p>当method value 作为参数时，会复制含receiver在内的整个method value。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> N <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n N)</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"test.n: %p, %v\n"</span>, &amp;n, n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">call</span><span class="params">(m <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">m()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> n N = <span class="number">25</span></span><br><span class="line">p := &amp;n</span><br><span class="line">fmt.Printf(<span class="string">"main.n: %p, %v\n"</span>, p, n)</span><br><span class="line"></span><br><span class="line">n++</span><br><span class="line">call(n.test)</span><br><span class="line"></span><br><span class="line">n++</span><br><span class="line">call(p.test)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.n: 0xc000082000, 25</span></span><br><span class="line"><span class="comment">// test.n: 0xc000082018, 26</span></span><br><span class="line"><span class="comment">// test.n: 0xc00008c000, 27</span></span><br></pre></td></tr></table></figure><p>我们把 receiver类型改成指针，那么复制的仅是指针了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> N <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *N)</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"test.n: %p, %v\n"</span>, n, *n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> n N = <span class="number">25</span></span><br><span class="line">p := &amp;n</span><br><span class="line"></span><br><span class="line">n++</span><br><span class="line">f1 := n.test</span><br><span class="line"></span><br><span class="line">n++</span><br><span class="line">f2 := p.test</span><br><span class="line"></span><br><span class="line">n++</span><br><span class="line">fmt.Printf(<span class="string">"main.n: %p, %v\n"</span>, p, n)</span><br><span class="line"></span><br><span class="line">f1()</span><br><span class="line">f2()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.n: 0xc000018078, 28</span></span><br><span class="line"><span class="comment">// test.n: 0xc000018078, 28</span></span><br><span class="line"><span class="comment">// test.n: 0xc000018078, 28</span></span><br></pre></td></tr></table></figure><p>只要 receiver 参数类型正确，使用nil同样可以执行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> N <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n N)</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"test.n: %p, %v\n"</span>, &amp;n, n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*N)</span> <span class="title">pointer</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//fmt.Printf("point.n: %p, %v\n", n, *n)</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">"===="</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a *N</span><br><span class="line"><span class="keyword">var</span> b N</span><br><span class="line">a.pointer()</span><br><span class="line">(*N)(<span class="literal">nil</span>).pointer()</span><br><span class="line">(*N).pointer(<span class="literal">nil</span>)</span><br><span class="line">N.test(b)</span><br><span class="line">&#125;</span><br><span class="line">====</span><br><span class="line">====</span><br><span class="line">====</span><br><span class="line">test.n: <span class="number">0xc00008a000</span>, <span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;方法是对象实例绑定的特殊函数，方法和函数的区别是前者有前置实例接收参数（receiver），编译器以此确定方法所属类型。&lt;br&gt;我们可以为当
      
    
    </summary>
    
    
      <category term="golang" scheme="https://devying.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://devying.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>golang 结构体总结</title>
    <link href="https://devying.github.io/2018/04/19/golang%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <id>https://devying.github.io/2018/04/19/golang结构体/</id>
    <published>2018-04-18T16:23:02.000Z</published>
    <updated>2019-11-17T07:13:20.001Z</updated>
    
    <content type="html"><![CDATA[<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>字段名必须唯一，可以用”_”来部位，支持使用自身指针类型成员。字段名、排列顺序属类型组成部分。除对齐处理外，编译器不会优化，调整内存布局。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">_    <span class="keyword">int</span></span><br><span class="line">id   <span class="keyword">int</span></span><br><span class="line">next *node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">n1 := node&#123;</span><br><span class="line">id: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line">n2 := node&#123;</span><br><span class="line">id:   <span class="number">2</span>,</span><br><span class="line">next: &amp;n1,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(n1, n2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//&#123;0 1 &lt;nil&gt;&#125; &#123;0 2 0xc00006e020&#125;</span></span><br></pre></td></tr></table></figure><p>只有在所有字段类型全部时，才可以做相等操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">d1 := data&#123;</span><br><span class="line">x: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line">d2 := data&#123;</span><br><span class="line">x: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(d1 == d2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//invalid operation: d1 == d2 (struct containing map[string]int cannot be compared)</span></span><br></pre></td></tr></table></figure><p>可以使用指针直接操作结构字段，但不能是多级指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p := &amp;user&#123;</span><br><span class="line">name: <span class="string">"TOM"</span>,</span><br><span class="line">age:  <span class="number">22</span>,</span><br><span class="line">&#125;</span><br><span class="line">p.name = <span class="string">"TAE"</span></span><br><span class="line">p.age++</span><br><span class="line">p2 := &amp;p</span><br><span class="line">fmt.Println(p, *p2)</span><br><span class="line">(*p2).name = <span class="string">"Jack"</span></span><br><span class="line">fmt.Println((*p2).name)</span><br><span class="line">fmt.Println((*p2).age)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &amp;&#123;TAE 23&#125; &amp;&#123;TAE 23&#125;</span></span><br><span class="line"><span class="comment">// Jack</span></span><br><span class="line"><span class="comment">// 23</span></span><br></pre></td></tr></table></figure><h3 id="空结构"><a href="#空结构" class="headerlink" title="空结构"></a>空结构</h3><p>空结构是指没有字段的结构类型，它比较特殊，因为无论是其自身，还是作为数组元素类型，其长度都是0,<br>但是尽管没有分配数组内存，但依然可以操作元素，对应切片len、cap属性也正常。<br>实际上这类”长度”为零的对象通常都指向runtime.zerobase变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> b [<span class="number">100</span>]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> d [<span class="number">100</span>]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="built_in">println</span>(unsafe.Sizeof(a), unsafe.Sizeof(b))</span><br><span class="line">s := d[:]</span><br><span class="line">d[<span class="number">1</span>] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">s[<span class="number">2</span>] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">fmt.Println(s[<span class="number">3</span>], <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">s1 := [<span class="number">10</span>]<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">s2 := s1[:]</span><br><span class="line">s3 := [<span class="number">0</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%p,%p,%p"</span>, &amp;s1, &amp;s2[<span class="number">0</span>], &amp;s3)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//0 0</span></span><br><span class="line"><span class="comment">//&#123;&#125; 100 100</span></span><br><span class="line"><span class="comment">//0x118efd0,0x118efd0,0x118efd0</span></span><br></pre></td></tr></table></figure><p>空结构可以用作通道元素类型，用于事件通知。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&lt;-ch</span><br></pre></td></tr></table></figure><h3 id="匿名字段"><a href="#匿名字段" class="headerlink" title="匿名字段"></a>匿名字段</h3><p>所谓匿名字段，是指没有名字，仅有类型的字段，也被称作嵌入字段或者嵌入类型,这类用法非常常见。<br>如嵌入其他包中的类型，则隐式字段名不包括包名。就是说定义的时候字段是File而非os.File</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int</span></span><br><span class="line">addr</span><br><span class="line">os.File</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> addr <span class="keyword">struct</span> &#123;</span><br><span class="line">city <span class="keyword">string</span></span><br><span class="line">road <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">u := user&#123;</span><br><span class="line">name: <span class="string">"tom"</span>,</span><br><span class="line">age:  <span class="number">2</span>,</span><br><span class="line">addr: addr&#123;</span><br><span class="line">city: <span class="string">"Beijing"</span>,</span><br><span class="line">road: <span class="string">"XiBeiWang"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">File: os.File&#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">u.city = <span class="string">"Tianjin"</span></span><br><span class="line">fmt.Println(u)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//&#123;tom 2 &#123;Tianjin XiBeiWang&#125; &#123;&lt;nil&gt;&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>不仅仅是结构体，除接口指针和多级指针以外的任何命名类型都可以作为匿名字段</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">*<span class="keyword">int</span></span><br><span class="line"><span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">x := <span class="number">100</span></span><br><span class="line">d := data&#123;</span><br><span class="line"><span class="keyword">int</span>:    &amp;x,</span><br><span class="line"><span class="keyword">string</span>: <span class="string">"Abc"</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, d)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main.data&#123;int:(*int)(0xc00007e008), string:"Abc"&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> a *<span class="keyword">int</span></span><br><span class="line"><span class="keyword">type</span> b **<span class="keyword">int</span></span><br><span class="line"><span class="keyword">type</span> c <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> d <span class="keyword">struct</span> &#123;</span><br><span class="line">*a        <span class="comment">//embedded type cannot be a pointer</span></span><br><span class="line">b         <span class="comment">//embedded type cannot be a pointer</span></span><br><span class="line">c         <span class="comment">//embedded type cannot be a pointer to interface</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不能将基础类型和其指针类型同时嵌入，因为两者隐式名字相同。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> file <span class="keyword">struct</span>&#123;</span><br><span class="line">*<span class="keyword">int</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然可以像普通字段那要访问匿名字段成员，但是会存在重名问题。如果是这样的话就必须要使用显式字段名。<br>如果有多个成员都存在重名情况就必须要使用显式字段名。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> file <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">file</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">d := data&#123;</span><br><span class="line">name: <span class="string">"data"</span>,</span><br><span class="line">file: file&#123;</span><br><span class="line"><span class="string">"file"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">d.name = <span class="string">"data2"</span></span><br><span class="line">d.file.name = <span class="string">"file2"</span> <span class="comment">//使用显式的方式访问 data.file.name</span></span><br><span class="line">fmt.Println(d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//&#123;&#123;file2&#125; data2&#125;</span></span><br></pre></td></tr></table></figure><h3 id="字段标签"><a href="#字段标签" class="headerlink" title="字段标签"></a>字段标签</h3><p>字段标签(tag)并不是注释，而是用来对字段进行描述的元数据。尽管它不属于数据成员，但却是类型的组成部分。<br>在运行期间，可用发射获取标签信息。它常常被用作格式校验，数据库关系映射等。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span> <span class="string">`昵称`</span></span><br><span class="line">sex  <span class="keyword">byte</span>   <span class="string">`性别`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">u := user&#123;<span class="string">"Tom"</span>, <span class="number">1</span>&#125;</span><br><span class="line">v := reflect.ValueOf(u)</span><br><span class="line">t := v.Type()</span><br><span class="line"><span class="keyword">for</span> i, n := <span class="number">0</span>, t.NumField(); i &lt; n; i++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s: %v\n"</span>, t.Field(i).Tag, v.Field(i))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 昵称: Tom</span></span><br><span class="line"><span class="comment">// 性别: 1</span></span><br></pre></td></tr></table></figure><h3 id="内存分布"><a href="#内存分布" class="headerlink" title="内存分布"></a>内存分布</h3><p>不管结构体包含多少字段，其内存总是一次性分配的，各字段在相邻的地址空间按定义顺序排列，当然对于引用类型、字符串和指针，结构内存中只包含其基本（头部）数据。还有，所有匿名字段成员也被包含在内。<br>借助unsafe包中的相关函数，可输出所有字段的偏移量和长度。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> point <span class="keyword">struct</span> &#123;</span><br><span class="line">x, y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> value <span class="keyword">struct</span> &#123;</span><br><span class="line">id    <span class="keyword">int</span>    <span class="comment">//基本类型</span></span><br><span class="line">name  <span class="keyword">string</span> <span class="comment">//字符串</span></span><br><span class="line">data  []<span class="keyword">byte</span> <span class="comment">//引用类型</span></span><br><span class="line">next  *value <span class="comment">//指针类型</span></span><br><span class="line">point        <span class="comment">//匿名字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := value&#123;</span><br><span class="line">id:    <span class="number">1</span>,</span><br><span class="line">name:  <span class="string">"jack"</span>,</span><br><span class="line">data:  []<span class="keyword">byte</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">point: point&#123;x: <span class="number">-100</span>, y: <span class="number">-10</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"v: %p ~ %x, size: %d, align: %d\n"</span>, &amp;v, <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;v))+unsafe.Sizeof(v), unsafe.Sizeof(v), unsafe.Alignof(v))</span><br><span class="line">fmt.Printf(<span class="string">"id addr: %p  offset: %d  size: %d\n"</span>, &amp;v.id, unsafe.Offsetof(v.id), unsafe.Sizeof(v.id))</span><br><span class="line">fmt.Printf(<span class="string">"name addr: %p  offset: %d  size: %d\n"</span>, &amp;v.name, unsafe.Offsetof(v.name), unsafe.Sizeof(v.name))</span><br><span class="line">fmt.Printf(<span class="string">"data addr: %p  offset: %d  size: %d\n"</span>, &amp;v.data, unsafe.Offsetof(v.data), unsafe.Sizeof(v.data))</span><br><span class="line">fmt.Printf(<span class="string">"next addr: %p  offset: %d  size: %d\n"</span>, &amp;v.next, unsafe.Offsetof(v.next), unsafe.Sizeof(v.next))</span><br><span class="line">fmt.Printf(<span class="string">"pointx addr: %p  offset: %d  size: %d\n"</span>, &amp;v.x, unsafe.Offsetof(v.x), unsafe.Sizeof(v.x))</span><br><span class="line">fmt.Printf(<span class="string">"pointy addr: %p  offset: %d  size: %d\n"</span>, &amp;v.y, unsafe.Offsetof(v.y), unsafe.Sizeof(v.y))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对齐 8</span></span><br><span class="line"><span class="comment">// v: 0xc00008c000 ~ c00008c000, size: 72, align: 8</span></span><br><span class="line"><span class="comment">// id addr: 0xc00008c000  offset: 0  size: 8</span></span><br><span class="line"><span class="comment">// name addr: 0xc00008c008  offset: 8  size: 16</span></span><br><span class="line"><span class="comment">// data addr: 0xc00008c018  offset: 24  size: 24</span></span><br><span class="line"><span class="comment">// next addr: 0xc00008c030  offset: 48  size: 8</span></span><br><span class="line"><span class="comment">// pointx addr: 0xc00008c038  offset: 56  size: 8</span></span><br><span class="line"><span class="comment">// pointy addr: 0xc00008c040  offset: 64  size: 8</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     |-------- name -------|------------- data -------------|      |------ point ------|</span><br><span class="line">+----+----------+----------+----------+----------+----------+------+---------+---------+</span><br><span class="line">| id | name.ptr | name.len | data.ptr | data.len | data.cap | next | point.x | point.y |</span><br><span class="line">+----+----------+----------+----------+----------+----------+------+---------+---------+</span><br><span class="line">0    8          16         24         32         40         48     56        64        72</span><br></pre></td></tr></table></figure><p>在分配内存时，字段须做对齐处理，通常以所有字段中最长的基础类型宽度为标准。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// v0 := struct&#123;</span></span><br><span class="line"><span class="comment">// a byte</span></span><br><span class="line"><span class="comment">// b []int //基础类型为int 对齐宽度是8</span></span><br><span class="line"><span class="comment">// c byte</span></span><br><span class="line"><span class="comment">// &#125;&#123;&#125;</span></span><br><span class="line">v1 := <span class="keyword">struct</span> &#123;</span><br><span class="line">a <span class="keyword">byte</span></span><br><span class="line">b <span class="keyword">byte</span></span><br><span class="line">c <span class="keyword">int32</span> <span class="comment">//对齐宽度4</span></span><br><span class="line">&#125;&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">16</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%d %d\n"</span>, unsafe.Alignof(v1), unsafe.Sizeof(v1))</span><br><span class="line">fmt.Printf(<span class="string">"%p,%d,%d\n"</span>, &amp;v1.a, unsafe.Offsetof(v1.a), unsafe.Sizeof(v1.a))</span><br><span class="line">fmt.Printf(<span class="string">"%p,%d,%d\n"</span>, &amp;v1.b, unsafe.Offsetof(v1.b), unsafe.Sizeof(v1.b))</span><br><span class="line">fmt.Printf(<span class="string">"%p,%d,%d\n"</span>, &amp;v1.c, unsafe.Offsetof(v1.c), unsafe.Sizeof(v1.c))</span><br><span class="line"><span class="comment">//a是1位b是1位，"xx" c 是4位 单独开启 4位 ，那么排列起来就是 xx--|xxxx 宽度是4的对齐少于4个的重新开4个</span></span><br><span class="line"><span class="comment">//假如我们换个顺序改成a、c、b 我们预测一下应该是x---|xxxx|x--- </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较特殊的是空结构类型的字段。如果它是最后一个字段，那么编译器将其当做长度为1的类型做对齐处理，以便其地址不会越界，避免引发垃圾回收错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v1 := <span class="keyword">struct</span> &#123;</span><br><span class="line">a <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">c <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">b <span class="keyword">int</span></span><br><span class="line">&#125;&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%p ~ %x, size: %d  align: %d\n"</span>, &amp;v1, <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;v1))+unsafe.Sizeof(v1), unsafe.Sizeof(v1), unsafe.Alignof(v1))</span><br><span class="line">fmt.Printf(<span class="string">"a addr: %p  offset: %d size: %d\n"</span>, &amp;v1.a, unsafe.Offsetof(v1.a), unsafe.Sizeof(v1.a))</span><br><span class="line">fmt.Printf(<span class="string">"b addr: %p  offset: %d size: %d\n"</span>, &amp;v1.b, unsafe.Offsetof(v1.b), unsafe.Sizeof(v1.b))</span><br><span class="line">fmt.Printf(<span class="string">"c addr: %p  offset: %d size: %d\n"</span>, &amp;v1.c, unsafe.Offsetof(v1.c), unsafe.Sizeof(v1.c))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0xc000092000 ~ c000092010, size: 16  align: 8</span></span><br><span class="line"><span class="comment">// a addr: 0xc000092000  offset: 0 size: 0</span></span><br><span class="line"><span class="comment">// b addr: 0xc000092000  offset: 0 size: 8</span></span><br><span class="line"><span class="comment">// c addr: 0xc000092008  offset: 8 size: 0</span></span><br><span class="line"><span class="comment">// xxxxxxxx|x------  最后一个字段长度1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;结构&quot;&gt;&lt;a href=&quot;#结构&quot; class=&quot;headerlink&quot; title=&quot;结构&quot;&gt;&lt;/a&gt;结构&lt;/h2&gt;&lt;p&gt;字段名必须唯一，可以用”_”来部位，支持使用自身指针类型成员。字段名、排列顺序属类型组成部分。除对齐处理外，编译器不会优化，调整内存布局。&lt;
      
    
    </summary>
    
    
      <category term="golang" scheme="https://devying.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://devying.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>golang map总结</title>
    <link href="https://devying.github.io/2018/03/25/golangmap/"/>
    <id>https://devying.github.io/2018/03/25/golangmap/</id>
    <published>2018-03-24T16:23:02.000Z</published>
    <updated>2019-11-21T14:58:46.057Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>作为无序键值对集合，字典要求val必须是支持相等运算符(==,!=)的数据类型，比如数字、字符串、指针、数组、结构体，以及对应接口类型。<br>访问不存在的键值，默认返回零值，不会引发错误。但是推荐使用ok-idiom模式<br>对字典进行迭代的时候每次返回的键值顺序都是不一样的。字段不支持cap。<br>因内存访问安全和哈希算法等缘故，字段被设计成”not addressable”，故不能直接修改value成员（结构或数组）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := <span class="keyword">map</span>[<span class="keyword">int</span>]user&#123;</span><br><span class="line"><span class="number">1</span>: &#123;<span class="string">"Tom"</span>, <span class="number">19</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//m[1].age++ //错误了cannot assign to struct field m[1].age in map</span></span><br><span class="line"><span class="comment">//正确的做法如下</span></span><br><span class="line">u := m[<span class="number">1</span>]</span><br><span class="line">u.age++</span><br><span class="line">m[<span class="number">1</span>] = u</span><br><span class="line">fmt.Println(m) <span class="comment">//map[1:&#123;Tom 20&#125;]</span></span><br><span class="line"><span class="comment">//或者使用指针类型</span></span><br><span class="line">m2 := <span class="keyword">map</span>[<span class="keyword">int</span>]*user&#123;</span><br><span class="line"><span class="number">1</span>: &amp;user&#123;<span class="string">"Jack"</span>, <span class="number">20</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">m2[<span class="number">1</span>].age++</span><br><span class="line">fmt.Println(m2) <span class="comment">//map[1:0xc00000c0e0]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然m[key]++ 是可以操作的，如果value支持可寻址的话，可以网上搜索golang 可寻址<br>不能对nil字典进行写操作，但是可以读。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line"><span class="built_in">println</span>(m[<span class="string">"a"</span>])<span class="comment">//返回零值</span></span><br><span class="line">m[<span class="string">"a"</span>] = <span class="number">1</span> <span class="comment">//panic: assignment to entry in nil map</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意了：内容为空的字典，与nil是不同的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> m1 <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">m2 := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="built_in">println</span>(m1 == <span class="literal">nil</span>,m2 == <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">//true false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个map不支持比较操作,只能和nil比较</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">x := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;<span class="number">1</span>: <span class="string">"a"</span>&#125;</span><br><span class="line">y := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;<span class="number">1</span>: <span class="string">"a"</span>&#125;</span><br><span class="line"><span class="built_in">println</span>(x == y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//invalid operation: x == y (map can only be compared to nil)</span></span><br></pre></td></tr></table></figure><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>在迭代期间删除或者新增键值是安全的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">m[i] = i + <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> x := <span class="keyword">range</span> m &#123;</span><br><span class="line"><span class="keyword">if</span> x == <span class="number">3</span> &#123;</span><br><span class="line">m[<span class="number">100</span>] = <span class="number">1000</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">delete</span>(m, x)</span><br><span class="line">fmt.Println(x, m)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4 map[0:100 1:101 2:102 3:103 5:105 6:106 7:107 8:108 9:109]</span></span><br><span class="line"><span class="comment">// 5 map[0:100 1:101 2:102 3:103 6:106 7:107 8:108 9:109]</span></span><br><span class="line"><span class="comment">// 6 map[0:100 1:101 2:102 3:103 7:107 8:108 9:109]</span></span><br><span class="line"><span class="comment">// 7 map[0:100 1:101 2:102 3:103 8:108 9:109]</span></span><br><span class="line"><span class="comment">// 8 map[0:100 1:101 2:102 3:103 9:109]</span></span><br><span class="line"><span class="comment">// 1 map[0:100 2:102 3:103 9:109]</span></span><br><span class="line"><span class="comment">// 3 map[0:100 2:102 9:109 100:1000]</span></span><br><span class="line"><span class="comment">// 9 map[0:100 2:102 100:1000]</span></span><br><span class="line"><span class="comment">// 0 map[2:102 100:1000]</span></span><br><span class="line"><span class="comment">// 2 map[100:1000]</span></span><br><span class="line">我们可以看到 <span class="keyword">map</span> 迭代的无序性，每次删除m的元素都会更新</span><br></pre></td></tr></table></figure><p>关于map并发操作导致的进程崩溃。(并发读、写、迭代)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"a"</span>:<span class="number">1</span>,<span class="string">"b"</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">m[<span class="string">"a"</span>] += <span class="number">1</span></span><br><span class="line">time.Sleep(time.Microsecond)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">_ = m[<span class="string">"b"</span>]</span><br><span class="line">time.Sleep(time.Microsecond)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//fatal error: concurrent map read and map write</span></span><br></pre></td></tr></table></figure><p>可以使用go run -race s.go 来检查此类问题,当然为了避免此类问题，可以使用读写互斥锁</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> lock sync.RWMutex</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">lock.Lock()</span><br><span class="line">m[<span class="string">"a"</span>] += <span class="number">1</span></span><br><span class="line">lock.Unlock()</span><br><span class="line">time.Sleep(time.Microsecond)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">lock.Lock()</span><br><span class="line">_ = m[<span class="string">"b"</span>]</span><br><span class="line">lock.Unlock()</span><br><span class="line">time.Sleep(time.Microsecond)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在创建时预先准备足够的空间有助于提升性能，减少扩张时的内存分配和重新哈希操作。对于海量小对象，应该直接用字典存储键值数据拷贝而不是指针，这样减少扫描对象的数量缩短垃圾回收时间。另外，字典不会收缩内存，适当替换新对象是有必要的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;字典&quot;&gt;&lt;a href=&quot;#字典&quot; class=&quot;headerlink&quot; title=&quot;字典&quot;&gt;&lt;/a&gt;字典&lt;/h2&gt;&lt;p&gt;作为无序键值对集合，字典要求val必须是支持相等运算符(==,!=)的数据类型，比如数字、字符串、指针、数组、结构体，以及对应接口类型。&lt;b
      
    
    </summary>
    
    
      <category term="golang" scheme="https://devying.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://devying.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>golang切片总结</title>
    <link href="https://devying.github.io/2018/03/10/golang%E5%88%87%E7%89%87/"/>
    <id>https://devying.github.io/2018/03/10/golang切片/</id>
    <published>2018-03-09T16:23:02.000Z</published>
    <updated>2019-11-17T07:11:12.812Z</updated>
    
    <content type="html"><![CDATA[<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>切片本身并非动态数组或者数组指针。它内部通过指针引用底层数组，设定相关属性将数据读写操作限定在指定区域内。<br>切片本身是个只读对象，其工作机制类似于数组指针的一种包装<br>demo:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">x := [...]int&#123;0,1,2,3,4,5,6,7,8,9&#125;</span><br><span class="line"></span><br><span class="line">expression   slice                    len   <span class="built_in">cap</span> </span><br><span class="line">-----------+------------------------+-----+-----+------------</span><br><span class="line">x[:]         [0 1 2 3 4 5 6 7 8 9]    10    10    x[0:len(x)] </span><br><span class="line">x[2:5]       [2 3 4]                  3     8</span><br><span class="line">x[2:5:7]     [2 3 4]                  3     5</span><br><span class="line">x[4:]        [4 5 6 7 8 9]            6     6     x[4:len(x)]</span><br><span class="line">x[:4]        [0 1 2 3]                4     10    x[0:4]</span><br><span class="line">x[:4:6]      [0 1 2 3]                4     6     x[0:4:6]</span><br><span class="line"></span><br><span class="line">操作如下</span><br><span class="line">            low:2       high:5  max:7                         len = high - low</span><br><span class="line">            |           |       |                             <span class="built_in">cap</span> = max  - low</span><br><span class="line">    +---+---+---+---+---+---+---+---+---+---+           +-----+---+---+</span><br><span class="line">  x | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |           | ptr |3 | 5 |  x[2:5:7]</span><br><span class="line">    +---+---+---+---+---+---+---+---+---+---+           +-----+---+---+</span><br><span class="line">            |           |       |                          |</span><br><span class="line">            |&lt;-- len --&gt;|       |                          |</span><br><span class="line">            |                   |                          |</span><br><span class="line">            |&lt;------ <span class="built_in">cap</span> ------&gt;|                          |</span><br><span class="line">            |                                              |</span><br><span class="line">            |&lt;----------------- array pointer&lt;-------------+</span><br></pre></td></tr></table></figure><p>1.cap 表示切片引用数组片段的真实长度，len用于限定可读写元素数量。另外数组必须addressable，否则会引发错误。<br>关于是否可寻址，可以参考一下<a href="https://colobu.com/2018/02/27/go-addressable/" target="_blank" rel="noopener">https://colobu.com/2018/02/27/go-addressable/</a><br>2.和数组一样，切片同样适用索引号访问元素内容。起始索引为0，而非对应的底层数组的真实索引位置。<br>3.可以直接创建切片对象，无需预先准备数组。因为是引用类型，须使用make函数或显示初始化语句，他会自动完成底层数组内存分配</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">s2 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">s3 := []<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">5</span>: <span class="number">30</span>&#125;  <span class="comment">//这个方式跟数组好像</span></span><br><span class="line">fmt.Println(s1, <span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1))</span><br><span class="line">fmt.Println(s2, <span class="built_in">len</span>(s2), <span class="built_in">cap</span>(s2))</span><br><span class="line">fmt.Println(s3, <span class="built_in">len</span>(s3), <span class="built_in">cap</span>(s3))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>] <span class="number">3</span> <span class="number">5</span></span><br><span class="line">[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>] <span class="number">3</span> <span class="number">3</span></span><br><span class="line">[<span class="number">10</span> <span class="number">20</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">30</span>] <span class="number">6</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><p>注意以下两种定义方式的区别。前者定义了一个[]int类型变量，并未执行初始化操作，而后者则用初始化表达式完成了全部创建过程。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a []<span class="keyword">int</span></span><br><span class="line">b := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="built_in">println</span>(a==<span class="literal">nil</span>,b==<span class="literal">nil</span>)</span><br><span class="line"><span class="comment">//true false</span></span><br><span class="line"><span class="comment">//可以用(*reflect.SliceHeader)(unsafe.Pointer(&amp;a))打印出来结构</span></span><br><span class="line">另外虽然a == <span class="literal">nil</span> ，切片本身依然会分配内存。可以直接对a进行slice[:]操作，同样返回<span class="literal">nil</span></span><br></pre></td></tr></table></figure><p>切片不支持比较操作，就算元素类型支持也不行，仅能判定是否为nil<br>可以获取元素的地址，但是不能像数组那样直接用指针访问元素。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">p := &amp;s</span><br><span class="line">p0 := &amp;s[<span class="number">0</span>]</span><br><span class="line">p1 := &amp;s[<span class="number">1</span>]</span><br><span class="line"><span class="built_in">println</span>(p, p0, p1)</span><br><span class="line">*p0 += <span class="number">1</span> <span class="comment">//这种操作切片和数组一样</span></span><br><span class="line">*p1 += <span class="number">100</span></span><br><span class="line">fmt.Println(s)</span><br></pre></td></tr></table></figure><p>假如元素类型也是切片，那么也就可以实现类似交错数组功能。<br>另外并不是所有的时候都适合用切片代替数组，因为切片底层数组可能会再堆上分配内存。而且小数组在栈上拷贝的消耗也未必就比make大。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">array</span><span class="params">()</span> [1024]<span class="title">int</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> x [<span class="number">1024</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i:= <span class="number">0</span>;i&lt;<span class="built_in">len</span>(x);i++&#123;</span><br><span class="line">x[i]=i</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slice</span><span class="params">()</span> []<span class="title">int</span></span>&#123;</span><br><span class="line">x := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">1024</span>)</span><br><span class="line"><span class="keyword">for</span> i:= <span class="number">0</span>;i&lt;<span class="built_in">len</span>(x);i++&#123;</span><br><span class="line">x[i]=i</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkArray</span><span class="params">(b *testing.B)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;b.N;i++&#123;</span><br><span class="line">array()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSlice</span><span class="params">(b *testing.B)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;b.N;i++&#123;</span><br><span class="line">slice()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试结果</span></span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">BenchmarkArray<span class="number">-4</span>         <span class="number">2000000</span>               <span class="number">725</span> ns/op</span><br><span class="line">BenchmarkSlice<span class="number">-4</span>         <span class="number">1000000</span>              <span class="number">1284</span> ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      command-line-arguments  <span class="number">3.490</span>s</span><br></pre></td></tr></table></figure><h3 id="reslice"><a href="#reslice" class="headerlink" title="reslice"></a>reslice</h3><p>将切片视作[cap]slice数据源，据此创建新切片对象。不能超过cap，但不受len限制。<br>s[x:y:z] x起始索引 y结束索引，但是不包含y值，z表示取s的z个容量，如果不写z则是cap(s)-x<br>否则是z-x</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+---+---+---+---+---+---+---+---+---+---+</span><br><span class="line">| 0 | 1 | 2 | 3 | 4 | 5 | 6 |   |   |   |  s            len:6,<span class="built_in">cap</span>:10</span><br><span class="line">+---+---+---+---+---+---+---+---+---+---+</span><br><span class="line">0           3                   8      10</span><br><span class="line">    </span><br><span class="line">            +---+---+---+---+---+---+---+</span><br><span class="line">            | 3 | 4 | 5 | 6 | 0 |   |   |  s1=s[3:8]    len:5,<span class="built_in">cap</span>:7</span><br><span class="line">            +---+---+---+---+---+---+---+</span><br><span class="line">            0       2       4       6</span><br><span class="line"></span><br><span class="line">                    +---+---+---+---+</span><br><span class="line">                    | 5 | 6 |   |   |      s2=s1[2:4:6] len:2,<span class="built_in">cap</span>:4</span><br><span class="line">                    +---+---+---+---+</span><br><span class="line">                    0   1</span><br><span class="line"></span><br><span class="line">                    +---+---+---+---+---+</span><br><span class="line">                    | 5 |   |   |   |   |  s3=s2[:1:5]   error:slice bounds out of range</span><br><span class="line">                    +---+---+---+---+---+</span><br></pre></td></tr></table></figure><h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><p>在两个切片对象间复制数据，允许指向同一底层数组，允许目标区间重叠。最终所复制长度以较短的切片长度为准</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">s1 := s[<span class="number">5</span>:<span class="number">8</span>]</span><br><span class="line">n := <span class="built_in">copy</span>(s[<span class="number">4</span>:], s1)  <span class="comment">//5,6,7======&gt;4--9 //在同一底层数组的不同区间复制</span></span><br><span class="line">fmt.Println(s, s1, n) <span class="comment">//[0 1 2 3 5 6 7 7 8 9] [6 7 7] 3</span></span><br><span class="line">s2 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">6</span>)</span><br><span class="line">n2 := <span class="built_in">copy</span>(s2, s)   <span class="comment">//在不同数组间复制</span></span><br><span class="line">fmt.Println(s2, n2) <span class="comment">//[0 1 2 3 5 6] 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然还可以将字符串中复制数据到[]byte</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">5</span>)</span><br><span class="line">n3 := <span class="built_in">copy</span>(b, str)</span><br><span class="line">fmt.Println(b, n3) <span class="comment">//[97 98 99 100 101] 5</span></span><br></pre></td></tr></table></figure><p>如果切片长时间引用大数组中很小的片段，那么建议单独新建独立的切片，复制出所需数据，以便原数组可以被及时回收</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;切片&quot;&gt;&lt;a href=&quot;#切片&quot; class=&quot;headerlink&quot; title=&quot;切片&quot;&gt;&lt;/a&gt;切片&lt;/h2&gt;&lt;p&gt;切片本身并非动态数组或者数组指针。它内部通过指针引用底层数组，设定相关属性将数据读写操作限定在指定区域内。&lt;br&gt;切片本身是个只读对象，其工
      
    
    </summary>
    
    
      <category term="golang" scheme="https://devying.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://devying.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>golang数组总结</title>
    <link href="https://devying.github.io/2018/02/25/golang%E6%95%B0%E7%BB%84/"/>
    <id>https://devying.github.io/2018/02/25/golang数组/</id>
    <published>2018-02-24T16:23:02.000Z</published>
    <updated>2019-11-17T06:49:37.812Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>定义数组类型时，数组长度必须是非负整数常量表达式，长度是类型组成部分。也就是说，元素类型相同，但是长度不同的数组不属于同一类型。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a [<span class="number">4</span>]<span class="built_in">int</span></span><br><span class="line">b := [<span class="number">4</span>]<span class="built_in">int</span>&#123;<span class="number">2</span>,<span class="number">5</span>&#125; <span class="comment">//未初始化的元素自动初始化为0</span></span><br><span class="line">c := [<span class="number">4</span>]<span class="built_in">int</span>&#123;<span class="number">5</span>,<span class="number">3</span>:<span class="number">10</span>&#125; <span class="comment">//可以指定索引位置初始化</span></span><br><span class="line">d := [...]<span class="built_in">int</span>&#123;<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>&#125; <span class="comment">//编译器按初始化值的数量来确定数组的长度</span></span><br><span class="line">e := [...]<span class="built_in">int</span>&#123;<span class="number">10</span>,<span class="number">5</span>:<span class="number">100</span>&#125;</span><br></pre></td></tr></table></figure><p>对于结构等复合类型，可以省略元素初始化类型标签。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line">d := [...]user&#123;</span><br><span class="line">&#123;<span class="string">"Huangby"</span>, <span class="number">30</span>&#125;,</span><br><span class="line">&#123;<span class="string">"Mi"</span>, <span class="number">20</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%#v"</span>, d)</span><br><span class="line"><span class="comment">//以上输出</span></span><br><span class="line">[<span class="number">2</span>]main.user&#123;main.user&#123;name:<span class="string">"Huangby"</span>, age:<span class="number">0x1e</span>&#125;, main.user&#123;name:<span class="string">"Mi"</span>, age:<span class="number">0x14</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>在定义多维数组时仅第一维度允许使用”…”</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">b := [...][<span class="number">3</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">&#123;<span class="number">10</span>,<span class="number">20</span>&#125;,</span><br><span class="line">&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">50</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果是 [[10 20 0] [10 20 50]]</span></span><br><span class="line">c := [...][<span class="number">3</span>][<span class="number">4</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="number">10</span>,<span class="number">12</span>,<span class="number">2</span>&#125;,</span><br><span class="line">&#123;<span class="number">6</span>,<span class="number">12</span>&#125;,</span><br><span class="line">&#123;<span class="number">100</span>&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="number">13</span>,<span class="number">2</span>:<span class="number">90</span>&#125;,</span><br><span class="line">&#123;<span class="number">6</span>&#125;,</span><br><span class="line">&#123;<span class="number">3</span>:<span class="number">33</span>&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果是 [[[10 12 2 0] [6 12 0 0] [100 0 0 0]] [[13 0 90 0] [6 0 0 0] [0 0 0 33]]]</span></span><br></pre></td></tr></table></figure><p>另外内置函数len和cap都返回的是第一维度的长度<br>如果数组的元素类型支持“==”或者“!=”操作，那么对应数组也支持。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a,b [<span class="number">2</span>]<span class="keyword">int</span></span><br><span class="line"><span class="built_in">println</span>(a==b) <span class="comment">//int支持==操作符  true</span></span><br><span class="line"></span><br><span class="line">c := [<span class="number">2</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">d := [<span class="number">2</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>&#125;</span><br><span class="line"><span class="built_in">println</span>(c==d) <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> e,f [<span class="number">2</span>]<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line"><span class="built_in">println</span>(e == f) <span class="comment">//map[string]int 不支持 == 操作符</span></span><br></pre></td></tr></table></figure><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>要分清楚指针数组和数组指针的区别，指针数是指元素为指针类型的数组，数组指针是获取数组变量的地址。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x, y := <span class="number">10</span>, <span class="number">20</span></span><br><span class="line">a := [...]*<span class="keyword">int</span>&#123;&amp;x, &amp;y&#125;</span><br><span class="line">p := &amp;a</span><br><span class="line">fmt.Printf(<span class="string">"%T,%v\n"</span>, a, a) <span class="comment">//元素为指针的指针数组</span></span><br><span class="line">fmt.Printf(<span class="string">"%T,%v\n"</span>, p, p) <span class="comment">//存储数组地址的指针</span></span><br><span class="line"><span class="comment">//以上输出</span></span><br><span class="line"><span class="comment">// [2]*int,[0xc000092000 0xc00007e008]</span></span><br><span class="line"><span class="comment">// *[2]*int,&amp;[0xc000092000 0xc00007e008]</span></span><br></pre></td></tr></table></figure><p>另外我们可以获取任何元素的地址</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line"><span class="built_in">println</span>(&amp;a,&amp;a[<span class="number">0</span>],&amp;a[<span class="number">1</span>])</span><br><span class="line"><span class="comment">//以上输出</span></span><br><span class="line"><span class="comment">//0xc000032778 0xc000032778 0xc000032780</span></span><br></pre></td></tr></table></figure><p>数组指针可以直接用来操作元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">p := &amp;a</span><br><span class="line">p[<span class="number">1</span>] += <span class="number">20</span>  <span class="comment">//直接操作元素</span></span><br><span class="line"><span class="built_in">println</span>(p[<span class="number">1</span>]) <span class="comment">//22</span></span><br><span class="line"><span class="comment">//&amp;a[0] += 100//错误 cannot assign to &amp;a[0]</span></span><br><span class="line"><span class="comment">//正确的姿势  因为都是int 也可以将unsafe去掉</span></span><br><span class="line">up := (*<span class="keyword">int</span>)(unsafe.Pointer(&amp;a[<span class="number">0</span>]))</span><br><span class="line">*up = <span class="number">100</span></span><br><span class="line"><span class="comment">//或者 up := &amp;a[0] *up += 100</span></span><br><span class="line"><span class="built_in">println</span>(a[<span class="number">0</span>], a[<span class="number">1</span>]) <span class="comment">//100 22</span></span><br></pre></td></tr></table></figure><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>与C数组变量隐式作为指针使用不同，Go数组是值类型，赋值和传参操作都会复制整个数组数据。如果需要，可改用指针或者切片，避免数据复制。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h2&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;p&gt;定义数
      
    
    </summary>
    
    
      <category term="golang" scheme="https://devying.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://devying.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>golang字符串总结</title>
    <link href="https://devying.github.io/2018/02/03/golang%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://devying.github.io/2018/02/03/golang字符串/</id>
    <published>2018-02-02T16:23:02.000Z</published>
    <updated>2019-11-17T06:49:29.511Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串是不可变字节(byte)序列,其本身是一个复合结构</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">stringStruct</span></span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="built_in">str</span> <span class="keyword">unsafe</span>.Pointer</span><br><span class="line">    len int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>头部指针指向字节数组，但没有NULL结尾。默认以UTF-8编码存储Unicode字符，字面量里允许使用十六进制、八进制和UTF编码格式。<br>内置函数len返回字节数组长度，cap不接受字符串类型参数。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">s := <span class="string">"黄abc\x61\142\u0041"</span></span><br><span class="line">println(len(s))</span><br><span class="line">println(len([]rune(s)))  <span class="comment">//先转成rune数组再计算数组长度</span></span><br><span class="line">    fmt.Println([]rune(s))</span><br><span class="line">fmt.Println([]byte(s))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line">[<span class="number">40644</span> <span class="number">97</span> <span class="number">98</span> <span class="number">99</span> <span class="number">97</span> <span class="number">98</span> <span class="number">65</span>]</span><br><span class="line">[<span class="number">233</span> <span class="number">187</span> <span class="number">132</span> <span class="number">97</span> <span class="number">98</span> <span class="number">99</span> <span class="number">97</span> <span class="number">98</span> <span class="number">65</span>]</span><br></pre></td></tr></table></figure><p>字符串默认值是””,可以使用``来处理原始字符串。<br>字符串支持“!=、==、&lt;、&gt;、+、+=”操作符，其中跨行时操作符必须在上一行结尾。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="string">"ab"</span> +</span><br><span class="line"><span class="string">"cd"</span></span><br><span class="line"><span class="built_in">println</span>(s == <span class="string">"abcd"</span>)</span><br><span class="line"><span class="built_in">println</span>(s &gt; <span class="string">"abc"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p>允许以索引号访问字节数组（非字符）,但不能获取元素地址。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">func</span> <span class="selector-tag">main</span>() &#123;</span><br><span class="line"><span class="attribute">s </span>:= <span class="string">"abcd"</span></span><br><span class="line"><span class="built_in">println</span>(s[1])</span><br><span class="line"><span class="built_in">println</span>(&amp;s[1])//错误</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">cannot</span> <span class="selector-tag">take</span> <span class="selector-tag">the</span> <span class="selector-tag">address</span> <span class="selector-tag">of</span> <span class="selector-tag">s</span><span class="selector-attr">[1]</span></span><br></pre></td></tr></table></figure><p>以切片语法返回子串时，其内部依旧指向原字节数组</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">s := <span class="string">"abcdefg"</span></span><br><span class="line">s1 := s[:<span class="number">2</span>]</span><br><span class="line">s2 := s[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">s3 := s[<span class="number">3</span>:]</span><br><span class="line">println(s1, s2, s3)</span><br><span class="line">fmt.Printf(<span class="string">"%#v"</span>, (*<span class="built_in">ref</span>lect.StringHeader)(unsafe.Pointer(&amp;s))) </span><br><span class="line">    <span class="comment">//我们先去到Go字符串的指针，它本质上是一个*reflect.StringHeader，但是Go告诉我们这是一个*string</span></span><br><span class="line">    <span class="comment">//unsafe.Pointer 用于两个不同类型的指针转换 上面这个就是将字符串指针转成*reflect.StringHeader 指针</span></span><br><span class="line">fmt.Printf(<span class="string">"%#v"</span>, (*<span class="built_in">ref</span>lect.StringHeader)(unsafe.Pointer(&amp;s1)))</span><br><span class="line">fmt.Printf(<span class="string">"%#v"</span>, (*<span class="built_in">ref</span>lect.StringHeader)(unsafe.Pointer(&amp;s2)))</span><br><span class="line">fmt.Printf(<span class="string">"%#v"</span>, (*<span class="built_in">ref</span>lect.StringHeader)(unsafe.Pointer(&amp;s3)))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">ab bcd defg</span><br><span class="line">&amp;<span class="built_in">ref</span>lect.StringHeader&#123;Data:<span class="number">0x10c8b36</span>, Len:<span class="number">7</span>&#125;</span><br><span class="line">&amp;<span class="built_in">ref</span>lect.StringHeader&#123;Data:<span class="number">0x10c8b36</span>, Len:<span class="number">2</span>&#125;</span><br><span class="line">&amp;<span class="built_in">ref</span>lect.StringHeader&#123;Data:<span class="number">0x10c8b37</span>, Len:<span class="number">3</span>&#125;</span><br><span class="line">&amp;<span class="built_in">ref</span>lect.StringHeader&#123;Data:<span class="number">0x10c8b39</span>, Len:<span class="number">4</span>&#125;</span><br><span class="line">可以看出 第一个字节地址是一样的</span><br></pre></td></tr></table></figure><p>遍历字符串两种方式结果不一样</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="string">"胡汉三"</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;          <span class="comment">//byte</span></span><br><span class="line">fmt.Printf(<span class="string">"%c\n"</span>, s[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;                  <span class="comment">//rune:返回数组索引号，以及Unicode字符</span></span><br><span class="line">fmt.Printf(<span class="string">"%c\n"</span>, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">é</span><br><span class="line">»</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ä</span><br><span class="line">¿</span><br><span class="line"></span><br><span class="line">胡</span><br><span class="line">汉</span><br><span class="line">三</span><br></pre></td></tr></table></figure><h3 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h3><p>要修改字符串，须将其转为可变类型（[ ]byte或[ ]rune）待完成后再转回来。但是不管如何转换，都需重新分配内存，并复制数据。当然有些时候这么做会拖累算法性能，可以使用“非安全”方法进行改善。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">bt := []<span class="keyword">byte</span>(<span class="string">"hello,world"</span>)</span><br><span class="line">sp := (*<span class="keyword">string</span>)(unsafe.Pointer(&amp;bt))</span><br><span class="line">fmt.Println(*sp)</span><br><span class="line">    *sp = <span class="string">"huangby"</span>    <span class="comment">//直接修改对象</span></span><br><span class="line">    fmt.Println(bt)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">hello,world</span><br><span class="line">huangby</span><br><span class="line">该方法利用了[]<span class="keyword">byte</span>和<span class="keyword">string</span>头部结构部分相同，以非安全的指针类型转换来实现类型变更。</span><br></pre></td></tr></table></figure><p>用append函数可以将string直接追加到[]byte内</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">bt := []<span class="keyword">byte</span>(<span class="string">"hello,world"</span>)</span><br><span class="line">bt = <span class="built_in">append</span>(bt, <span class="string">"@huangby"</span>...)</span><br><span class="line">fmt.Printf(<span class="string">"%s"</span>, bt)</span><br><span class="line">ru := []<span class="keyword">rune</span>(<span class="string">"你好，世界"</span>)</span><br><span class="line">ru = <span class="built_in">append</span>(ru, <span class="string">'应'</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%c"</span>, ru)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">hello,world@huangby[你 好 ， 世 界 应]</span><br><span class="line">注意了<span class="keyword">rune</span>不能像<span class="keyword">string</span>...那么使用</span><br></pre></td></tr></table></figure><p>考虑到字符串只读特征，转换时复制数据到新分配内存是可以理解的。当然，性能同样重要，编译器会为某些场合进行专门优化，避免额外分配和复制操作：</p><ul><li>将[]byte转为string key,去map[string]查询的时候</li><li>将string转为[]byte，进行for range迭代时，直接取字节赋值给局部变量。<br>GDB验证一下<br>编译的时候加上 go build -gcflags ‘-N -l’<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">GNU gdb (GDB) 8.3</span><br><span class="line">Copyright (C) 2019 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line">Type <span class="string">"show copying"</span> and <span class="string">"show warranty"</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">"x86_64-apple-darwin17.7.0"</span>.</span><br><span class="line">Type <span class="string">"show configuration"</span> <span class="keyword">for</span> configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line"></span><br><span class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">"help"</span>.</span><br><span class="line">Type <span class="string">"apropos word"</span> to search <span class="keyword">for</span> commands related to <span class="string">"word"</span>...</span><br><span class="line">Reading symbols from ./s...</span><br><span class="line">Loading Go Runtime support.</span><br><span class="line">(gdb) b 6</span><br><span class="line">Breakpoint 1 at 0x10567cb: file /Users/baoying5/go/src/basic/s.go, line 6.</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /Users/baoying5/go/src/basic/s </span><br><span class="line">[New Thread 0xc03 of process 4532]</span><br><span class="line">[New Thread 0xb03 of process 4532]</span><br><span class="line">warning: `/BuildRoot/Library/Caches/com.apple.xbs/Binaries/Libc_darwin/install/TempContent/Objects/Libc.build/libsystem_darwin.dylib.build/Objects-normal/x86_64/darwin_vers.o<span class="string">': can'</span>t open to <span class="built_in">read</span> symbols: No such file or directory.</span><br><span class="line">warning: `/BuildRoot/Library/Caches/com.apple.xbs/Binaries/Libc_darwin/install/TempContent/Objects/Libc.build/libsystem_darwin.dylib.build/Objects-normal/x86_64/dirstat.o<span class="string">': can'</span>t open to <span class="built_in">read</span> symbols: No such file or directory.</span><br><span class="line">warning: `/BuildRoot/Library/Caches/com.apple.xbs/Binaries/Libc_darwin/install/TempContent/Objects/Libc.build/libsystem_darwin.dylib.build/Objects-normal/x86_64/dirstat_collection.o<span class="string">': can'</span>t open to <span class="built_in">read</span> symbols: No such file or directory.</span><br><span class="line">warning: `/BuildRoot/Library/Caches/com.apple.xbs/Binaries/Libc_darwin/install/TempContent/Objects/Libc.build/libsystem_darwin.dylib.build/Objects-normal/x86_64/init.o<span class="string">': can'</span>t open to <span class="built_in">read</span> symbols: No such file or directory.</span><br><span class="line">warning: `/BuildRoot/Library/Caches/com.apple.xbs/Binaries/Libc_darwin/install/TempContent/Objects/Libc.build/libsystem_darwin.dylib.build/Objects-normal/x86_64/variant.o<span class="string">': can'</span>t open to <span class="built_in">read</span> symbols: No such file or directory.</span><br><span class="line">[New Thread 0x90f of process 4532]</span><br><span class="line">[New Thread 0x1503 of process 4532]</span><br><span class="line">[New Thread 0x1603 of process 4532]</span><br><span class="line">[New Thread 0x2903 of process 4532]</span><br><span class="line"></span><br><span class="line">Thread 2 hit Breakpoint 1, main.main () at /Users/baoying5/go/src/basic/s.go:6</span><br><span class="line">warning: Source file is more recent than executable.</span><br><span class="line">6               //s := string(key)</span><br><span class="line">(gdb) info locals</span><br><span class="line">ok = <span class="literal">false</span></span><br><span class="line">x = 18550296</span><br><span class="line">m = map[string]int = &#123;[0x1075b17 <span class="string">"abc"</span>] = 123&#125;</span><br><span class="line">key = &#123;array = 0xc00003261d <span class="string">"abc\030\016\033\001"</span>, len = 3, <span class="built_in">cap</span> = 3&#125;</span><br><span class="line">(gdb) s</span><br><span class="line">runtime.mapaccess2_faststr (t=0x10649c0 &lt;<span class="built_in">type</span>.*+57568&gt;, h=0xc000032688, ky=..., ~r3=&lt;optimized out&gt;, ~r4=&lt;optimized out&gt;)</span><br><span class="line">    at /usr/<span class="built_in">local</span>/go/src/runtime/map_faststr.go:107</span><br><span class="line">107     func mapaccess2_faststr(t *maptype, h *hmap, ky string) (unsafe.Pointer, bool) &#123;</span><br><span class="line">(gdb) info args</span><br><span class="line">t = 0x10649c0 &lt;<span class="built_in">type</span>.*+57568&gt;</span><br><span class="line">h = 0xc000032688</span><br><span class="line">ky = &lt;optimized out&gt;</span><br><span class="line">~r3 = &lt;optimized out&gt;</span><br><span class="line">~r4 = &lt;optimized out&gt;</span><br><span class="line">(gdb) x/3xw ky</span><br><span class="line">value has been optimized out</span><br><span class="line">(gdb) s</span><br><span class="line">112             <span class="keyword">if</span> h == nil || h.count == 0 &#123;</span><br><span class="line">(gdb) s</span><br><span class="line">115             <span class="keyword">if</span> h.flags&amp;hashWriting != 0 &#123;</span><br><span class="line">(gdb) s</span><br><span class="line">118             key := stringStructOf(&amp;ky)</span><br><span class="line">(gdb) x/3xw key</span><br><span class="line">value has been optimized out</span><br><span class="line">(gdb) x/3xw &amp;key</span><br><span class="line">Can<span class="string">'t take address of "key" which isn'</span>t an lvalue.</span><br><span class="line">(gdb) s</span><br><span class="line">runtime.stringStructOf (sp=0xc0000325f8, ~r1=&lt;optimized out&gt;) at /usr/<span class="built_in">local</span>/go/src/runtime/string.go:230</span><br><span class="line">230             <span class="built_in">return</span> (*stringStruct)(unsafe.Pointer(sp))</span><br><span class="line">(gdb) x/3xw key</span><br><span class="line">No symbol <span class="string">"key"</span> <span class="keyword">in</span> current context.</span><br><span class="line">(gdb) x/3xw &amp;key</span><br><span class="line">No symbol <span class="string">"key"</span> <span class="keyword">in</span> current context.</span><br><span class="line">(gdb) s</span><br><span class="line">runtime.mapaccess2_faststr (t=0x10649c0 &lt;<span class="built_in">type</span>.*+57568&gt;, h=0xc000032688, ky=..., ~r3=&lt;optimized out&gt;, ~r4=&lt;optimized out&gt;)</span><br><span class="line">    at /usr/<span class="built_in">local</span>/go/src/runtime/map_faststr.go:119</span><br><span class="line">119             <span class="keyword">if</span> h.B == 0 &#123;</span><br><span class="line">(gdb) x/3xw key</span><br><span class="line">0xc0000325f8:   0x0003261d      0x000000c0      0x00000003</span><br><span class="line">(gdb) s</span><br><span class="line">121                     b := (*bmap)(h.buckets)</span><br><span class="line">(gdb) s</span><br><span class="line">122                     <span class="keyword">if</span> key.len &lt; 32 &#123;</span><br><span class="line">(gdb) s</span><br><span class="line">124                             <span class="keyword">for</span> i, kptr := uintptr(0), b.keys(); i &lt; bucketCnt; i, kptr = i+1, add(kptr, 2*sys.PtrSize) &#123;</span><br><span class="line">(gdb) x/3xw key</span><br><span class="line">0xc0000325f8:   0x0003261d      0x000000c0      0x00000003</span><br><span class="line">(gdb) </span><br><span class="line"></span><br><span class="line">可以看到 地址 0x0003261d 说明这里是直接修改的地址</span><br></pre></td></tr></table></figure><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3>除类型转换外，动态构建字符串也容易造成性能问题<br>用加法操作字符拼接字符串时，每次都需要重写分配内存。如此，在构建超大字符串时性能就特别差。<br>可以用<code>strings.Join</code> 或者 <code>bytes.Buffer</code><br>对于数量较少的字符串格式化拼接可以用fmt.Sprintf、text/template等方法<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> a <span class="built_in">bytes</span>.Buffer</span><br><span class="line">a.Grow(<span class="number">100</span>)</span><br><span class="line">for i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">a.WriteByte(<span class="string">'c'</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(a.<span class="built_in">String</span>())</span><br></pre></td></tr></table></figure><h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3>类型rune专门用来存储Unicode码点，他是int32的别名，相当于UCS-4、UTF-32编码格式。使用单引号的字面量，其默认类型就是rune。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := <span class="string">'黄'</span></span><br><span class="line">fmt.Printf(<span class="string">"type : %T"</span>, r)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//type : int32</span></span><br></pre></td></tr></table></figure>除了[]rune 外（即不能[]rune()这样转一个字符串），还可以再rune/byte/string间进行转换,<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">r := <span class="string">'黄'</span></span><br><span class="line">fmt.Printf(<span class="string">"type : %T\n"</span>, r)</span><br><span class="line">s := <span class="keyword">string</span>(r)</span><br><span class="line">b := <span class="keyword">byte</span>(r)</span><br><span class="line"></span><br><span class="line">s2 := <span class="keyword">string</span>(b)</span><br><span class="line">r2 := <span class="keyword">rune</span>(b)</span><br><span class="line">fmt.Println(r, s, b, s2, r2)</span><br><span class="line"><span class="comment">//40644 黄 196 Ä 196</span></span><br></pre></td></tr></table></figure>字符串存储的字节数组，不一定就是合法的UTF-8文本<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">str</span> := <span class="string">"胡汉三"</span></span><br><span class="line">stt := <span class="keyword">str</span>[:<span class="number">1</span>] + <span class="keyword">str</span>[<span class="number">3</span>:<span class="number">4</span>]</span><br><span class="line">fmt.Println(stt) <span class="comment">//��</span></span><br><span class="line">fmt.Println(utf8.ValidString(stt))</span><br><span class="line"><span class="comment">//以上输出</span></span><br><span class="line">��</span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure>当然我们用unicode库下面的一些函数，可以统计Unicode字符数量,另外官方扩展库还有提供对BOM支持的。<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">str</span> := <span class="string">"胡汉三abc"</span></span><br><span class="line">fmt.Println(len(<span class="keyword">str</span>), utf8.RuneCountInString(<span class="keyword">str</span>))</span><br><span class="line"><span class="comment">//以上输出</span></span><br><span class="line"><span class="number">12</span> <span class="number">6</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;字符串&quot;&gt;&lt;a href=&quot;#字符串&quot; class=&quot;headerlink&quot; title=&quot;字符串&quot;&gt;&lt;/a&gt;字符串&lt;/h2&gt;&lt;p&gt;字符串是不可变字节(byte)序列,其本身是一个复合结构&lt;/p&gt;
&lt;figure class=&quot;highlight rust&quot;&gt;&lt;t
      
    
    </summary>
    
    
      <category term="golang" scheme="https://devying.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://devying.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>golang数据类型总结</title>
    <link href="https://devying.github.io/2018/01/13/golang%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/"/>
    <id>https://devying.github.io/2018/01/13/golang数据类型总结/</id>
    <published>2018-01-12T16:23:02.000Z</published>
    <updated>2019-11-17T06:48:30.871Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><table><thead><tr><th>类型</th><th>长度</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>bool</td><td>1</td><td>false</td><td></td></tr><tr><td>byte</td><td>1</td><td>0</td><td>uint8</td></tr><tr><td>rune</td><td>4</td><td>0</td><td>Unicode Code Point, int32</td></tr><tr><td>int, uint</td><td>4或8</td><td>0</td><td>32 或 64 位</td></tr><tr><td>int8, uint8</td><td>1</td><td>0</td><td>-128 ~ 127, 0 ~ 255</td></tr><tr><td>int16, uint16</td><td>2</td><td>0</td><td>-32768 ~ 32767, 0 ~ 65535</td></tr><tr><td>int32, uint32</td><td>4</td><td>0</td><td>-21亿~ 21亿, 0 ~ 42亿</td></tr><tr><td>int64, uint64</td><td>8</td><td>0</td><td></td></tr><tr><td>float32</td><td>4</td><td>0.0</td><td></td></tr><tr><td>float64</td><td>8</td><td>0.0</td><td></td></tr><tr><td>complex64</td><td>8</td><td></td><td></td></tr><tr><td>complex128</td><td>16</td><td></td><td></td></tr><tr><td>uintptr</td><td>4或8</td><td></td><td>⾜足以存储指针的 uint32 或 uint64整数</td></tr><tr><td>array</td><td></td><td></td><td>值类型</td></tr><tr><td>struct</td><td></td><td></td><td>值类型</td></tr><tr><td>string</td><td></td><td>“”</td><td>UTF-8 字符串</td></tr><tr><td>slice</td><td></td><td>nil</td><td>引⽤用类型</td></tr><tr><td>map</td><td></td><td>nil</td><td>引⽤用类型</td></tr><tr><td>channel</td><td></td><td>nil</td><td>引⽤用类型</td></tr><tr><td>interface</td><td></td><td>nil</td><td>接⼝</td></tr><tr><td>function</td><td></td><td>nil</td><td>函数</td></tr></tbody></table><p>支持八进制，十六进制以及科学计数法</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span>,<span class="selector-tag">b</span>,c := <span class="number">100</span>,<span class="number">0144</span>,<span class="number">0</span>x64</span><br><span class="line">fmt.Println(<span class="selector-tag">a</span>,<span class="selector-tag">b</span>,c)  <span class="comment">//100,100,100</span></span><br><span class="line">fmt.Printf(<span class="string">"0b%b,%#o,%#x"</span>,<span class="selector-tag">a</span>,<span class="selector-tag">b</span>,c)<span class="comment">//0b1100100,0144,0x64</span></span><br><span class="line">fmt.Prinln(math<span class="selector-class">.MaxInt8</span>,math,MinInt8)<span class="comment">//127,-128</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//进制转换到十进制</span></span><br><span class="line"><span class="selector-tag">a</span>,_ := strconv.ParseInt(<span class="string">"1100100"</span>,<span class="number">2</span>,<span class="number">32</span>)  <span class="comment">//100</span></span><br><span class="line"><span class="selector-tag">b</span>,_ := strconv.ParseInt(<span class="string">"0144"</span>,<span class="number">8</span>,<span class="number">32</span>)     <span class="comment">//100</span></span><br><span class="line">c,_ := strconv.ParseInt(<span class="string">"0x64"</span>,<span class="number">16</span>,<span class="number">32</span>)    <span class="comment">//100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//十进制转到其他进制</span></span><br><span class="line">strconv.FormatInt(<span class="selector-tag">a</span>,<span class="number">2</span>)  <span class="comment">//1100100</span></span><br><span class="line">strconv.FormatInt(<span class="selector-tag">a</span>,<span class="number">8</span>)  <span class="comment">//144</span></span><br><span class="line">strconv.FormatInt(<span class="selector-tag">a</span>,<span class="number">16</span>) <span class="comment">//64</span></span><br></pre></td></tr></table></figure><p>注意浮点数 默认浮点类型是<code>float64</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a float32 = <span class="number">1.123456789</span></span><br><span class="line"><span class="keyword">var</span> b float32 = <span class="number">1.123456781</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">c</span> float32 = <span class="number">1.12345678</span></span><br><span class="line"><span class="built_in">println</span>(a, b, <span class="built_in">c</span>)</span><br><span class="line"><span class="built_in">println</span>(a == b, b == <span class="built_in">c</span>, a == <span class="built_in">c</span>)</span><br><span class="line">fmt.<span class="type">Printf</span>(<span class="string">"%v,%v,%v"</span>, a, b, <span class="built_in">c</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+<span class="number">1.123457e</span>+<span class="number">000</span> +<span class="number">1.123457e</span>+<span class="number">000</span> +<span class="number">1.123457e</span>+<span class="number">000</span></span><br><span class="line"><span class="literal">true</span> <span class="literal">true</span> <span class="literal">true</span></span><br><span class="line"><span class="number">1.1234568</span>,<span class="number">1.1234568</span>,<span class="number">1.1234568</span></span><br></pre></td></tr></table></figure><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>byte 是 uint8 别名<br>rune 是 int32 别名<br>别名类型不需要转换可以直接赋值，比如下面这样没有问题。但是注意了，就算你在32操作系统上int 并不等于int32，在64位系统上int 并不等于int64</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">byte</span> = <span class="number">0x11</span></span><br><span class="line"><span class="keyword">var</span> y <span class="keyword">uint8</span> = x</span><br><span class="line"><span class="keyword">var</span> z <span class="keyword">uint8</span> = x + y</span><br><span class="line">test(z)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(x <span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>特指slice，map，chan 这三类<br>内置函数new按指定类型长度分配零值内存，返回指针，并不关心类型内部构造和初始化方式，而引用类型必须要使用make来创建，编译器会将make转为目标类型专用的创建函数（或指令），以确保全部内存分配和相关属性初始化。</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>不⽀支持隐式类型转换</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="number">10</span></span><br><span class="line">b := <span class="keyword">byte</span>(a)</span><br><span class="line">c := a + <span class="keyword">int</span>(b) <span class="comment">//混合表达式 必须保持类型一致，a自动推断为</span></span><br><span class="line"><span class="keyword">int</span> 所以a + 后面的也必须是<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> n <span class="keyword">int</span> = <span class="keyword">int</span>(b) <span class="comment">// 显式转换</span></span><br><span class="line"><span class="built_in">println</span>(a, b, c) <span class="comment">//10，10，20</span></span><br><span class="line"></span><br><span class="line">d := <span class="keyword">bool</span>(a) <span class="comment">//这里就有问题了</span></span><br></pre></td></tr></table></figure><p>如果转换的目标是<code>指针</code>，<code>单向通道</code>或者是<code>没有返回值的函数</code>,必须要使用括号。避免造成语法分析错误</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d := (*<span class="keyword">int</span>)(&amp;a)   <span class="comment">//0xc000032780</span></span><br><span class="line">e := (&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)(ch)</span><br><span class="line">f := (<span class="function"><span class="keyword">func</span><span class="params">()</span>)<span class="params">(x)</span></span></span><br><span class="line">g := <span class="function"><span class="keyword">func</span><span class="params">()</span><span class="title">int</span><span class="params">(x)</span> //有返回值的可以省略括号</span></span><br></pre></td></tr></table></figure><h2 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h2><p>使用关键字<code>type</code>定义，包括基于现有基础类型创建或者是结构体、函数类型等。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> flag <span class="keyword">byte</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">read flag = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span></span><br><span class="line">write</span><br><span class="line">exec</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">f := read | exec</span><br><span class="line">fmt.Printf(<span class="string">"%b\n"</span>,f)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//101</span></span><br></pre></td></tr></table></figure><p>和var 、const 类似，多个type定义可以合并成组，可以在函数或者代码块内定义局部类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">user <span class="keyword">struct</span> &#123;             <span class="comment">//结构体类型</span></span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age <span class="keyword">uint8</span></span><br><span class="line">&#125;</span><br><span class="line">event <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>)</span> <span class="title">bool</span>   //函数类型</span></span><br><span class="line">)</span><br><span class="line">u := user&#123;<span class="string">"huangby"</span>,<span class="number">30</span>&#125;</span><br><span class="line">fmt.Println(u)</span><br><span class="line"><span class="keyword">var</span> f event = <span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(s)</span><br><span class="line"><span class="keyword">return</span> s !=<span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line">f(<span class="string">"huangby"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="未命名类型"><a href="#未命名类型" class="headerlink" title="未命名类型"></a>未命名类型</h2><p>与有明确标识符的 bool、int、string 等类型相比，数组、切片、字典、通道等类型与具体类型的长度等属性有关，故称作为命了类型。<br>具有相同声明的未命名类型被视作同一类型。</p><ul><li>具有相同基类型的指针。</li><li>具有相同元素类型和长度的数组 array</li><li>具有相同元素类型的切片 slice</li><li>具有相同键值类型的字典  map</li><li>具有相同数据类型以及操作方向的通道 channel</li><li>具有相同字段序列（字段名、字段类型、标签、字段顺序）的结构体 struct</li><li>具有相同签名(参数和返回值，不包括参数名)的函数 func</li><li>具有相同方法集（方法名，方法签名）的接口 interface{}</li></ul><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>不能将内存地址与指针混为一谈<br>内存地址是内存中每个字节单元的唯一编号，指针则是一个实体。指针会分配内存空间，相当于一个专门用来保存地址的整形变量。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">             p := &amp;x             x:=100</span><br><span class="line"><span class="params">------------</span>|<span class="params">-------</span>|<span class="params">----</span>\\<span class="params">----</span>|<span class="params">---------</span>|<span class="params">-----</span></span><br><span class="line">memory.<span class="string">..</span>   |0x1200 |   ····   | 100     |</span><br><span class="line"><span class="params">------------</span>|<span class="params">-------</span>|<span class="params">----</span>\\<span class="params">----</span>|<span class="params">---------</span>|<span class="params">-----</span></span><br><span class="line">addr         0x80              0x1200 </span><br><span class="line"><span class="params">-----------------------------------------------</span></span><br></pre></td></tr></table></figure><ul><li><code>&amp;</code>符号用来获取对象地址</li><li>指针运算符<code>*</code>用于间接引用目标对象</li><li>二级指针 ** T,如包含包名则写成*package T</li></ul><p>并非所有的对象都能进行取地址操作，但变量总是能正确返回。指针运算符为左值时(*a = 20)，可以更新目标对象状态，而为右值时(a := *b)，则是为了获取目标状态。<br>指针支持相等运算，单不支持加减法和类型转换。</p><p>可以通过unsafe.Pointer将指针转换为 uintptr 后加减运算，但可能会造成非法访问。</p><p>Pointer类似于C中的void* 万能指针，可以用来转换指针类型。它能安全持有对象或对象成员，但是 uintptr 不行。uintptr 仅是一种特殊整形，并不引用目标对象，无法阻止垃圾回收器回收对象内存。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">a</span>,<span class="selector-tag">b</span>  struct&#123;&#125;</span><br><span class="line"><span class="function"><span class="title">println</span><span class="params">(&amp;a,&amp;b)</span></span>           <span class="comment">//都是0x---------</span></span><br><span class="line"><span class="function"><span class="title">println</span><span class="params">(&amp;a==&amp;b ,&amp;a==nil)</span></span> <span class="comment">//第一个不一定true  但是第二个肯定false</span></span><br></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>对复合类型（数组，切片，字典，结构体）变量初始化时，有一些语法限制。</p><ul><li>初始化表达式必须含有类型标签</li><li>左花括号必须在类型尾部，不能另起一行</li><li>多个成员初始值以逗号分隔</li><li>允许多行，但是每行必须以逗号或者右花括号结束。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span>&#123;</span><br><span class="line">x <span class="keyword">int</span></span><br><span class="line">s <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a data = data&#123;<span class="number">1</span>,<span class="string">"abc"</span>&#125;</span><br><span class="line">b := data&#123;<span class="number">2</span>,<span class="string">"def"</span>&#125;</span><br><span class="line">c := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"name"</span>:<span class="string">"huangby"</span>,<span class="string">"addr"</span>:<span class="string">"beijing"</span>&#125;</span><br><span class="line">d := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"name"</span>: <span class="string">"huangby"</span>, <span class="string">"addr"</span>: <span class="string">"beijing"</span>&#125;</span><br><span class="line">d[<span class="string">"a"</span>] = <span class="string">"acd"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//但是</span></span><br><span class="line"><span class="keyword">var</span> d <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">d[<span class="string">"a"</span>] = <span class="string">"acd"</span> 这就不行了</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本类型&quot;&gt;&lt;a href=&quot;#基本类型&quot; class=&quot;headerlink&quot; title=&quot;基本类型&quot;&gt;&lt;/a&gt;基本类型&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;长度&lt;/th&gt;
&lt;th&gt;默认值&lt;/th&gt;
&lt;th&gt;说明&lt;
      
    
    </summary>
    
    
      <category term="golang" scheme="https://devying.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://devying.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>golang变量和常量总结</title>
    <link href="https://devying.github.io/2018/01/01/golang%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/"/>
    <id>https://devying.github.io/2018/01/01/golang变量和常量/</id>
    <published>2017-12-31T16:23:02.000Z</published>
    <updated>2019-11-17T06:49:35.910Z</updated>
    
    <content type="html"><![CDATA[<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>Go变量总是有固定的数据类型，类型决定了变量内存的长度和存储格式。我们只能修改变量值，无法改变类型。</p><p><strong>通过类型转换或者指针操作，我们可以用不同方式修改变量值，但是这并不意味着改变了变量类型。</strong></p><h3 id="关键字var"><a href="#关键字var" class="headerlink" title="关键字var"></a>关键字var</h3><p>可以用于定义变量，运行时内存分配操作会确保变量自动初始化为二进制零值，避免出现不可预测行为。如果显式提供初始化值，可以省略变量类型，由编译器推断。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">int</span>   <span class="comment">//自动初始化为 0</span></span><br><span class="line"><span class="keyword">var</span> y = <span class="literal">false</span> <span class="comment">//自动推断为bool类型</span></span><br><span class="line"><span class="keyword">var</span> z <span class="keyword">int</span> = <span class="number">0</span> <span class="comment">//可以省略int</span></span><br></pre></td></tr></table></figure><p>一次性定义多个变量</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keywords">var</span> <span class="symbol">x</span>,<span class="symbol">y</span> int <span class="comment">//相同类型的多个变量</span></span><br><span class="line"><span class="keywords">var</span> a,s = <span class="number">100</span>, <span class="string">"abc"</span> <span class="comment">//不同类型初始化值</span></span><br></pre></td></tr></table></figure><p>按照惯例，以组的方式整理多行变量定义。</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keywords">var</span> (</span><br><span class="line">    <span class="symbol">x</span>, <span class="symbol">y</span> int</span><br><span class="line">    a, s = <span class="number">300</span>, <span class="string">"abc"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="简短模式"><a href="#简短模式" class="headerlink" title="简短模式"></a>简短模式</h3><p>除了var 关键字还可以用更简短的变量定义和初始化语法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x := <span class="number">100</span></span><br><span class="line">a,s := <span class="number">1</span>, <span class="string">"abc"</span></span><br></pre></td></tr></table></figure><p>简短模式有一些限制：</p><ul><li>定义变量，同时显式初始化</li><li>不能提供数据类型</li><li>只能用在函数内部</li></ul><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keywords">var</span> <span class="symbol">x</span> = <span class="number">100</span> <span class="comment">//全局变量</span></span><br><span class="line">func main()&#123;</span><br><span class="line">    fmt.Println(&amp;<span class="symbol">x</span>,<span class="symbol">x</span>)</span><br><span class="line">    <span class="symbol">x</span>:=<span class="string">"abc"</span> <span class="comment">//重新定义和初始化同名局部变量，局部有效</span></span><br><span class="line">    fmt.Println(&amp;<span class="symbol">x</span>,<span class="symbol">x</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">以上程序运行结果：</span><br><span class="line">两个&amp;<span class="symbol">x</span> 内存地址不一样，<span class="symbol">x</span>值也不一样，可以看出是两个不同的变量</span><br></pre></td></tr></table></figure><p><strong>简短模式在函数多值返回，以及if/for/switch等语句中定义局部变量非常方便</strong></p><p>简短模式并不总是重新定义变量的，还有可能是部分退化的赋值操作。另外退化赋值的前提条件是至少有一个新变量被定义，且在同一作用域。常见在函数返回err时，始终重复使用err变量</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func main()&#123;</span><br><span class="line">    <span class="symbol">x</span> := <span class="number">100</span></span><br><span class="line">    fmt.Println(&amp;<span class="symbol">x</span>)</span><br><span class="line">    <span class="symbol">x</span>, <span class="symbol">y</span> := <span class="number">20</span>,<span class="string">"abc"</span> <span class="comment">//</span></span><br><span class="line">    fmt.Println(&amp;<span class="symbol">x</span>,<span class="symbol">x</span>,<span class="symbol">y</span>)<span class="comment">//&amp;x是同一个 x这是退化赋值</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="symbol">x</span>,<span class="symbol">y</span> := <span class="number">12</span>,<span class="number">12</span> <span class="comment">//作用域不同，这里都是重新定义变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="未使用错误"><a href="#未使用错误" class="headerlink" title="未使用错误"></a>未使用错误</h3><p>编译的时候未使用的局部变量会报错，而全局变量不会。</p><h3 id="空标识符"><a href="#空标识符" class="headerlink" title="空标识符_"></a>空标识符_</h3><p>空标识符可临时用来规避编译器对未使用的变量或包的错误检查，但是请注意它是预置成员，不能重新定义。</p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量表示运行时恒定不可改变的值，通常是一些字面量。<br>常量必须是编译期可确定的<code>字符</code>、<code>字符串</code>、<code>数字</code>、<code>布尔值</code>，可指定常量类型或者由编译器通过初始化推断。不曾使用的常量不会编译报错。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x,y <span class="built_in">int</span> = <span class="number">123</span>,<span class="number">0x22</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="string">"hello"</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="string">'哈'</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    i,f = <span class="number">123</span>,<span class="number">2.3</span> <span class="comment">//int，float64(默认)</span></span><br><span class="line">    b = <span class="literal">false</span></span><br><span class="line">)</span><br><span class="line">func main()&#123;</span><br><span class="line">    <span class="keyword">const</span> s = <span class="number">45</span> <span class="comment">//可以在不同作用域定义同名常量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以是编译器可以计算出来的表达式(比如unsafe.Sizeof，cap,len等)，范围必须要正确</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    x, y = <span class="number">99</span>, <span class="number">-999</span></span><br><span class="line">    b byte = byte(<span class="name">x</span>) //b 是byte类型，必须显式的将x转为byte</span><br><span class="line">    n  = uint8(<span class="name">y</span>)  //错误范围溢出 </span><br><span class="line"></span><br><span class="line">    ptrSize = unsafe.Sizeof(<span class="name">uintptr</span>(<span class="number">0</span>))</span><br><span class="line">    strSize = len(<span class="string">"hello"</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在常量组中，如不指定类型和初始化值，则与上一行非空常量右值相同</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    x <span class="built_in">uint</span>16 = <span class="number">120</span> </span><br><span class="line">    y                <span class="comment">//与上一行x  右值、类型相同</span></span><br><span class="line">    s = <span class="string">"abc"</span></span><br><span class="line">    z                <span class="comment">//与上一行s  右值、类型相同</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>Go没有明确意义上的enum定义，但是可以借助<code>iota</code>标识符实现一组自增常量值，来实现枚举类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    x = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">    y        <span class="comment">//1</span></span><br><span class="line">    z        <span class="comment">//2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    _  = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">    KB =  <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)     <span class="comment">// 1 &lt;&lt; (10 * 1)</span></span><br><span class="line">    MB                         <span class="comment">// 1 &lt;&lt; (10 * 2)</span></span><br><span class="line">    GB                         <span class="comment">// 1 &lt;&lt; (10 * 3)</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>自增作用范围为常量组。可以在多常量定义中使用多个iota，它们各自单独计数，只需要确保组中每行常量个数相同即可</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">const</span> <span class="string">(</span></span><br><span class="line">    <span class="string">_,</span> <span class="string">_</span> <span class="string">=</span> <span class="string">iota</span> <span class="string">,iota</span> <span class="string">*</span> <span class="number">10</span>     <span class="string">//</span> <span class="number">0</span><span class="string">,</span> <span class="number">0</span> <span class="string">*</span> <span class="number">10</span></span><br><span class="line">    <span class="string">a,</span> <span class="string">b</span>                       <span class="string">//</span> <span class="number">1</span><span class="string">,</span> <span class="number">1</span> <span class="string">*</span> <span class="number">10</span></span><br><span class="line">    <span class="string">c,</span> <span class="string">d</span>                       <span class="string">//</span> <span class="number">2</span><span class="string">,</span> <span class="number">2</span> <span class="string">*</span> <span class="number">10</span></span><br><span class="line"><span class="string">)</span></span><br></pre></td></tr></table></figure><p>如果中断iota自增，必须显式恢复，切后续自增值按行序递增。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a  = <span class="literal">iota</span>     <span class="comment">//0</span></span><br><span class="line">    b             <span class="comment">//1</span></span><br><span class="line">    c  = <span class="number">100</span>      <span class="comment">//100</span></span><br><span class="line">    d             <span class="comment">//100 与上一行保持一致</span></span><br><span class="line">    e  = <span class="literal">iota</span>     <span class="comment">//4 恢复iota,行序递增</span></span><br><span class="line">    f             <span class="comment">//5</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>自增默认类型为int,当然你可以显示的指定类型</p><h3 id="常量和变量区别"><a href="#常量和变量区别" class="headerlink" title="常量和变量区别"></a>常量和变量区别</h3><p>常量是只读，不能取地址。数字常量不会分配存储空间，无需像变量那要通过内存寻址来取值，因此无法获取地址。<br>变量在运行期分配存储内存（非优化状态）常量通常会被编译器在预处理阶段直接展开，作为指令数据使用。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="number">100</span>      <span class="comment">//无类型声明的常量</span></span><br><span class="line"><span class="keyword">const</span> y byte = x   <span class="comment">//直接展开x,相当于const y byte = 100</span></span><br><span class="line"><span class="keyword">const</span> a <span class="built_in">int</span> = <span class="number">100</span>  <span class="comment">//显式指定常量类型，编译器会做强类型检查</span></span><br><span class="line"><span class="keyword">const</span> b byte = a   <span class="comment">//错误，can not use a （type int）as type byte in const initializer</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;变量&quot;&gt;&lt;a href=&quot;#变量&quot; class=&quot;headerlink&quot; title=&quot;变量&quot;&gt;&lt;/a&gt;变量&lt;/h2&gt;&lt;p&gt;Go变量总是有固定的数据类型，类型决定了变量内存的长度和存储格式。我们只能修改变量值，无法改变类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通过类型
      
    
    </summary>
    
    
      <category term="golang" scheme="https://devying.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://devying.github.io/tags/golang/"/>
    
  </entry>
  
</feed>

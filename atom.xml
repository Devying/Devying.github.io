<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>熠熙轻雷</title>
  
  <subtitle>blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://devying.github.io/"/>
  <updated>2019-11-17T07:13:20.001Z</updated>
  <id>https://devying.github.io/</id>
  
  <author>
    <name>Devying</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>golang 结构体总结</title>
    <link href="https://devying.github.io/2018/04/19/golang%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <id>https://devying.github.io/2018/04/19/golang结构体/</id>
    <published>2018-04-18T16:23:02.000Z</published>
    <updated>2019-11-17T07:13:20.001Z</updated>
    
    <content type="html"><![CDATA[<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>字段名必须唯一，可以用”_”来部位，支持使用自身指针类型成员。字段名、排列顺序属类型组成部分。除对齐处理外，编译器不会优化，调整内存布局。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">_    <span class="keyword">int</span></span><br><span class="line">id   <span class="keyword">int</span></span><br><span class="line">next *node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">n1 := node&#123;</span><br><span class="line">id: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line">n2 := node&#123;</span><br><span class="line">id:   <span class="number">2</span>,</span><br><span class="line">next: &amp;n1,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(n1, n2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//&#123;0 1 &lt;nil&gt;&#125; &#123;0 2 0xc00006e020&#125;</span></span><br></pre></td></tr></table></figure><p>只有在所有字段类型全部时，才可以做相等操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">d1 := data&#123;</span><br><span class="line">x: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line">d2 := data&#123;</span><br><span class="line">x: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(d1 == d2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//invalid operation: d1 == d2 (struct containing map[string]int cannot be compared)</span></span><br></pre></td></tr></table></figure><p>可以使用指针直接操作结构字段，但不能是多级指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p := &amp;user&#123;</span><br><span class="line">name: <span class="string">"TOM"</span>,</span><br><span class="line">age:  <span class="number">22</span>,</span><br><span class="line">&#125;</span><br><span class="line">p.name = <span class="string">"TAE"</span></span><br><span class="line">p.age++</span><br><span class="line">p2 := &amp;p</span><br><span class="line">fmt.Println(p, *p2)</span><br><span class="line">(*p2).name = <span class="string">"Jack"</span></span><br><span class="line">fmt.Println((*p2).name)</span><br><span class="line">fmt.Println((*p2).age)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &amp;&#123;TAE 23&#125; &amp;&#123;TAE 23&#125;</span></span><br><span class="line"><span class="comment">// Jack</span></span><br><span class="line"><span class="comment">// 23</span></span><br></pre></td></tr></table></figure><h3 id="空结构"><a href="#空结构" class="headerlink" title="空结构"></a>空结构</h3><p>空结构是指没有字段的结构类型，它比较特殊，因为无论是其自身，还是作为数组元素类型，其长度都是0,<br>但是尽管没有分配数组内存，但依然可以操作元素，对应切片len、cap属性也正常。<br>实际上这类”长度”为零的对象通常都指向runtime.zerobase变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> b [<span class="number">100</span>]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> d [<span class="number">100</span>]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="built_in">println</span>(unsafe.Sizeof(a), unsafe.Sizeof(b))</span><br><span class="line">s := d[:]</span><br><span class="line">d[<span class="number">1</span>] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">s[<span class="number">2</span>] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">fmt.Println(s[<span class="number">3</span>], <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">s1 := [<span class="number">10</span>]<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">s2 := s1[:]</span><br><span class="line">s3 := [<span class="number">0</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%p,%p,%p"</span>, &amp;s1, &amp;s2[<span class="number">0</span>], &amp;s3)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//0 0</span></span><br><span class="line"><span class="comment">//&#123;&#125; 100 100</span></span><br><span class="line"><span class="comment">//0x118efd0,0x118efd0,0x118efd0</span></span><br></pre></td></tr></table></figure><p>空结构可以用作通道元素类型，用于事件通知。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&lt;-ch</span><br></pre></td></tr></table></figure><h3 id="匿名字段"><a href="#匿名字段" class="headerlink" title="匿名字段"></a>匿名字段</h3><p>所谓匿名字段，是指没有名字，仅有类型的字段，也被称作嵌入字段或者嵌入类型,这类用法非常常见。<br>如嵌入其他包中的类型，则隐式字段名不包括包名。就是说定义的时候字段是File而非os.File</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int</span></span><br><span class="line">addr</span><br><span class="line">os.File</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> addr <span class="keyword">struct</span> &#123;</span><br><span class="line">city <span class="keyword">string</span></span><br><span class="line">road <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">u := user&#123;</span><br><span class="line">name: <span class="string">"tom"</span>,</span><br><span class="line">age:  <span class="number">2</span>,</span><br><span class="line">addr: addr&#123;</span><br><span class="line">city: <span class="string">"Beijing"</span>,</span><br><span class="line">road: <span class="string">"XiBeiWang"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">File: os.File&#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">u.city = <span class="string">"Tianjin"</span></span><br><span class="line">fmt.Println(u)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//&#123;tom 2 &#123;Tianjin XiBeiWang&#125; &#123;&lt;nil&gt;&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>不仅仅是结构体，除接口指针和多级指针以外的任何命名类型都可以作为匿名字段</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">*<span class="keyword">int</span></span><br><span class="line"><span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">x := <span class="number">100</span></span><br><span class="line">d := data&#123;</span><br><span class="line"><span class="keyword">int</span>:    &amp;x,</span><br><span class="line"><span class="keyword">string</span>: <span class="string">"Abc"</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, d)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main.data&#123;int:(*int)(0xc00007e008), string:"Abc"&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> a *<span class="keyword">int</span></span><br><span class="line"><span class="keyword">type</span> b **<span class="keyword">int</span></span><br><span class="line"><span class="keyword">type</span> c <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> d <span class="keyword">struct</span> &#123;</span><br><span class="line">*a        <span class="comment">//embedded type cannot be a pointer</span></span><br><span class="line">b         <span class="comment">//embedded type cannot be a pointer</span></span><br><span class="line">c         <span class="comment">//embedded type cannot be a pointer to interface</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不能将基础类型和其指针类型同时嵌入，因为两者隐式名字相同。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> file <span class="keyword">struct</span>&#123;</span><br><span class="line">*<span class="keyword">int</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然可以像普通字段那要访问匿名字段成员，但是会存在重名问题。如果是这样的话就必须要使用显式字段名。<br>如果有多个成员都存在重名情况就必须要使用显式字段名。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> file <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">file</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">d := data&#123;</span><br><span class="line">name: <span class="string">"data"</span>,</span><br><span class="line">file: file&#123;</span><br><span class="line"><span class="string">"file"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">d.name = <span class="string">"data2"</span></span><br><span class="line">d.file.name = <span class="string">"file2"</span> <span class="comment">//使用显式的方式访问 data.file.name</span></span><br><span class="line">fmt.Println(d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//&#123;&#123;file2&#125; data2&#125;</span></span><br></pre></td></tr></table></figure><h3 id="字段标签"><a href="#字段标签" class="headerlink" title="字段标签"></a>字段标签</h3><p>字段标签(tag)并不是注释，而是用来对字段进行描述的元数据。尽管它不属于数据成员，但却是类型的组成部分。<br>在运行期间，可用发射获取标签信息。它常常被用作格式校验，数据库关系映射等。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span> <span class="string">`昵称`</span></span><br><span class="line">sex  <span class="keyword">byte</span>   <span class="string">`性别`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">u := user&#123;<span class="string">"Tom"</span>, <span class="number">1</span>&#125;</span><br><span class="line">v := reflect.ValueOf(u)</span><br><span class="line">t := v.Type()</span><br><span class="line"><span class="keyword">for</span> i, n := <span class="number">0</span>, t.NumField(); i &lt; n; i++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s: %v\n"</span>, t.Field(i).Tag, v.Field(i))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 昵称: Tom</span></span><br><span class="line"><span class="comment">// 性别: 1</span></span><br></pre></td></tr></table></figure><h3 id="内存分布"><a href="#内存分布" class="headerlink" title="内存分布"></a>内存分布</h3><p>不管结构体包含多少字段，其内存总是一次性分配的，各字段在相邻的地址空间按定义顺序排列，当然对于引用类型、字符串和指针，结构内存中只包含其基本（头部）数据。还有，所有匿名字段成员也被包含在内。<br>借助unsafe包中的相关函数，可输出所有字段的偏移量和长度。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> point <span class="keyword">struct</span> &#123;</span><br><span class="line">x, y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> value <span class="keyword">struct</span> &#123;</span><br><span class="line">id    <span class="keyword">int</span>    <span class="comment">//基本类型</span></span><br><span class="line">name  <span class="keyword">string</span> <span class="comment">//字符串</span></span><br><span class="line">data  []<span class="keyword">byte</span> <span class="comment">//引用类型</span></span><br><span class="line">next  *value <span class="comment">//指针类型</span></span><br><span class="line">point        <span class="comment">//匿名字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := value&#123;</span><br><span class="line">id:    <span class="number">1</span>,</span><br><span class="line">name:  <span class="string">"jack"</span>,</span><br><span class="line">data:  []<span class="keyword">byte</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">point: point&#123;x: <span class="number">-100</span>, y: <span class="number">-10</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"v: %p ~ %x, size: %d, align: %d\n"</span>, &amp;v, <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;v))+unsafe.Sizeof(v), unsafe.Sizeof(v), unsafe.Alignof(v))</span><br><span class="line">fmt.Printf(<span class="string">"id addr: %p  offset: %d  size: %d\n"</span>, &amp;v.id, unsafe.Offsetof(v.id), unsafe.Sizeof(v.id))</span><br><span class="line">fmt.Printf(<span class="string">"name addr: %p  offset: %d  size: %d\n"</span>, &amp;v.name, unsafe.Offsetof(v.name), unsafe.Sizeof(v.name))</span><br><span class="line">fmt.Printf(<span class="string">"data addr: %p  offset: %d  size: %d\n"</span>, &amp;v.data, unsafe.Offsetof(v.data), unsafe.Sizeof(v.data))</span><br><span class="line">fmt.Printf(<span class="string">"next addr: %p  offset: %d  size: %d\n"</span>, &amp;v.next, unsafe.Offsetof(v.next), unsafe.Sizeof(v.next))</span><br><span class="line">fmt.Printf(<span class="string">"pointx addr: %p  offset: %d  size: %d\n"</span>, &amp;v.x, unsafe.Offsetof(v.x), unsafe.Sizeof(v.x))</span><br><span class="line">fmt.Printf(<span class="string">"pointy addr: %p  offset: %d  size: %d\n"</span>, &amp;v.y, unsafe.Offsetof(v.y), unsafe.Sizeof(v.y))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对齐 8</span></span><br><span class="line"><span class="comment">// v: 0xc00008c000 ~ c00008c000, size: 72, align: 8</span></span><br><span class="line"><span class="comment">// id addr: 0xc00008c000  offset: 0  size: 8</span></span><br><span class="line"><span class="comment">// name addr: 0xc00008c008  offset: 8  size: 16</span></span><br><span class="line"><span class="comment">// data addr: 0xc00008c018  offset: 24  size: 24</span></span><br><span class="line"><span class="comment">// next addr: 0xc00008c030  offset: 48  size: 8</span></span><br><span class="line"><span class="comment">// pointx addr: 0xc00008c038  offset: 56  size: 8</span></span><br><span class="line"><span class="comment">// pointy addr: 0xc00008c040  offset: 64  size: 8</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     |-------- name -------|------------- data -------------|      |------ point ------|</span><br><span class="line">+----+----------+----------+----------+----------+----------+------+---------+---------+</span><br><span class="line">| id | name.ptr | name.len | data.ptr | data.len | data.cap | next | point.x | point.y |</span><br><span class="line">+----+----------+----------+----------+----------+----------+------+---------+---------+</span><br><span class="line">0    8          16         24         32         40         48     56        64        72</span><br></pre></td></tr></table></figure><p>在分配内存时，字段须做对齐处理，通常以所有字段中最长的基础类型宽度为标准。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// v0 := struct&#123;</span></span><br><span class="line"><span class="comment">// a byte</span></span><br><span class="line"><span class="comment">// b []int //基础类型为int 对齐宽度是8</span></span><br><span class="line"><span class="comment">// c byte</span></span><br><span class="line"><span class="comment">// &#125;&#123;&#125;</span></span><br><span class="line">v1 := <span class="keyword">struct</span> &#123;</span><br><span class="line">a <span class="keyword">byte</span></span><br><span class="line">b <span class="keyword">byte</span></span><br><span class="line">c <span class="keyword">int32</span> <span class="comment">//对齐宽度4</span></span><br><span class="line">&#125;&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">16</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%d %d\n"</span>, unsafe.Alignof(v1), unsafe.Sizeof(v1))</span><br><span class="line">fmt.Printf(<span class="string">"%p,%d,%d\n"</span>, &amp;v1.a, unsafe.Offsetof(v1.a), unsafe.Sizeof(v1.a))</span><br><span class="line">fmt.Printf(<span class="string">"%p,%d,%d\n"</span>, &amp;v1.b, unsafe.Offsetof(v1.b), unsafe.Sizeof(v1.b))</span><br><span class="line">fmt.Printf(<span class="string">"%p,%d,%d\n"</span>, &amp;v1.c, unsafe.Offsetof(v1.c), unsafe.Sizeof(v1.c))</span><br><span class="line"><span class="comment">//a是1位b是1位，"xx" c 是4位 单独开启 4位 ，那么排列起来就是 xx--|xxxx 宽度是4的对齐少于4个的重新开4个</span></span><br><span class="line"><span class="comment">//假如我们换个顺序改成a、c、b 我们预测一下应该是x---|xxxx|x--- </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较特殊的是空结构类型的字段。如果它是最后一个字段，那么编译器将其当做长度为1的类型做对齐处理，以便其地址不会越界，避免引发垃圾回收错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v1 := <span class="keyword">struct</span> &#123;</span><br><span class="line">a <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">c <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">b <span class="keyword">int</span></span><br><span class="line">&#125;&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%p ~ %x, size: %d  align: %d\n"</span>, &amp;v1, <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;v1))+unsafe.Sizeof(v1), unsafe.Sizeof(v1), unsafe.Alignof(v1))</span><br><span class="line">fmt.Printf(<span class="string">"a addr: %p  offset: %d size: %d\n"</span>, &amp;v1.a, unsafe.Offsetof(v1.a), unsafe.Sizeof(v1.a))</span><br><span class="line">fmt.Printf(<span class="string">"b addr: %p  offset: %d size: %d\n"</span>, &amp;v1.b, unsafe.Offsetof(v1.b), unsafe.Sizeof(v1.b))</span><br><span class="line">fmt.Printf(<span class="string">"c addr: %p  offset: %d size: %d\n"</span>, &amp;v1.c, unsafe.Offsetof(v1.c), unsafe.Sizeof(v1.c))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0xc000092000 ~ c000092010, size: 16  align: 8</span></span><br><span class="line"><span class="comment">// a addr: 0xc000092000  offset: 0 size: 0</span></span><br><span class="line"><span class="comment">// b addr: 0xc000092000  offset: 0 size: 8</span></span><br><span class="line"><span class="comment">// c addr: 0xc000092008  offset: 8 size: 0</span></span><br><span class="line"><span class="comment">// xxxxxxxx|x------  最后一个字段长度1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;结构&quot;&gt;&lt;a href=&quot;#结构&quot; class=&quot;headerlink&quot; title=&quot;结构&quot;&gt;&lt;/a&gt;结构&lt;/h2&gt;&lt;p&gt;字段名必须唯一，可以用”_”来部位，支持使用自身指针类型成员。字段名、排列顺序属类型组成部分。除对齐处理外，编译器不会优化，调整内存布局。&lt;
      
    
    </summary>
    
    
      <category term="golang" scheme="https://devying.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://devying.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>golang map总结</title>
    <link href="https://devying.github.io/2018/03/25/golangmap/"/>
    <id>https://devying.github.io/2018/03/25/golangmap/</id>
    <published>2018-03-24T16:23:02.000Z</published>
    <updated>2019-11-17T07:13:07.225Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>作为无序键值对集合，字典要求val必须是支持相等运算符(==,!=)的数据类型，比如数字、字符串、指针、数组、结构体，以及对应接口类型。<br>访问不存在的键值，默认返回零值，不会引发错误。但是推荐使用ok-idiom模式<br>对字典进行迭代的时候每次返回的键值顺序都是不一样的。字段不支持cap。<br>因内存访问安全和哈希算法等缘故，字段被设计成”not addressable”，故不能直接修改value成员（结构或数组）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := <span class="keyword">map</span>[<span class="keyword">int</span>]user&#123;</span><br><span class="line"><span class="number">1</span>: &#123;<span class="string">"Tom"</span>, <span class="number">19</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//m[1].age++ //错误了cannot assign to struct field m[1].age in map</span></span><br><span class="line"><span class="comment">//正确的做法如下</span></span><br><span class="line">u := m[<span class="number">1</span>]</span><br><span class="line">u.age++</span><br><span class="line">m[<span class="number">1</span>] = u</span><br><span class="line">fmt.Println(m) <span class="comment">//map[1:&#123;Tom 20&#125;]</span></span><br><span class="line"><span class="comment">//或者使用指针类型</span></span><br><span class="line">m2 := <span class="keyword">map</span>[<span class="keyword">int</span>]*user&#123;</span><br><span class="line"><span class="number">1</span>: &amp;user&#123;<span class="string">"Jack"</span>, <span class="number">20</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">m2[<span class="number">1</span>].age++</span><br><span class="line">fmt.Println(m2) <span class="comment">//map[1:0xc00000c0e0]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然m[key]++ 是可以操作的，如果value支持的话<br>不能对nil字典进行写操作，但是可以读。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line"><span class="built_in">println</span>(m[<span class="string">"a"</span>])<span class="comment">//返回零值</span></span><br><span class="line">m[<span class="string">"a"</span>] = <span class="number">1</span> <span class="comment">//panic: assignment to entry in nil map</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意了：内容为空的字典，与nil是不同的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> m1 <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">m2 := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="built_in">println</span>(m1 == <span class="literal">nil</span>,m2 == <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">//true false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个map不支持比较操作,只能和nil比较</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">x := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;<span class="number">1</span>: <span class="string">"a"</span>&#125;</span><br><span class="line">y := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;<span class="number">1</span>: <span class="string">"a"</span>&#125;</span><br><span class="line"><span class="built_in">println</span>(x == y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//invalid operation: x == y (map can only be compared to nil)</span></span><br></pre></td></tr></table></figure><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>在迭代期间删除或者新增键值是安全的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">m[i] = i + <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> x := <span class="keyword">range</span> m &#123;</span><br><span class="line"><span class="keyword">if</span> x == <span class="number">3</span> &#123;</span><br><span class="line">m[<span class="number">100</span>] = <span class="number">1000</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">delete</span>(m, x)</span><br><span class="line">fmt.Println(x, m)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4 map[0:100 1:101 2:102 3:103 5:105 6:106 7:107 8:108 9:109]</span></span><br><span class="line"><span class="comment">// 5 map[0:100 1:101 2:102 3:103 6:106 7:107 8:108 9:109]</span></span><br><span class="line"><span class="comment">// 6 map[0:100 1:101 2:102 3:103 7:107 8:108 9:109]</span></span><br><span class="line"><span class="comment">// 7 map[0:100 1:101 2:102 3:103 8:108 9:109]</span></span><br><span class="line"><span class="comment">// 8 map[0:100 1:101 2:102 3:103 9:109]</span></span><br><span class="line"><span class="comment">// 1 map[0:100 2:102 3:103 9:109]</span></span><br><span class="line"><span class="comment">// 3 map[0:100 2:102 9:109 100:1000]</span></span><br><span class="line"><span class="comment">// 9 map[0:100 2:102 100:1000]</span></span><br><span class="line"><span class="comment">// 0 map[2:102 100:1000]</span></span><br><span class="line"><span class="comment">// 2 map[100:1000]</span></span><br><span class="line">我们可以看到 <span class="keyword">map</span> 迭代的无序性，每次删除m的元素都会更新</span><br></pre></td></tr></table></figure><p>关于map并发操作导致的进程崩溃。(并发读、写、迭代)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"a"</span>:<span class="number">1</span>,<span class="string">"b"</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">m[<span class="string">"a"</span>] += <span class="number">1</span></span><br><span class="line">time.Sleep(time.Microsecond)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">_ = m[<span class="string">"b"</span>]</span><br><span class="line">time.Sleep(time.Microsecond)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//fatal error: concurrent map read and map write</span></span><br></pre></td></tr></table></figure><p>可以使用go run -race s.go 来检查此类问题,当然为了避免此类问题，可以使用读写互斥锁</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> lock sync.RWMutex</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">lock.Lock()</span><br><span class="line">m[<span class="string">"a"</span>] += <span class="number">1</span></span><br><span class="line">lock.Unlock()</span><br><span class="line">time.Sleep(time.Microsecond)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">lock.Lock()</span><br><span class="line">_ = m[<span class="string">"b"</span>]</span><br><span class="line">lock.Unlock()</span><br><span class="line">time.Sleep(time.Microsecond)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在创建时预先准备足够的空间有助于提升性能，减少扩张时的内存分配和重新哈希操作。对于海量小对象，应该直接用字典存储键值数据拷贝而不是指针，这样减少扫描对象的数量缩短垃圾回收时间。另外，字典不会收缩内存，适当替换新对象是有必要的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;字典&quot;&gt;&lt;a href=&quot;#字典&quot; class=&quot;headerlink&quot; title=&quot;字典&quot;&gt;&lt;/a&gt;字典&lt;/h2&gt;&lt;p&gt;作为无序键值对集合，字典要求val必须是支持相等运算符(==,!=)的数据类型，比如数字、字符串、指针、数组、结构体，以及对应接口类型。&lt;b
      
    
    </summary>
    
    
      <category term="golang" scheme="https://devying.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://devying.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>golang切片总结</title>
    <link href="https://devying.github.io/2018/03/10/golang%E5%88%87%E7%89%87/"/>
    <id>https://devying.github.io/2018/03/10/golang切片/</id>
    <published>2018-03-09T16:23:02.000Z</published>
    <updated>2019-11-17T07:11:12.812Z</updated>
    
    <content type="html"><![CDATA[<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>切片本身并非动态数组或者数组指针。它内部通过指针引用底层数组，设定相关属性将数据读写操作限定在指定区域内。<br>切片本身是个只读对象，其工作机制类似于数组指针的一种包装<br>demo:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">x := [...]int&#123;0,1,2,3,4,5,6,7,8,9&#125;</span><br><span class="line"></span><br><span class="line">expression   slice                    len   <span class="built_in">cap</span> </span><br><span class="line">-----------+------------------------+-----+-----+------------</span><br><span class="line">x[:]         [0 1 2 3 4 5 6 7 8 9]    10    10    x[0:len(x)] </span><br><span class="line">x[2:5]       [2 3 4]                  3     8</span><br><span class="line">x[2:5:7]     [2 3 4]                  3     5</span><br><span class="line">x[4:]        [4 5 6 7 8 9]            6     6     x[4:len(x)]</span><br><span class="line">x[:4]        [0 1 2 3]                4     10    x[0:4]</span><br><span class="line">x[:4:6]      [0 1 2 3]                4     6     x[0:4:6]</span><br><span class="line"></span><br><span class="line">操作如下</span><br><span class="line">            low:2       high:5  max:7                         len = high - low</span><br><span class="line">            |           |       |                             <span class="built_in">cap</span> = max  - low</span><br><span class="line">    +---+---+---+---+---+---+---+---+---+---+           +-----+---+---+</span><br><span class="line">  x | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |           | ptr |3 | 5 |  x[2:5:7]</span><br><span class="line">    +---+---+---+---+---+---+---+---+---+---+           +-----+---+---+</span><br><span class="line">            |           |       |                          |</span><br><span class="line">            |&lt;-- len --&gt;|       |                          |</span><br><span class="line">            |                   |                          |</span><br><span class="line">            |&lt;------ <span class="built_in">cap</span> ------&gt;|                          |</span><br><span class="line">            |                                              |</span><br><span class="line">            |&lt;----------------- array pointer&lt;-------------+</span><br></pre></td></tr></table></figure><p>1.cap 表示切片引用数组片段的真实长度，len用于限定可读写元素数量。另外数组必须addressable，否则会引发错误。<br>关于是否可寻址，可以参考一下<a href="https://colobu.com/2018/02/27/go-addressable/" target="_blank" rel="noopener">https://colobu.com/2018/02/27/go-addressable/</a><br>2.和数组一样，切片同样适用索引号访问元素内容。起始索引为0，而非对应的底层数组的真实索引位置。<br>3.可以直接创建切片对象，无需预先准备数组。因为是引用类型，须使用make函数或显示初始化语句，他会自动完成底层数组内存分配</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">s2 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">s3 := []<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">5</span>: <span class="number">30</span>&#125;  <span class="comment">//这个方式跟数组好像</span></span><br><span class="line">fmt.Println(s1, <span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1))</span><br><span class="line">fmt.Println(s2, <span class="built_in">len</span>(s2), <span class="built_in">cap</span>(s2))</span><br><span class="line">fmt.Println(s3, <span class="built_in">len</span>(s3), <span class="built_in">cap</span>(s3))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>] <span class="number">3</span> <span class="number">5</span></span><br><span class="line">[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>] <span class="number">3</span> <span class="number">3</span></span><br><span class="line">[<span class="number">10</span> <span class="number">20</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">30</span>] <span class="number">6</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><p>注意以下两种定义方式的区别。前者定义了一个[]int类型变量，并未执行初始化操作，而后者则用初始化表达式完成了全部创建过程。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a []<span class="keyword">int</span></span><br><span class="line">b := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="built_in">println</span>(a==<span class="literal">nil</span>,b==<span class="literal">nil</span>)</span><br><span class="line"><span class="comment">//true false</span></span><br><span class="line"><span class="comment">//可以用(*reflect.SliceHeader)(unsafe.Pointer(&amp;a))打印出来结构</span></span><br><span class="line">另外虽然a == <span class="literal">nil</span> ，切片本身依然会分配内存。可以直接对a进行slice[:]操作，同样返回<span class="literal">nil</span></span><br></pre></td></tr></table></figure><p>切片不支持比较操作，就算元素类型支持也不行，仅能判定是否为nil<br>可以获取元素的地址，但是不能像数组那样直接用指针访问元素。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">p := &amp;s</span><br><span class="line">p0 := &amp;s[<span class="number">0</span>]</span><br><span class="line">p1 := &amp;s[<span class="number">1</span>]</span><br><span class="line"><span class="built_in">println</span>(p, p0, p1)</span><br><span class="line">*p0 += <span class="number">1</span> <span class="comment">//这种操作切片和数组一样</span></span><br><span class="line">*p1 += <span class="number">100</span></span><br><span class="line">fmt.Println(s)</span><br></pre></td></tr></table></figure><p>假如元素类型也是切片，那么也就可以实现类似交错数组功能。<br>另外并不是所有的时候都适合用切片代替数组，因为切片底层数组可能会再堆上分配内存。而且小数组在栈上拷贝的消耗也未必就比make大。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">array</span><span class="params">()</span> [1024]<span class="title">int</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> x [<span class="number">1024</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i:= <span class="number">0</span>;i&lt;<span class="built_in">len</span>(x);i++&#123;</span><br><span class="line">x[i]=i</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slice</span><span class="params">()</span> []<span class="title">int</span></span>&#123;</span><br><span class="line">x := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">1024</span>)</span><br><span class="line"><span class="keyword">for</span> i:= <span class="number">0</span>;i&lt;<span class="built_in">len</span>(x);i++&#123;</span><br><span class="line">x[i]=i</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkArray</span><span class="params">(b *testing.B)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;b.N;i++&#123;</span><br><span class="line">array()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSlice</span><span class="params">(b *testing.B)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;b.N;i++&#123;</span><br><span class="line">slice()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试结果</span></span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">BenchmarkArray<span class="number">-4</span>         <span class="number">2000000</span>               <span class="number">725</span> ns/op</span><br><span class="line">BenchmarkSlice<span class="number">-4</span>         <span class="number">1000000</span>              <span class="number">1284</span> ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      command-line-arguments  <span class="number">3.490</span>s</span><br></pre></td></tr></table></figure><h3 id="reslice"><a href="#reslice" class="headerlink" title="reslice"></a>reslice</h3><p>将切片视作[cap]slice数据源，据此创建新切片对象。不能超过cap，但不受len限制。<br>s[x:y:z] x起始索引 y结束索引，但是不包含y值，z表示取s的z个容量，如果不写z则是cap(s)-x<br>否则是z-x</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+---+---+---+---+---+---+---+---+---+---+</span><br><span class="line">| 0 | 1 | 2 | 3 | 4 | 5 | 6 |   |   |   |  s            len:6,<span class="built_in">cap</span>:10</span><br><span class="line">+---+---+---+---+---+---+---+---+---+---+</span><br><span class="line">0           3                   8      10</span><br><span class="line">    </span><br><span class="line">            +---+---+---+---+---+---+---+</span><br><span class="line">            | 3 | 4 | 5 | 6 | 0 |   |   |  s1=s[3:8]    len:5,<span class="built_in">cap</span>:7</span><br><span class="line">            +---+---+---+---+---+---+---+</span><br><span class="line">            0       2       4       6</span><br><span class="line"></span><br><span class="line">                    +---+---+---+---+</span><br><span class="line">                    | 5 | 6 |   |   |      s2=s1[2:4:6] len:2,<span class="built_in">cap</span>:4</span><br><span class="line">                    +---+---+---+---+</span><br><span class="line">                    0   1</span><br><span class="line"></span><br><span class="line">                    +---+---+---+---+---+</span><br><span class="line">                    | 5 |   |   |   |   |  s3=s2[:1:5]   error:slice bounds out of range</span><br><span class="line">                    +---+---+---+---+---+</span><br></pre></td></tr></table></figure><h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><p>在两个切片对象间复制数据，允许指向同一底层数组，允许目标区间重叠。最终所复制长度以较短的切片长度为准</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">s1 := s[<span class="number">5</span>:<span class="number">8</span>]</span><br><span class="line">n := <span class="built_in">copy</span>(s[<span class="number">4</span>:], s1)  <span class="comment">//5,6,7======&gt;4--9 //在同一底层数组的不同区间复制</span></span><br><span class="line">fmt.Println(s, s1, n) <span class="comment">//[0 1 2 3 5 6 7 7 8 9] [6 7 7] 3</span></span><br><span class="line">s2 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">6</span>)</span><br><span class="line">n2 := <span class="built_in">copy</span>(s2, s)   <span class="comment">//在不同数组间复制</span></span><br><span class="line">fmt.Println(s2, n2) <span class="comment">//[0 1 2 3 5 6] 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然还可以将字符串中复制数据到[]byte</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">5</span>)</span><br><span class="line">n3 := <span class="built_in">copy</span>(b, str)</span><br><span class="line">fmt.Println(b, n3) <span class="comment">//[97 98 99 100 101] 5</span></span><br></pre></td></tr></table></figure><p>如果切片长时间引用大数组中很小的片段，那么建议单独新建独立的切片，复制出所需数据，以便原数组可以被及时回收</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;切片&quot;&gt;&lt;a href=&quot;#切片&quot; class=&quot;headerlink&quot; title=&quot;切片&quot;&gt;&lt;/a&gt;切片&lt;/h2&gt;&lt;p&gt;切片本身并非动态数组或者数组指针。它内部通过指针引用底层数组，设定相关属性将数据读写操作限定在指定区域内。&lt;br&gt;切片本身是个只读对象，其工
      
    
    </summary>
    
    
      <category term="golang" scheme="https://devying.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://devying.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>golang数组总结</title>
    <link href="https://devying.github.io/2018/02/25/golang%E6%95%B0%E7%BB%84/"/>
    <id>https://devying.github.io/2018/02/25/golang数组/</id>
    <published>2018-02-24T16:23:02.000Z</published>
    <updated>2019-11-17T06:49:37.812Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>定义数组类型时，数组长度必须是非负整数常量表达式，长度是类型组成部分。也就是说，元素类型相同，但是长度不同的数组不属于同一类型。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a [<span class="number">4</span>]<span class="built_in">int</span></span><br><span class="line">b := [<span class="number">4</span>]<span class="built_in">int</span>&#123;<span class="number">2</span>,<span class="number">5</span>&#125; <span class="comment">//未初始化的元素自动初始化为0</span></span><br><span class="line">c := [<span class="number">4</span>]<span class="built_in">int</span>&#123;<span class="number">5</span>,<span class="number">3</span>:<span class="number">10</span>&#125; <span class="comment">//可以指定索引位置初始化</span></span><br><span class="line">d := [...]<span class="built_in">int</span>&#123;<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>&#125; <span class="comment">//编译器按初始化值的数量来确定数组的长度</span></span><br><span class="line">e := [...]<span class="built_in">int</span>&#123;<span class="number">10</span>,<span class="number">5</span>:<span class="number">100</span>&#125;</span><br></pre></td></tr></table></figure><p>对于结构等复合类型，可以省略元素初始化类型标签。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line">d := [...]user&#123;</span><br><span class="line">&#123;<span class="string">"Huangby"</span>, <span class="number">30</span>&#125;,</span><br><span class="line">&#123;<span class="string">"Mi"</span>, <span class="number">20</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%#v"</span>, d)</span><br><span class="line"><span class="comment">//以上输出</span></span><br><span class="line">[<span class="number">2</span>]main.user&#123;main.user&#123;name:<span class="string">"Huangby"</span>, age:<span class="number">0x1e</span>&#125;, main.user&#123;name:<span class="string">"Mi"</span>, age:<span class="number">0x14</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>在定义多维数组时仅第一维度允许使用”…”</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">b := [...][<span class="number">3</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">&#123;<span class="number">10</span>,<span class="number">20</span>&#125;,</span><br><span class="line">&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">50</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果是 [[10 20 0] [10 20 50]]</span></span><br><span class="line">c := [...][<span class="number">3</span>][<span class="number">4</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="number">10</span>,<span class="number">12</span>,<span class="number">2</span>&#125;,</span><br><span class="line">&#123;<span class="number">6</span>,<span class="number">12</span>&#125;,</span><br><span class="line">&#123;<span class="number">100</span>&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="number">13</span>,<span class="number">2</span>:<span class="number">90</span>&#125;,</span><br><span class="line">&#123;<span class="number">6</span>&#125;,</span><br><span class="line">&#123;<span class="number">3</span>:<span class="number">33</span>&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果是 [[[10 12 2 0] [6 12 0 0] [100 0 0 0]] [[13 0 90 0] [6 0 0 0] [0 0 0 33]]]</span></span><br></pre></td></tr></table></figure><p>另外内置函数len和cap都返回的是第一维度的长度<br>如果数组的元素类型支持“==”或者“!=”操作，那么对应数组也支持。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a,b [<span class="number">2</span>]<span class="keyword">int</span></span><br><span class="line"><span class="built_in">println</span>(a==b) <span class="comment">//int支持==操作符  true</span></span><br><span class="line"></span><br><span class="line">c := [<span class="number">2</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">d := [<span class="number">2</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>&#125;</span><br><span class="line"><span class="built_in">println</span>(c==d) <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> e,f [<span class="number">2</span>]<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line"><span class="built_in">println</span>(e == f) <span class="comment">//map[string]int 不支持 == 操作符</span></span><br></pre></td></tr></table></figure><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>要分清楚指针数组和数组指针的区别，指针数是指元素为指针类型的数组，数组指针是获取数组变量的地址。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x, y := <span class="number">10</span>, <span class="number">20</span></span><br><span class="line">a := [...]*<span class="keyword">int</span>&#123;&amp;x, &amp;y&#125;</span><br><span class="line">p := &amp;a</span><br><span class="line">fmt.Printf(<span class="string">"%T,%v\n"</span>, a, a) <span class="comment">//元素为指针的指针数组</span></span><br><span class="line">fmt.Printf(<span class="string">"%T,%v\n"</span>, p, p) <span class="comment">//存储数组地址的指针</span></span><br><span class="line"><span class="comment">//以上输出</span></span><br><span class="line"><span class="comment">// [2]*int,[0xc000092000 0xc00007e008]</span></span><br><span class="line"><span class="comment">// *[2]*int,&amp;[0xc000092000 0xc00007e008]</span></span><br></pre></td></tr></table></figure><p>另外我们可以获取任何元素的地址</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line"><span class="built_in">println</span>(&amp;a,&amp;a[<span class="number">0</span>],&amp;a[<span class="number">1</span>])</span><br><span class="line"><span class="comment">//以上输出</span></span><br><span class="line"><span class="comment">//0xc000032778 0xc000032778 0xc000032780</span></span><br></pre></td></tr></table></figure><p>数组指针可以直接用来操作元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">p := &amp;a</span><br><span class="line">p[<span class="number">1</span>] += <span class="number">20</span>  <span class="comment">//直接操作元素</span></span><br><span class="line"><span class="built_in">println</span>(p[<span class="number">1</span>]) <span class="comment">//22</span></span><br><span class="line"><span class="comment">//&amp;a[0] += 100//错误 cannot assign to &amp;a[0]</span></span><br><span class="line"><span class="comment">//正确的姿势  因为都是int 也可以将unsafe去掉</span></span><br><span class="line">up := (*<span class="keyword">int</span>)(unsafe.Pointer(&amp;a[<span class="number">0</span>]))</span><br><span class="line">*up = <span class="number">100</span></span><br><span class="line"><span class="comment">//或者 up := &amp;a[0] *up += 100</span></span><br><span class="line"><span class="built_in">println</span>(a[<span class="number">0</span>], a[<span class="number">1</span>]) <span class="comment">//100 22</span></span><br></pre></td></tr></table></figure><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>与C数组变量隐式作为指针使用不同，Go数组是值类型，赋值和传参操作都会复制整个数组数据。如果需要，可改用指针或者切片，避免数据复制。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h2&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;p&gt;定义数
      
    
    </summary>
    
    
      <category term="golang" scheme="https://devying.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://devying.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>golang字符串总结</title>
    <link href="https://devying.github.io/2018/02/03/golang%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://devying.github.io/2018/02/03/golang字符串/</id>
    <published>2018-02-02T16:23:02.000Z</published>
    <updated>2019-11-17T06:49:29.511Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串是不可变字节(byte)序列,其本身是一个复合结构</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">stringStruct</span></span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="built_in">str</span> <span class="keyword">unsafe</span>.Pointer</span><br><span class="line">    len int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>头部指针指向字节数组，但没有NULL结尾。默认以UTF-8编码存储Unicode字符，字面量里允许使用十六进制、八进制和UTF编码格式。<br>内置函数len返回字节数组长度，cap不接受字符串类型参数。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">s := <span class="string">"黄abc\x61\142\u0041"</span></span><br><span class="line">println(len(s))</span><br><span class="line">println(len([]rune(s)))  <span class="comment">//先转成rune数组再计算数组长度</span></span><br><span class="line">    fmt.Println([]rune(s))</span><br><span class="line">fmt.Println([]byte(s))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line">[<span class="number">40644</span> <span class="number">97</span> <span class="number">98</span> <span class="number">99</span> <span class="number">97</span> <span class="number">98</span> <span class="number">65</span>]</span><br><span class="line">[<span class="number">233</span> <span class="number">187</span> <span class="number">132</span> <span class="number">97</span> <span class="number">98</span> <span class="number">99</span> <span class="number">97</span> <span class="number">98</span> <span class="number">65</span>]</span><br></pre></td></tr></table></figure><p>字符串默认值是””,可以使用``来处理原始字符串。<br>字符串支持“!=、==、&lt;、&gt;、+、+=”操作符，其中跨行时操作符必须在上一行结尾。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="string">"ab"</span> +</span><br><span class="line"><span class="string">"cd"</span></span><br><span class="line"><span class="built_in">println</span>(s == <span class="string">"abcd"</span>)</span><br><span class="line"><span class="built_in">println</span>(s &gt; <span class="string">"abc"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p>允许以索引号访问字节数组（非字符）,但不能获取元素地址。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">func</span> <span class="selector-tag">main</span>() &#123;</span><br><span class="line"><span class="attribute">s </span>:= <span class="string">"abcd"</span></span><br><span class="line"><span class="built_in">println</span>(s[1])</span><br><span class="line"><span class="built_in">println</span>(&amp;s[1])//错误</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">cannot</span> <span class="selector-tag">take</span> <span class="selector-tag">the</span> <span class="selector-tag">address</span> <span class="selector-tag">of</span> <span class="selector-tag">s</span><span class="selector-attr">[1]</span></span><br></pre></td></tr></table></figure><p>以切片语法返回子串时，其内部依旧指向原字节数组</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">s := <span class="string">"abcdefg"</span></span><br><span class="line">s1 := s[:<span class="number">2</span>]</span><br><span class="line">s2 := s[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">s3 := s[<span class="number">3</span>:]</span><br><span class="line">println(s1, s2, s3)</span><br><span class="line">fmt.Printf(<span class="string">"%#v"</span>, (*<span class="built_in">ref</span>lect.StringHeader)(unsafe.Pointer(&amp;s))) </span><br><span class="line">    <span class="comment">//我们先去到Go字符串的指针，它本质上是一个*reflect.StringHeader，但是Go告诉我们这是一个*string</span></span><br><span class="line">    <span class="comment">//unsafe.Pointer 用于两个不同类型的指针转换 上面这个就是将字符串指针转成*reflect.StringHeader 指针</span></span><br><span class="line">fmt.Printf(<span class="string">"%#v"</span>, (*<span class="built_in">ref</span>lect.StringHeader)(unsafe.Pointer(&amp;s1)))</span><br><span class="line">fmt.Printf(<span class="string">"%#v"</span>, (*<span class="built_in">ref</span>lect.StringHeader)(unsafe.Pointer(&amp;s2)))</span><br><span class="line">fmt.Printf(<span class="string">"%#v"</span>, (*<span class="built_in">ref</span>lect.StringHeader)(unsafe.Pointer(&amp;s3)))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">ab bcd defg</span><br><span class="line">&amp;<span class="built_in">ref</span>lect.StringHeader&#123;Data:<span class="number">0x10c8b36</span>, Len:<span class="number">7</span>&#125;</span><br><span class="line">&amp;<span class="built_in">ref</span>lect.StringHeader&#123;Data:<span class="number">0x10c8b36</span>, Len:<span class="number">2</span>&#125;</span><br><span class="line">&amp;<span class="built_in">ref</span>lect.StringHeader&#123;Data:<span class="number">0x10c8b37</span>, Len:<span class="number">3</span>&#125;</span><br><span class="line">&amp;<span class="built_in">ref</span>lect.StringHeader&#123;Data:<span class="number">0x10c8b39</span>, Len:<span class="number">4</span>&#125;</span><br><span class="line">可以看出 第一个字节地址是一样的</span><br></pre></td></tr></table></figure><p>遍历字符串两种方式结果不一样</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="string">"胡汉三"</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;          <span class="comment">//byte</span></span><br><span class="line">fmt.Printf(<span class="string">"%c\n"</span>, s[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;                  <span class="comment">//rune:返回数组索引号，以及Unicode字符</span></span><br><span class="line">fmt.Printf(<span class="string">"%c\n"</span>, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">é</span><br><span class="line">»</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ä</span><br><span class="line">¿</span><br><span class="line"></span><br><span class="line">胡</span><br><span class="line">汉</span><br><span class="line">三</span><br></pre></td></tr></table></figure><h3 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h3><p>要修改字符串，须将其转为可变类型（[ ]byte或[ ]rune）待完成后再转回来。但是不管如何转换，都需重新分配内存，并复制数据。当然有些时候这么做会拖累算法性能，可以使用“非安全”方法进行改善。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">bt := []<span class="keyword">byte</span>(<span class="string">"hello,world"</span>)</span><br><span class="line">sp := (*<span class="keyword">string</span>)(unsafe.Pointer(&amp;bt))</span><br><span class="line">fmt.Println(*sp)</span><br><span class="line">    *sp = <span class="string">"huangby"</span>    <span class="comment">//直接修改对象</span></span><br><span class="line">    fmt.Println(bt)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">hello,world</span><br><span class="line">huangby</span><br><span class="line">该方法利用了[]<span class="keyword">byte</span>和<span class="keyword">string</span>头部结构部分相同，以非安全的指针类型转换来实现类型变更。</span><br></pre></td></tr></table></figure><p>用append函数可以将string直接追加到[]byte内</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">bt := []<span class="keyword">byte</span>(<span class="string">"hello,world"</span>)</span><br><span class="line">bt = <span class="built_in">append</span>(bt, <span class="string">"@huangby"</span>...)</span><br><span class="line">fmt.Printf(<span class="string">"%s"</span>, bt)</span><br><span class="line">ru := []<span class="keyword">rune</span>(<span class="string">"你好，世界"</span>)</span><br><span class="line">ru = <span class="built_in">append</span>(ru, <span class="string">'应'</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%c"</span>, ru)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">hello,world@huangby[你 好 ， 世 界 应]</span><br><span class="line">注意了<span class="keyword">rune</span>不能像<span class="keyword">string</span>...那么使用</span><br></pre></td></tr></table></figure><p>考虑到字符串只读特征，转换时复制数据到新分配内存是可以理解的。当然，性能同样重要，编译器会为某些场合进行专门优化，避免额外分配和复制操作：</p><ul><li>将[]byte转为string key,去map[string]查询的时候</li><li>将string转为[]byte，进行for range迭代时，直接取字节赋值给局部变量。<br>GDB验证一下<br>编译的时候加上 go build -gcflags ‘-N -l’<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">GNU gdb (GDB) 8.3</span><br><span class="line">Copyright (C) 2019 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line">Type <span class="string">"show copying"</span> and <span class="string">"show warranty"</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">"x86_64-apple-darwin17.7.0"</span>.</span><br><span class="line">Type <span class="string">"show configuration"</span> <span class="keyword">for</span> configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line"></span><br><span class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">"help"</span>.</span><br><span class="line">Type <span class="string">"apropos word"</span> to search <span class="keyword">for</span> commands related to <span class="string">"word"</span>...</span><br><span class="line">Reading symbols from ./s...</span><br><span class="line">Loading Go Runtime support.</span><br><span class="line">(gdb) b 6</span><br><span class="line">Breakpoint 1 at 0x10567cb: file /Users/baoying5/go/src/basic/s.go, line 6.</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /Users/baoying5/go/src/basic/s </span><br><span class="line">[New Thread 0xc03 of process 4532]</span><br><span class="line">[New Thread 0xb03 of process 4532]</span><br><span class="line">warning: `/BuildRoot/Library/Caches/com.apple.xbs/Binaries/Libc_darwin/install/TempContent/Objects/Libc.build/libsystem_darwin.dylib.build/Objects-normal/x86_64/darwin_vers.o<span class="string">': can'</span>t open to <span class="built_in">read</span> symbols: No such file or directory.</span><br><span class="line">warning: `/BuildRoot/Library/Caches/com.apple.xbs/Binaries/Libc_darwin/install/TempContent/Objects/Libc.build/libsystem_darwin.dylib.build/Objects-normal/x86_64/dirstat.o<span class="string">': can'</span>t open to <span class="built_in">read</span> symbols: No such file or directory.</span><br><span class="line">warning: `/BuildRoot/Library/Caches/com.apple.xbs/Binaries/Libc_darwin/install/TempContent/Objects/Libc.build/libsystem_darwin.dylib.build/Objects-normal/x86_64/dirstat_collection.o<span class="string">': can'</span>t open to <span class="built_in">read</span> symbols: No such file or directory.</span><br><span class="line">warning: `/BuildRoot/Library/Caches/com.apple.xbs/Binaries/Libc_darwin/install/TempContent/Objects/Libc.build/libsystem_darwin.dylib.build/Objects-normal/x86_64/init.o<span class="string">': can'</span>t open to <span class="built_in">read</span> symbols: No such file or directory.</span><br><span class="line">warning: `/BuildRoot/Library/Caches/com.apple.xbs/Binaries/Libc_darwin/install/TempContent/Objects/Libc.build/libsystem_darwin.dylib.build/Objects-normal/x86_64/variant.o<span class="string">': can'</span>t open to <span class="built_in">read</span> symbols: No such file or directory.</span><br><span class="line">[New Thread 0x90f of process 4532]</span><br><span class="line">[New Thread 0x1503 of process 4532]</span><br><span class="line">[New Thread 0x1603 of process 4532]</span><br><span class="line">[New Thread 0x2903 of process 4532]</span><br><span class="line"></span><br><span class="line">Thread 2 hit Breakpoint 1, main.main () at /Users/baoying5/go/src/basic/s.go:6</span><br><span class="line">warning: Source file is more recent than executable.</span><br><span class="line">6               //s := string(key)</span><br><span class="line">(gdb) info locals</span><br><span class="line">ok = <span class="literal">false</span></span><br><span class="line">x = 18550296</span><br><span class="line">m = map[string]int = &#123;[0x1075b17 <span class="string">"abc"</span>] = 123&#125;</span><br><span class="line">key = &#123;array = 0xc00003261d <span class="string">"abc\030\016\033\001"</span>, len = 3, <span class="built_in">cap</span> = 3&#125;</span><br><span class="line">(gdb) s</span><br><span class="line">runtime.mapaccess2_faststr (t=0x10649c0 &lt;<span class="built_in">type</span>.*+57568&gt;, h=0xc000032688, ky=..., ~r3=&lt;optimized out&gt;, ~r4=&lt;optimized out&gt;)</span><br><span class="line">    at /usr/<span class="built_in">local</span>/go/src/runtime/map_faststr.go:107</span><br><span class="line">107     func mapaccess2_faststr(t *maptype, h *hmap, ky string) (unsafe.Pointer, bool) &#123;</span><br><span class="line">(gdb) info args</span><br><span class="line">t = 0x10649c0 &lt;<span class="built_in">type</span>.*+57568&gt;</span><br><span class="line">h = 0xc000032688</span><br><span class="line">ky = &lt;optimized out&gt;</span><br><span class="line">~r3 = &lt;optimized out&gt;</span><br><span class="line">~r4 = &lt;optimized out&gt;</span><br><span class="line">(gdb) x/3xw ky</span><br><span class="line">value has been optimized out</span><br><span class="line">(gdb) s</span><br><span class="line">112             <span class="keyword">if</span> h == nil || h.count == 0 &#123;</span><br><span class="line">(gdb) s</span><br><span class="line">115             <span class="keyword">if</span> h.flags&amp;hashWriting != 0 &#123;</span><br><span class="line">(gdb) s</span><br><span class="line">118             key := stringStructOf(&amp;ky)</span><br><span class="line">(gdb) x/3xw key</span><br><span class="line">value has been optimized out</span><br><span class="line">(gdb) x/3xw &amp;key</span><br><span class="line">Can<span class="string">'t take address of "key" which isn'</span>t an lvalue.</span><br><span class="line">(gdb) s</span><br><span class="line">runtime.stringStructOf (sp=0xc0000325f8, ~r1=&lt;optimized out&gt;) at /usr/<span class="built_in">local</span>/go/src/runtime/string.go:230</span><br><span class="line">230             <span class="built_in">return</span> (*stringStruct)(unsafe.Pointer(sp))</span><br><span class="line">(gdb) x/3xw key</span><br><span class="line">No symbol <span class="string">"key"</span> <span class="keyword">in</span> current context.</span><br><span class="line">(gdb) x/3xw &amp;key</span><br><span class="line">No symbol <span class="string">"key"</span> <span class="keyword">in</span> current context.</span><br><span class="line">(gdb) s</span><br><span class="line">runtime.mapaccess2_faststr (t=0x10649c0 &lt;<span class="built_in">type</span>.*+57568&gt;, h=0xc000032688, ky=..., ~r3=&lt;optimized out&gt;, ~r4=&lt;optimized out&gt;)</span><br><span class="line">    at /usr/<span class="built_in">local</span>/go/src/runtime/map_faststr.go:119</span><br><span class="line">119             <span class="keyword">if</span> h.B == 0 &#123;</span><br><span class="line">(gdb) x/3xw key</span><br><span class="line">0xc0000325f8:   0x0003261d      0x000000c0      0x00000003</span><br><span class="line">(gdb) s</span><br><span class="line">121                     b := (*bmap)(h.buckets)</span><br><span class="line">(gdb) s</span><br><span class="line">122                     <span class="keyword">if</span> key.len &lt; 32 &#123;</span><br><span class="line">(gdb) s</span><br><span class="line">124                             <span class="keyword">for</span> i, kptr := uintptr(0), b.keys(); i &lt; bucketCnt; i, kptr = i+1, add(kptr, 2*sys.PtrSize) &#123;</span><br><span class="line">(gdb) x/3xw key</span><br><span class="line">0xc0000325f8:   0x0003261d      0x000000c0      0x00000003</span><br><span class="line">(gdb) </span><br><span class="line"></span><br><span class="line">可以看到 地址 0x0003261d 说明这里是直接修改的地址</span><br></pre></td></tr></table></figure><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3>除类型转换外，动态构建字符串也容易造成性能问题<br>用加法操作字符拼接字符串时，每次都需要重写分配内存。如此，在构建超大字符串时性能就特别差。<br>可以用<code>strings.Join</code> 或者 <code>bytes.Buffer</code><br>对于数量较少的字符串格式化拼接可以用fmt.Sprintf、text/template等方法<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> a <span class="built_in">bytes</span>.Buffer</span><br><span class="line">a.Grow(<span class="number">100</span>)</span><br><span class="line">for i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">a.WriteByte(<span class="string">'c'</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(a.<span class="built_in">String</span>())</span><br></pre></td></tr></table></figure><h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3>类型rune专门用来存储Unicode码点，他是int32的别名，相当于UCS-4、UTF-32编码格式。使用单引号的字面量，其默认类型就是rune。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := <span class="string">'黄'</span></span><br><span class="line">fmt.Printf(<span class="string">"type : %T"</span>, r)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//type : int32</span></span><br></pre></td></tr></table></figure>除了[]rune 外（即不能[]rune()这样转一个字符串），还可以再rune/byte/string间进行转换,<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">r := <span class="string">'黄'</span></span><br><span class="line">fmt.Printf(<span class="string">"type : %T\n"</span>, r)</span><br><span class="line">s := <span class="keyword">string</span>(r)</span><br><span class="line">b := <span class="keyword">byte</span>(r)</span><br><span class="line"></span><br><span class="line">s2 := <span class="keyword">string</span>(b)</span><br><span class="line">r2 := <span class="keyword">rune</span>(b)</span><br><span class="line">fmt.Println(r, s, b, s2, r2)</span><br><span class="line"><span class="comment">//40644 黄 196 Ä 196</span></span><br></pre></td></tr></table></figure>字符串存储的字节数组，不一定就是合法的UTF-8文本<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">str</span> := <span class="string">"胡汉三"</span></span><br><span class="line">stt := <span class="keyword">str</span>[:<span class="number">1</span>] + <span class="keyword">str</span>[<span class="number">3</span>:<span class="number">4</span>]</span><br><span class="line">fmt.Println(stt) <span class="comment">//��</span></span><br><span class="line">fmt.Println(utf8.ValidString(stt))</span><br><span class="line"><span class="comment">//以上输出</span></span><br><span class="line">��</span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure>当然我们用unicode库下面的一些函数，可以统计Unicode字符数量,另外官方扩展库还有提供对BOM支持的。<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">str</span> := <span class="string">"胡汉三abc"</span></span><br><span class="line">fmt.Println(len(<span class="keyword">str</span>), utf8.RuneCountInString(<span class="keyword">str</span>))</span><br><span class="line"><span class="comment">//以上输出</span></span><br><span class="line"><span class="number">12</span> <span class="number">6</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;字符串&quot;&gt;&lt;a href=&quot;#字符串&quot; class=&quot;headerlink&quot; title=&quot;字符串&quot;&gt;&lt;/a&gt;字符串&lt;/h2&gt;&lt;p&gt;字符串是不可变字节(byte)序列,其本身是一个复合结构&lt;/p&gt;
&lt;figure class=&quot;highlight rust&quot;&gt;&lt;t
      
    
    </summary>
    
    
      <category term="golang" scheme="https://devying.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://devying.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>golang数据类型总结</title>
    <link href="https://devying.github.io/2018/01/13/golang%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/"/>
    <id>https://devying.github.io/2018/01/13/golang数据类型总结/</id>
    <published>2018-01-12T16:23:02.000Z</published>
    <updated>2019-11-17T06:48:30.871Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><table><thead><tr><th>类型</th><th>长度</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>bool</td><td>1</td><td>false</td><td></td></tr><tr><td>byte</td><td>1</td><td>0</td><td>uint8</td></tr><tr><td>rune</td><td>4</td><td>0</td><td>Unicode Code Point, int32</td></tr><tr><td>int, uint</td><td>4或8</td><td>0</td><td>32 或 64 位</td></tr><tr><td>int8, uint8</td><td>1</td><td>0</td><td>-128 ~ 127, 0 ~ 255</td></tr><tr><td>int16, uint16</td><td>2</td><td>0</td><td>-32768 ~ 32767, 0 ~ 65535</td></tr><tr><td>int32, uint32</td><td>4</td><td>0</td><td>-21亿~ 21亿, 0 ~ 42亿</td></tr><tr><td>int64, uint64</td><td>8</td><td>0</td><td></td></tr><tr><td>float32</td><td>4</td><td>0.0</td><td></td></tr><tr><td>float64</td><td>8</td><td>0.0</td><td></td></tr><tr><td>complex64</td><td>8</td><td></td><td></td></tr><tr><td>complex128</td><td>16</td><td></td><td></td></tr><tr><td>uintptr</td><td>4或8</td><td></td><td>⾜足以存储指针的 uint32 或 uint64整数</td></tr><tr><td>array</td><td></td><td></td><td>值类型</td></tr><tr><td>struct</td><td></td><td></td><td>值类型</td></tr><tr><td>string</td><td></td><td>“”</td><td>UTF-8 字符串</td></tr><tr><td>slice</td><td></td><td>nil</td><td>引⽤用类型</td></tr><tr><td>map</td><td></td><td>nil</td><td>引⽤用类型</td></tr><tr><td>channel</td><td></td><td>nil</td><td>引⽤用类型</td></tr><tr><td>interface</td><td></td><td>nil</td><td>接⼝</td></tr><tr><td>function</td><td></td><td>nil</td><td>函数</td></tr></tbody></table><p>支持八进制，十六进制以及科学计数法</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span>,<span class="selector-tag">b</span>,c := <span class="number">100</span>,<span class="number">0144</span>,<span class="number">0</span>x64</span><br><span class="line">fmt.Println(<span class="selector-tag">a</span>,<span class="selector-tag">b</span>,c)  <span class="comment">//100,100,100</span></span><br><span class="line">fmt.Printf(<span class="string">"0b%b,%#o,%#x"</span>,<span class="selector-tag">a</span>,<span class="selector-tag">b</span>,c)<span class="comment">//0b1100100,0144,0x64</span></span><br><span class="line">fmt.Prinln(math<span class="selector-class">.MaxInt8</span>,math,MinInt8)<span class="comment">//127,-128</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//进制转换到十进制</span></span><br><span class="line"><span class="selector-tag">a</span>,_ := strconv.ParseInt(<span class="string">"1100100"</span>,<span class="number">2</span>,<span class="number">32</span>)  <span class="comment">//100</span></span><br><span class="line"><span class="selector-tag">b</span>,_ := strconv.ParseInt(<span class="string">"0144"</span>,<span class="number">8</span>,<span class="number">32</span>)     <span class="comment">//100</span></span><br><span class="line">c,_ := strconv.ParseInt(<span class="string">"0x64"</span>,<span class="number">16</span>,<span class="number">32</span>)    <span class="comment">//100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//十进制转到其他进制</span></span><br><span class="line">strconv.FormatInt(<span class="selector-tag">a</span>,<span class="number">2</span>)  <span class="comment">//1100100</span></span><br><span class="line">strconv.FormatInt(<span class="selector-tag">a</span>,<span class="number">8</span>)  <span class="comment">//144</span></span><br><span class="line">strconv.FormatInt(<span class="selector-tag">a</span>,<span class="number">16</span>) <span class="comment">//64</span></span><br></pre></td></tr></table></figure><p>注意浮点数 默认浮点类型是<code>float64</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a float32 = <span class="number">1.123456789</span></span><br><span class="line"><span class="keyword">var</span> b float32 = <span class="number">1.123456781</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">c</span> float32 = <span class="number">1.12345678</span></span><br><span class="line"><span class="built_in">println</span>(a, b, <span class="built_in">c</span>)</span><br><span class="line"><span class="built_in">println</span>(a == b, b == <span class="built_in">c</span>, a == <span class="built_in">c</span>)</span><br><span class="line">fmt.<span class="type">Printf</span>(<span class="string">"%v,%v,%v"</span>, a, b, <span class="built_in">c</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+<span class="number">1.123457e</span>+<span class="number">000</span> +<span class="number">1.123457e</span>+<span class="number">000</span> +<span class="number">1.123457e</span>+<span class="number">000</span></span><br><span class="line"><span class="literal">true</span> <span class="literal">true</span> <span class="literal">true</span></span><br><span class="line"><span class="number">1.1234568</span>,<span class="number">1.1234568</span>,<span class="number">1.1234568</span></span><br></pre></td></tr></table></figure><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>byte 是 uint8 别名<br>rune 是 int32 别名<br>别名类型不需要转换可以直接赋值，比如下面这样没有问题。但是注意了，就算你在32操作系统上int 并不等于int32，在64位系统上int 并不等于int64</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">byte</span> = <span class="number">0x11</span></span><br><span class="line"><span class="keyword">var</span> y <span class="keyword">uint8</span> = x</span><br><span class="line"><span class="keyword">var</span> z <span class="keyword">uint8</span> = x + y</span><br><span class="line">test(z)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(x <span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>特指slice，map，chan 这三类<br>内置函数new按指定类型长度分配零值内存，返回指针，并不关心类型内部构造和初始化方式，而引用类型必须要使用make来创建，编译器会将make转为目标类型专用的创建函数（或指令），以确保全部内存分配和相关属性初始化。</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>不⽀支持隐式类型转换</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="number">10</span></span><br><span class="line">b := <span class="keyword">byte</span>(a)</span><br><span class="line">c := a + <span class="keyword">int</span>(b) <span class="comment">//混合表达式 必须保持类型一致，a自动推断为</span></span><br><span class="line"><span class="keyword">int</span> 所以a + 后面的也必须是<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> n <span class="keyword">int</span> = <span class="keyword">int</span>(b) <span class="comment">// 显式转换</span></span><br><span class="line"><span class="built_in">println</span>(a, b, c) <span class="comment">//10，10，20</span></span><br><span class="line"></span><br><span class="line">d := <span class="keyword">bool</span>(a) <span class="comment">//这里就有问题了</span></span><br></pre></td></tr></table></figure><p>如果转换的目标是<code>指针</code>，<code>单向通道</code>或者是<code>没有返回值的函数</code>,必须要使用括号。避免造成语法分析错误</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d := (*<span class="keyword">int</span>)(&amp;a)   <span class="comment">//0xc000032780</span></span><br><span class="line">e := (&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)(ch)</span><br><span class="line">f := (<span class="function"><span class="keyword">func</span><span class="params">()</span>)<span class="params">(x)</span></span></span><br><span class="line">g := <span class="function"><span class="keyword">func</span><span class="params">()</span><span class="title">int</span><span class="params">(x)</span> //有返回值的可以省略括号</span></span><br></pre></td></tr></table></figure><h2 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h2><p>使用关键字<code>type</code>定义，包括基于现有基础类型创建或者是结构体、函数类型等。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> flag <span class="keyword">byte</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">read flag = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span></span><br><span class="line">write</span><br><span class="line">exec</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">f := read | exec</span><br><span class="line">fmt.Printf(<span class="string">"%b\n"</span>,f)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//101</span></span><br></pre></td></tr></table></figure><p>和var 、const 类似，多个type定义可以合并成组，可以在函数或者代码块内定义局部类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">user <span class="keyword">struct</span> &#123;             <span class="comment">//结构体类型</span></span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age <span class="keyword">uint8</span></span><br><span class="line">&#125;</span><br><span class="line">event <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>)</span> <span class="title">bool</span>   //函数类型</span></span><br><span class="line">)</span><br><span class="line">u := user&#123;<span class="string">"huangby"</span>,<span class="number">30</span>&#125;</span><br><span class="line">fmt.Println(u)</span><br><span class="line"><span class="keyword">var</span> f event = <span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(s)</span><br><span class="line"><span class="keyword">return</span> s !=<span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line">f(<span class="string">"huangby"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="未命名类型"><a href="#未命名类型" class="headerlink" title="未命名类型"></a>未命名类型</h2><p>与有明确标识符的 bool、int、string 等类型相比，数组、切片、字典、通道等类型与具体类型的长度等属性有关，故称作为命了类型。<br>具有相同声明的未命名类型被视作同一类型。</p><ul><li>具有相同基类型的指针。</li><li>具有相同元素类型和长度的数组 array</li><li>具有相同元素类型的切片 slice</li><li>具有相同键值类型的字典  map</li><li>具有相同数据类型以及操作方向的通道 channel</li><li>具有相同字段序列（字段名、字段类型、标签、字段顺序）的结构体 struct</li><li>具有相同签名(参数和返回值，不包括参数名)的函数 func</li><li>具有相同方法集（方法名，方法签名）的接口 interface{}</li></ul><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>不能将内存地址与指针混为一谈<br>内存地址是内存中每个字节单元的唯一编号，指针则是一个实体。指针会分配内存空间，相当于一个专门用来保存地址的整形变量。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">             p := &amp;x             x:=100</span><br><span class="line"><span class="params">------------</span>|<span class="params">-------</span>|<span class="params">----</span>\\<span class="params">----</span>|<span class="params">---------</span>|<span class="params">-----</span></span><br><span class="line">memory.<span class="string">..</span>   |0x1200 |   ····   | 100     |</span><br><span class="line"><span class="params">------------</span>|<span class="params">-------</span>|<span class="params">----</span>\\<span class="params">----</span>|<span class="params">---------</span>|<span class="params">-----</span></span><br><span class="line">addr         0x80              0x1200 </span><br><span class="line"><span class="params">-----------------------------------------------</span></span><br></pre></td></tr></table></figure><ul><li><code>&amp;</code>符号用来获取对象地址</li><li>指针运算符<code>*</code>用于间接引用目标对象</li><li>二级指针 ** T,如包含包名则写成*package T</li></ul><p>并非所有的对象都能进行取地址操作，但变量总是能正确返回。指针运算符为左值时(*a = 20)，可以更新目标对象状态，而为右值时(a := *b)，则是为了获取目标状态。<br>指针支持相等运算，单不支持加减法和类型转换。</p><p>可以通过unsafe.Pointer将指针转换为 uintptr 后加减运算，但可能会造成非法访问。</p><p>Pointer类似于C中的void* 万能指针，可以用来转换指针类型。它能安全持有对象或对象成员，但是 uintptr 不行。uintptr 仅是一种特殊整形，并不引用目标对象，无法阻止垃圾回收器回收对象内存。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">a</span>,<span class="selector-tag">b</span>  struct&#123;&#125;</span><br><span class="line"><span class="function"><span class="title">println</span><span class="params">(&amp;a,&amp;b)</span></span>           <span class="comment">//都是0x---------</span></span><br><span class="line"><span class="function"><span class="title">println</span><span class="params">(&amp;a==&amp;b ,&amp;a==nil)</span></span> <span class="comment">//第一个不一定true  但是第二个肯定false</span></span><br></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>对复合类型（数组，切片，字典，结构体）变量初始化时，有一些语法限制。</p><ul><li>初始化表达式必须含有类型标签</li><li>左花括号必须在类型尾部，不能另起一行</li><li>多个成员初始值以逗号分隔</li><li>允许多行，但是每行必须以逗号或者右花括号结束。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span>&#123;</span><br><span class="line">x <span class="keyword">int</span></span><br><span class="line">s <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a data = data&#123;<span class="number">1</span>,<span class="string">"abc"</span>&#125;</span><br><span class="line">b := data&#123;<span class="number">2</span>,<span class="string">"def"</span>&#125;</span><br><span class="line">c := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"name"</span>:<span class="string">"huangby"</span>,<span class="string">"addr"</span>:<span class="string">"beijing"</span>&#125;</span><br><span class="line">d := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"name"</span>: <span class="string">"huangby"</span>, <span class="string">"addr"</span>: <span class="string">"beijing"</span>&#125;</span><br><span class="line">d[<span class="string">"a"</span>] = <span class="string">"acd"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//但是</span></span><br><span class="line"><span class="keyword">var</span> d <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">d[<span class="string">"a"</span>] = <span class="string">"acd"</span> 这就不行了</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本类型&quot;&gt;&lt;a href=&quot;#基本类型&quot; class=&quot;headerlink&quot; title=&quot;基本类型&quot;&gt;&lt;/a&gt;基本类型&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;长度&lt;/th&gt;
&lt;th&gt;默认值&lt;/th&gt;
&lt;th&gt;说明&lt;
      
    
    </summary>
    
    
      <category term="golang" scheme="https://devying.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://devying.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>golang变量和常量总结</title>
    <link href="https://devying.github.io/2018/01/01/golang%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/"/>
    <id>https://devying.github.io/2018/01/01/golang变量和常量/</id>
    <published>2017-12-31T16:23:02.000Z</published>
    <updated>2019-11-17T06:49:35.910Z</updated>
    
    <content type="html"><![CDATA[<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>Go变量总是有固定的数据类型，类型决定了变量内存的长度和存储格式。我们只能修改变量值，无法改变类型。</p><p><strong>通过类型转换或者指针操作，我们可以用不同方式修改变量值，但是这并不意味着改变了变量类型。</strong></p><h3 id="关键字var"><a href="#关键字var" class="headerlink" title="关键字var"></a>关键字var</h3><p>可以用于定义变量，运行时内存分配操作会确保变量自动初始化为二进制零值，避免出现不可预测行为。如果显式提供初始化值，可以省略变量类型，由编译器推断。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">int</span>   <span class="comment">//自动初始化为 0</span></span><br><span class="line"><span class="keyword">var</span> y = <span class="literal">false</span> <span class="comment">//自动推断为bool类型</span></span><br><span class="line"><span class="keyword">var</span> z <span class="keyword">int</span> = <span class="number">0</span> <span class="comment">//可以省略int</span></span><br></pre></td></tr></table></figure><p>一次性定义多个变量</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keywords">var</span> <span class="symbol">x</span>,<span class="symbol">y</span> int <span class="comment">//相同类型的多个变量</span></span><br><span class="line"><span class="keywords">var</span> a,s = <span class="number">100</span>, <span class="string">"abc"</span> <span class="comment">//不同类型初始化值</span></span><br></pre></td></tr></table></figure><p>按照惯例，以组的方式整理多行变量定义。</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keywords">var</span> (</span><br><span class="line">    <span class="symbol">x</span>, <span class="symbol">y</span> int</span><br><span class="line">    a, s = <span class="number">300</span>, <span class="string">"abc"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="简短模式"><a href="#简短模式" class="headerlink" title="简短模式"></a>简短模式</h3><p>除了var 关键字还可以用更简短的变量定义和初始化语法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x := <span class="number">100</span></span><br><span class="line">a,s := <span class="number">1</span>, <span class="string">"abc"</span></span><br></pre></td></tr></table></figure><p>简短模式有一些限制：</p><ul><li>定义变量，同时显式初始化</li><li>不能提供数据类型</li><li>只能用在函数内部</li></ul><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keywords">var</span> <span class="symbol">x</span> = <span class="number">100</span> <span class="comment">//全局变量</span></span><br><span class="line">func main()&#123;</span><br><span class="line">    fmt.Println(&amp;<span class="symbol">x</span>,<span class="symbol">x</span>)</span><br><span class="line">    <span class="symbol">x</span>:=<span class="string">"abc"</span> <span class="comment">//重新定义和初始化同名局部变量，局部有效</span></span><br><span class="line">    fmt.Println(&amp;<span class="symbol">x</span>,<span class="symbol">x</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">以上程序运行结果：</span><br><span class="line">两个&amp;<span class="symbol">x</span> 内存地址不一样，<span class="symbol">x</span>值也不一样，可以看出是两个不同的变量</span><br></pre></td></tr></table></figure><p><strong>简短模式在函数多值返回，以及if/for/switch等语句中定义局部变量非常方便</strong></p><p>简短模式并不总是重新定义变量的，还有可能是部分退化的赋值操作。另外退化赋值的前提条件是至少有一个新变量被定义，且在同一作用域。常见在函数返回err时，始终重复使用err变量</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func main()&#123;</span><br><span class="line">    <span class="symbol">x</span> := <span class="number">100</span></span><br><span class="line">    fmt.Println(&amp;<span class="symbol">x</span>)</span><br><span class="line">    <span class="symbol">x</span>, <span class="symbol">y</span> := <span class="number">20</span>,<span class="string">"abc"</span> <span class="comment">//</span></span><br><span class="line">    fmt.Println(&amp;<span class="symbol">x</span>,<span class="symbol">x</span>,<span class="symbol">y</span>)<span class="comment">//&amp;x是同一个 x这是退化赋值</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="symbol">x</span>,<span class="symbol">y</span> := <span class="number">12</span>,<span class="number">12</span> <span class="comment">//作用域不同，这里都是重新定义变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="未使用错误"><a href="#未使用错误" class="headerlink" title="未使用错误"></a>未使用错误</h3><p>编译的时候未使用的局部变量会报错，而全局变量不会。</p><h3 id="空标识符"><a href="#空标识符" class="headerlink" title="空标识符_"></a>空标识符_</h3><p>空标识符可临时用来规避编译器对未使用的变量或包的错误检查，但是请注意它是预置成员，不能重新定义。</p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量表示运行时恒定不可改变的值，通常是一些字面量。<br>常量必须是编译期可确定的<code>字符</code>、<code>字符串</code>、<code>数字</code>、<code>布尔值</code>，可指定常量类型或者由编译器通过初始化推断。不曾使用的常量不会编译报错。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x,y <span class="built_in">int</span> = <span class="number">123</span>,<span class="number">0x22</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="string">"hello"</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="string">'哈'</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    i,f = <span class="number">123</span>,<span class="number">2.3</span> <span class="comment">//int，float64(默认)</span></span><br><span class="line">    b = <span class="literal">false</span></span><br><span class="line">)</span><br><span class="line">func main()&#123;</span><br><span class="line">    <span class="keyword">const</span> s = <span class="number">45</span> <span class="comment">//可以在不同作用域定义同名常量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以是编译器可以计算出来的表达式(比如unsafe.Sizeof，cap,len等)，范围必须要正确</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    x, y = <span class="number">99</span>, <span class="number">-999</span></span><br><span class="line">    b byte = byte(<span class="name">x</span>) //b 是byte类型，必须显式的将x转为byte</span><br><span class="line">    n  = uint8(<span class="name">y</span>)  //错误范围溢出 </span><br><span class="line"></span><br><span class="line">    ptrSize = unsafe.Sizeof(<span class="name">uintptr</span>(<span class="number">0</span>))</span><br><span class="line">    strSize = len(<span class="string">"hello"</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在常量组中，如不指定类型和初始化值，则与上一行非空常量右值相同</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    x <span class="built_in">uint</span>16 = <span class="number">120</span> </span><br><span class="line">    y                <span class="comment">//与上一行x  右值、类型相同</span></span><br><span class="line">    s = <span class="string">"abc"</span></span><br><span class="line">    z                <span class="comment">//与上一行s  右值、类型相同</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>Go没有明确意义上的enum定义，但是可以借助<code>iota</code>标识符实现一组自增常量值，来实现枚举类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    x = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">    y        <span class="comment">//1</span></span><br><span class="line">    z        <span class="comment">//2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    _  = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">    KB =  <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)     <span class="comment">// 1 &lt;&lt; (10 * 1)</span></span><br><span class="line">    MB                         <span class="comment">// 1 &lt;&lt; (10 * 2)</span></span><br><span class="line">    GB                         <span class="comment">// 1 &lt;&lt; (10 * 3)</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>自增作用范围为常量组。可以在多常量定义中使用多个iota，它们各自单独计数，只需要确保组中每行常量个数相同即可</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">const</span> <span class="string">(</span></span><br><span class="line">    <span class="string">_,</span> <span class="string">_</span> <span class="string">=</span> <span class="string">iota</span> <span class="string">,iota</span> <span class="string">*</span> <span class="number">10</span>     <span class="string">//</span> <span class="number">0</span><span class="string">,</span> <span class="number">0</span> <span class="string">*</span> <span class="number">10</span></span><br><span class="line">    <span class="string">a,</span> <span class="string">b</span>                       <span class="string">//</span> <span class="number">1</span><span class="string">,</span> <span class="number">1</span> <span class="string">*</span> <span class="number">10</span></span><br><span class="line">    <span class="string">c,</span> <span class="string">d</span>                       <span class="string">//</span> <span class="number">2</span><span class="string">,</span> <span class="number">2</span> <span class="string">*</span> <span class="number">10</span></span><br><span class="line"><span class="string">)</span></span><br></pre></td></tr></table></figure><p>如果中断iota自增，必须显式恢复，切后续自增值按行序递增。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a  = <span class="literal">iota</span>     <span class="comment">//0</span></span><br><span class="line">    b             <span class="comment">//1</span></span><br><span class="line">    c  = <span class="number">100</span>      <span class="comment">//100</span></span><br><span class="line">    d             <span class="comment">//100 与上一行保持一致</span></span><br><span class="line">    e  = <span class="literal">iota</span>     <span class="comment">//4 恢复iota,行序递增</span></span><br><span class="line">    f             <span class="comment">//5</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>自增默认类型为int,当然你可以显示的指定类型</p><h3 id="常量和变量区别"><a href="#常量和变量区别" class="headerlink" title="常量和变量区别"></a>常量和变量区别</h3><p>常量是只读，不能取地址。数字常量不会分配存储空间，无需像变量那要通过内存寻址来取值，因此无法获取地址。<br>变量在运行期分配存储内存（非优化状态）常量通常会被编译器在预处理阶段直接展开，作为指令数据使用。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="number">100</span>      <span class="comment">//无类型声明的常量</span></span><br><span class="line"><span class="keyword">const</span> y byte = x   <span class="comment">//直接展开x,相当于const y byte = 100</span></span><br><span class="line"><span class="keyword">const</span> a <span class="built_in">int</span> = <span class="number">100</span>  <span class="comment">//显式指定常量类型，编译器会做强类型检查</span></span><br><span class="line"><span class="keyword">const</span> b byte = a   <span class="comment">//错误，can not use a （type int）as type byte in const initializer</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;变量&quot;&gt;&lt;a href=&quot;#变量&quot; class=&quot;headerlink&quot; title=&quot;变量&quot;&gt;&lt;/a&gt;变量&lt;/h2&gt;&lt;p&gt;Go变量总是有固定的数据类型，类型决定了变量内存的长度和存储格式。我们只能修改变量值，无法改变类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通过类型
      
    
    </summary>
    
    
      <category term="golang" scheme="https://devying.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://devying.github.io/tags/golang/"/>
    
  </entry>
  
</feed>
